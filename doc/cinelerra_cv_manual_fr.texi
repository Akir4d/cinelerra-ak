\input texinfo  @c -*-texinfo-*-

@c Manuel de Cinelerra CV - FRANCAIS
@c Site internet de Cinelerra Community Version : http://cvs.cinelerra.org
@c Coordinateur de la documentation : Nicolas MAUFRAIS - e.conti@gmx.net
@c Responsable du manuel en français : Jean-Luc COULON

@c Licence :
@c Vous pouvez redistribuer et/ou modifier le manuel de Cinelerra CV selon les
@c termes de la licence GNU GPL, telle que publiée par la Free Software
@c Foundation; que ce soit en version 2 de cette licence, ou (selon votre choix)
@c toute version ultérieure.

@c A garder dans les version du manuel autres qu'en anglais
@tex
\global\hyphenpenalty = 10000
@end tex

@setfilename cinelerra_cv_manual_fr.info
@documentlanguage fr
@documentencoding ISO-8859-15
@settitle Manuel de Cinelerra CV
@afourpaper
@set EDITION 1.24.FR
@set VERSION 2.1
@finalout

@titlepage
@title Manuel de Cinelerra CV
@subtitle @b{Editeur vidéo non-linéaire pour GNU/Linux}
@subtitle Community Version @value{VERSION}
@subtitle Edition @value{EDITION}
@author Heroine Virtual Ltd
@author Cinelerra CV Team
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2003, 2004, 2005, 2006 Jack Crossfire - Heroine Virtual Ltd.

Copyright @copyright{} 2003, 2004, 2005, 2006, 2007 Cinelerra CV Team.@*

Ce manuel est un document @w{libre ;} vous pouvez le redistribuer et/ou le
modifier au titre des clauses de la Licence Publique Générale GNU, telle que
publiée par la Free Software @w{Foundation ;} soit la version 2 de la Licence,
ou (à votre discrétion) une version ultérieure quelconque.

Ce document est distribué dans l'espoir qu'il sera utile, mais SANS AUCUNE
@w{GARANTIE ;} sans même une garantie implicite de COMMERCIABILITE ou DE
CONFORMITE A UNE UTILISATION PARTICULIERE. Voir la Licence Publique Générale
GNU pour plus de détails.
Vous devriez avoir reçu un exemplaire de la Licence Publique Générale GNU avec
ce @w{document;} si ce n'est pas le cas, écrivez à la Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA@.
@end titlepage
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thischapter @| @| @thispage

@setchapternewpage odd

@contents

@ifnottex
@c cincvdoc_node_number_1
@node Top
@top
@end ifnottex

@menu
* Introduction::                            	Cinelerra en bref.
* Installation::                            	Faire fonctionner Cinelerra sur votre système.
* Configuration::                           	Ajuster le comportement de Cinelerra.
* Attributs du projet::                     	Modifier la façon dont le média est affiché.
* Charger et enregistrer des fichiers::     	Déplacer le média entre le disque et Cinelerra.
* La fenêtre de programme::
* La fenêtre de composition::
* La fenêtre de la visionneuse::
* La fenêtre des ressources::
* La fenêtre des vu-mètres::
* Les commandes de transport::
* La barre temporelle::
* Les effets en temps réel::
* Les effets rendus::
* Les effets Ladspa::
* Les transitions::
* Les images-clés::                             Faire évoluer les effets au cours du temps.
* Faire l'acquisition de média::            	Déplacer les média du monde réel vers le disque.
* Le rendu de fichiers::
* Astuces::                             	Applications inhabituelles de Cinelerra à des problèmes courants.
* Résolution de problèmes::          		Problèmes avec Cinelerra.
* Création de greffons::                  	Comment écrire de nouveaux effets.
* Raccourcis clavier::                		Comment accélérer la plupart des commandes avec le clavier.
* Copies::                           		La Licence Publique Générale GNU.
@ifnotplaintext
@ifnothtml
@ifnotdocbook
* Index::                             		Menu couvrant de nombreuses rubriques.
@end ifnotdocbook
@end ifnothtml
@end ifnotplaintext
@end menu

@c cincvdoc_node_number_2
@node Introduction
@chapter Introduction
@cindex Introduction

@menu
* A propos de Cinelerra::
* Les deux versions de Cinelerra::
* A propos de ce manuel::
* Obtenir de l'aide::
* Tutoriels::
* Liens divers::
@end menu

@c cincvdoc_node_number_3
@node A propos de Cinelerra
@section A propos Cinelerra
@cindex A propos Cinelerra

Pendant des années, certaines personnes ont désiré disposer d'un moyen de
monter leur audio et leur vidéo depuis un seul endroit avec autant de facilité
que l'écriture d'un texte.  Cinelerra est une tentative pour réaliser ce voeux
et pour fournir, dans un seul logiciel, tout le nécessaire pour vos montages
audio et vidéo.  L'enregistrement, le montage et la lecture sont tous gérés
ici.  Il peut être utilisé comme lecteur audio.  Il peut aussi être utilisé
pour enregistrer de l'audio ou de la vidéo.  Il peut même être utilisé comme
logiciel de retouche de photos.

Il y a deux types de personnes impliquées dans les @w{films :} les producteurs qui
créent un nouveau contenu et qui reviennent ultérieurement sur celui-ci pour
l'améliorer encore, et le grand public qui veut acquérir le contenu et le
visionner.  Cinelerra n'est pas conçu pour le grand public.  Cinelerra possède
de nombreuses fonctionnalités pour gérer du contenu non compressé, pour le
traitement en haute définition et pour la composition.
Les producteurs ont besoin de ces fonctionnalités afin de pouvoir
retoucher de nombreuses générations de métrage,
et c'est ce qui rend Cinelerra si complexe.  Le grand public devrait envisager
l'utilisation d'autres outils, tels que MainActor, Kino ou Moxy.

@c cincvdoc_node_number_4
@node Les deux versions de Cinelerra
@section Les deux versions de Cinelerra
@cindex Les deux versions de Cinelerra

Il y a deux branches de Cinelerra.  L'une d'elle se trouve à
@uref{http://www.heroinewarrior.com} et l'autre à
@uref{http://cvs.cinelerra.org}.  Cette documentation concerne @b{Cinelerra-CV
(Community Version)}.

Les sources de la version officielle de Cinelerra sont développées "en amont" Par Heroine Virtual, Ltd (HV)
HV partage son code source avec une version communautaire de Cinelerra (Cinelerra-CV), mais
ne participe pas activement avec la communauté de developpeurs responsables de Cinelerra-CV@.  HV préfère travailler
sur sa propre copie de Cinelerra, en diffusant périodiquement le code tous les 6 mois environ.

Cinelerra-CV a été fondé par des développeurs qui souhaitaient étendre les
fonctionnalités et résoudre certains bugs présents dans le code source d'HV.
Ils ont décidé qu'il serait bien d'effectuer le développement de manière
communautaire, sans pour autant effectuer un "fork".  De ce fait, le code
source de Cinelerra CV est très proche de celui de la version officielle.  Les
développeurs de la version CV appliquent des résolutions de bugs
(@uref{http://bugs.cinelerra.org}), effectuent des correctifs de bogues et des
correctifs de compatibilité.  Les programmeurs envoyent occasionnellement des
correctifs en amont à HV@.  De ce fait, Cinelerra CV comporte certaines
fonctionnalités qu'on ne trouve pas dans la version officielle.

A la différence d'autres programmes, la version diffusée par HV ne peut pas
être qualifiée de "stable".  Après que la version de Cinelerra de HV ait été
diffusée, il reste souvent des problèmes, que ce soient des bogues ou en termes
de fonctionnalités.  Lorsqu'une nouvelle version est diffusée, un des membres
(j6t) effectue donc la fusion du code de HV avec le code de Cinelerra CV, en
prenant en compte les améliorations de HV et en réarrangeant le code afin qu'il
soit le plus similaire possible à celui de HV's (identation, nommage des
fonctions et des répertoires, modifications mineures de l'implémentation, etc.)
Après la fusion, la version diffusée de Cinelerra CV peut être légèrement
instable jusqu'à ce que tous les problèmes avec le nouveau code ajouté par HV
soient corrigés, que les utilisateurs découvrent les bogues et que nous ayons
le temps de les corriger.  Cinelerra CV peut être vu comme une tentative de la
communauté de stabiliser la version diffusée par HV@.

Comme indiqué, la communauté ajoute des améliorations au code source d'HV@.
Ses membres commentent mutuellement leurs implémentations afin de créer un
produit plus fonctionnel et stable.  Occasionnellement, HV commente les
implémentations que les membres de la communauté lui ont soumis.  Cependant,
les améliorations effectuées par la communauté ne remontent pas toutes dans la
version officielle; le rendu de flux YUV par exemple.

Après ce qui vient d'être dit, on peut dire que la version SVN telle qu'elle
est juste avant une opération de fusion est une version stabilisée.  Mais
soyiez conscient qu'il est possible que vous ayiez des problèmes avec des
fichiers de description de projet qui ne seront peut-être pas compatibles vers
la nouvelle version.  Avec une version quelconque de Cinelerra, trouver des
bugs est relativement aisé.  Cependant, décrire clairement et concisément ces
bugs à la communauté qui les corrige est une tâche que l'on est à même
d'espérer de la part de tous les utilisateurs.  La communauté est très
réactive.  Aidez-la en créant des rapports de bugs bien réalisés.  Vous pouvez
rejoindre notre mailing-liste à @uref{http://cvs.cinelerra.org}.

@c cincvdoc_node_number_5
@node A propos de ce manuel
@section A propos de ce manuel
@cindex A propos de ce manuel

L'édition de ce manuel est @value{EDITION}, et il s'applique à Cinelerra CV
version @value{VERSION}.  Vous pouvez le redistribueer et/ou le modifier selon
les termes de la Licence Publique Générale GNU (GPL), telle que publiée par la
Free Software Foundation ; soit à la version 2 de la licence ou (à votre
choix), toute autre version ultérieure.

Ce manuel est issu des "Secrets de Cinelerra", un excellent manuel écrit par
Jack @sc{Crossfire} d'@sc{Heroine Virtual Ltd}.  En 2003 Alex @sc{Ferrer} a
créé un Wiki basé sur ce manuel et a ajouté de nombreuses copies d'écran et
d'autres informations.  Jusqu'à ce jour, Cinelerra CV n'avait pas encore son
propre manuel et les informations concernant la version Communautaire de
Cinelerra étaient éparpillées sur Internet (liste de diffusion, IRC, sites Web,
wiki, etc.).  En 2006, Nicolas @sc{Maufrais} combina les "Secrets de Cinelerra"
avec le contenu se trouvant dans le Wiki d'Alex @sc{Ferrer} afin d'en faire un
document unifié.

Responsables de la documentation Cinelerra-CV :@*
Anglais : Nicolas @sc{Maufrais} (coordinateur)@*
Français : Jean-Luc @sc{Coulon}

Autre contributeurs : Alexandre @sc{Bourget}, Kevin @sc{Brosius}, Carlos
@sc{Davila}, Rafael @sc{Diniz}, Pierre @sc{Dumuid}, Mike @sc{Edwards}, Martin
@sc{Ellison}, Scott @sc{Frase}, Joe @sc{Friedrichsen}, Gus Gus, Terje @sc{Hanssen}, Mikko @sc{Huhtala}, Ben
@sc{Jorden}, Nathan @sc{Kidd}, Marcin @sc{Kostur}, Joseph @sc{L.}, Valentina @sc{Messeri},
Herman @sc{Robak}, Dana @sc{Rogers}, Jim @sc{Scott}, Andraz @sc{Tori}, Raffaella
@sc{Traniello}.

Merci à Karl @sc{Berry}, responsable de GNU texinfo, pour son aide et son
travail sur le fichier @file{texinfo.tex}, qui est utilisé pour construire ce
manuel.

Merci à l'équipe du projet GNU, et plus particulièrement à Karl @sc{Berry},
responsable de GNU Texinfo, pour l'aide très précieuse qu'il nous a apporté
durant l'élaboration de ce manuel.

@itemize
@item Pour obtenir les sources du manuel, installez cogito et git-core sur
votre ordinateur et @w{lancez :}@*
@command{cg-clone git://scm.pipapo.org/cinelerra/nicolasm}
@item Vous pouvez participer à l'édition de ce manuel en effectuant vos
modifications dans le wiki de @w{Cinelerra-CV :}@*
@uref{http://cvs.cinelerra.org/docs/wiki/doku.php}
@end itemize

@ifnotplaintext
@ifnothtml
@ifnotdocbook

@b{Note :} Ce manuel est destiné à être imprimé recto-verso.  Il est donc
normal que le manuel PDF comporte quelques pages paires laissées vierges.
@end ifnotdocbook
@end ifnothtml
@end ifnotplaintext

@c cincvdoc_node_number_6
@node Obtenir de l'aide
@section Obtenir de l'aide
@cindex Obtenir de l'aide
@cindex Aide, obtenir

On peut trouver de l'aide @w{sur :}
@itemize @bullet
@item @b{Le canal IRC :} #cinelerra sur Freenode
@item @b{La liste de diffusion :}
@uref{https://init.linpro.no/mailman/skolelinux.no/listinfo/cinelerra}
@item @b{Le site Web de Cinelerra CV :} @uref{http://cvs.cinelerra.org}
@end itemize

@c cincvdoc_node_number_327
@node Tutoriels
@section Tutoriels
@cindex Tutoriels

Quelques tutoriels sont disponibles sur internet:
@itemize @bullet
@item @b{Cinelerra Tutorial - Getting Started}, en anglais, par Rob @sc{Fisher}@*
@uref{http://www.robfisher.net/video/cinelerra1.html}
@item @b{Guide d'utilisation de Cinelerra}@*
@uref{http://www.funix.org/fr/linux/cinelerra.htm}
@item @b{Cinelerra video tutorials}, en anglais, par The Source@*
@uref{http://www.thesourceshow.org/node/11}@*
Le premier tutoriel est dans Episode 6 - "The Return Of The Pixel".@*
Le second tutoriel est dans Episode 1 - "The Filesystem Menace".
@item @b{Beginner's Guide to Exporting Video from Cinelerra}@*
En anglais, par Scott @sc{Frase}@*
@uref{http://content.serveftp.net/video/renderTest/guideToCinExport.html}
@item @b{Capturando e editando video usando Software Livre}, en portugais, par Rafael @sc{Diniz}@*
@uref{https://docs.indymedia.org/view/Sysadmin/Cinelerra}
@item @b{Tutorial Cinelerra}, en portugais, par Leo @sc{Germani}@*
@uref{http://www.estudiolivre.org/tiki-index.php?page=Cinelerra}
@item @b{Edici@'on de video bajo GNU/Linux (Cinelerra)}, en espagnol, par Gustavo I@~niguez @sc{Goya}@*
@uref{http://kutxa.homeunix.org/cinelerra}
@end itemize

@c cincvdoc_node_number_10
@node Liens divers
@section Liens divers
@cindex Liens divers

@w{Liens divers :}
@itemize @bullet
@item @b{What is Deinterlacing? Facts, solutions, examples}@*
Une page intéressante au sujet du désentrelacement (en anglais)@*
@uref{http://www.100fps.com}
@item @b{MPEG-2 FAQ}, en anglais@*
@uref{http://bmrc.berkeley.edu/frame/research/mpeg/mpeg2faq.html}
@item @b{"Exporting edited HD content back to the camcorder" (en anglais)}@*
@uref{http://dvinfo.net/conf/showthread.php?t=76674}
@end itemize

@c cincvdoc_node_number_7
@node Installation
@chapter Installation

@cindex Installation

Vous trouverez ci-dessous le contenu général des paquets de Cinelerra.

@itemize @bullet
@item @b{Traduction vers les langues étrangères} - on les trouve dans
@file{/usr/share/locale}
@item @b{Exécutable Cinelerra} - on le trouve dans @file{/usr/bin}
@item @b{Greffons Cinelerra} - on les trouve dans @file{/usr/lib/cinelerra}
pour les systèmes 32 bits, et dans @file{/usr/lib64/cinelerra} pour les
systèmes 64 bits.
@cindex Soundtest
@cindex Carte son, taille de tampon
@item @b{soundtest} - utilitaire pour déterminer la taille de tampon de la
carte-son.
@cindex mplexlo
@item @b{mplexlo} - multiplexage des flux MPEG élémentaires sans conformité
avec les normes mais plus efficacement.
@cindex mpeg3cat
@item @b{mpeg3cat} - utilitaire pour copier un fichier MPEG à partir d'une
certaine norme vers la sortie standard (stdout).
@cindex mpeg3toc
@cindex mpeg3dump
@item @b{mpeg3toc, mpeg3cat, mpeg3dump} - utilitaires pour indexer et lire des
fichiers MPEG
@cindex mpeg3peek
@item @b{mpeg3peek} - utilitaire pour afficher le décalage en octets d'une
image dans un flux MPEG.
@end itemize

@menu
* Prérequis matériels::
* Prérequis logiciels::
* Compiler Cinelerra CV::
* Lancer Cinelerra::
* Debian::
* Ubuntu::
* Gentoo::
* Live CD::
* Fedora::
* Mandriva::
* Slackware::
* Suse::
* MacOSX::
@end menu

@c cincvdoc_node_number_8
@node Prérequis matériels
@section Prérequis matériels
@cindex Prérequis matériels
@cindex Prérequis, matériels

Cinelerra est exigeant en terme de ressources matériel, puisque les demandes de
lecture, de décodage, de lecture de la vidéo peuvent être
assez pénalisantes et consommatrices de ressources.  En conséquence de quoi les performances et donc
la facilité d'utilisation de Cinelerra sont directement liées au format vidéo utilisé (SVCD/DV/HDV/HD/etc), à la puissance du processeur,
aux vitesses des bus d'entrées/sorties, à la capacité mémoire de votre système et l'architecture de son bus vidéo.
Ainsi, un système peu puissant sera suffisant pour les utilisateurs travaillant sur de l'audio uniquement ou bien sur
des vidéos en basse résolution.  Cependant, le même système pourra s'avérer insuffisant lors de la lecture
de vidéos en plus haute résolution, comme la vidéo DV.  La présence d'effets et de plusieurs pistes audio
vont accentuer ces problèmes.  En prenant en compte ces contraintes, voici quelques suggestions pour faire
fonctionner @w{Cinelerra :}

@itemize @bullet
@item @b{Vitesse CPU}@*
Une vitesse de processeur d'au moins 500 MHz, toute valeur inférieure sera
inutilisable.  Les processeurs à double coeurs et les systèmes multi-processeurs
améliorent sensiblement les performances de Cinelerra.
@item @b{Memoire}@*
Lorsqu'on travaille avec de la vidéo, une grande quantité de mémoire
disponsible peut aider à améliorer la vitesse en évitant les échanges non
nécessaires avec les disques et en rendant les matériaux toujours disponibles.
Vous devez disposer d'au moins 256 Mégaoctets de mémoire.  Afin de vraiment
utiliser Cinelerra avec des projets plus importants et des résolutions plus
élevées, un espace mémoire beaucoup plus important (> 1 Go) est recommandé.
@item @b{Espace disque}@*
L'édition vidéo peut être à l'origine de fréquents accès aux disques durs.  La
demande en espace disque dépend de vos besoins particuliers en montage vidéo.
Si vous pensez produire de longues vidéos dans des formats non compressés ou
bien en haute résolution, vous devriez utiliser un disque dur de grande
capacité (>200Go) et rapide (<10ms).  Par exemple le format DV utilise environ
3.5 Megs par seconde, soit 12 Go par heure.  Pour des projets plus petits 1Go
peut suffire.  Le RAID0, RAID 1+0 ou RAID5 améliorer aussi la vitesse de
lecture.
@item @b{Adaptateurs vidéo}@*
Depuis la version 2.1, Cinelerra tire profit de l'accélération matérielle
OpenGL@.  Assurez-vous que la carte vidéo que vous utilisez puisse gérer OpenGL
2.0 pour bénéficier de cette accélération.  Les cartes Nvidia série 7 (par
exemple 7600GS) sont connues pour bien fonctionner.  Malheureusement, les
pilotes ATI pour Linux ne supportent pas complètement l'OpenGL 2.0.  Si vous
êtes intéressé dans la production d'un signal vidéo composite à envoyer
directement vers un téléviseur ou un magnétoscope, assurez-vous que la carte
vidéo que vous avez choisi possède cette fonctionnalité.
@item @b{Moniteurs multiples}@*
Vous pouvez utiliser la fonctionnalité Xinerama de XFree86 afin de travailler
avec plusieurs moniteurs.  Cette fonctionnalité peut être une manière très
efficace d'améliorer votre productivité.
@item @b{Sortie TV}@*
Si votre adaptateur dispose d'une sortie TV, y connecter un téléviseur ou un
moniteur S-Vidéo est une bonne manière de visualiser votre matériau tel qu'il
le sera sur un écran de télévision.
@item @b{Cartes d'acquisition vidéo}@*
Si vous avez un caméscope analogique, ou si vous voulez faire l'acquisition de
vidéo depuis un magnétoscope vraiment ancien, il vous faut disposer d'une carte
d'acquisition.  Les cartes d'acquisition vidéo sont gérées sous Cinelerra au
travers de Video4Linux.
@item @b{Firewire}@*
Le firewire est le moyen le plus rapide de télécharger votre matériau dans
votre système.  A moins que vous ne chargiez votre matériau depuis un CD, d'un
autre format pré-capturé ou bien utilisiez un système d'acquisition vidéo
analogique, il vous faudra disposer du firewire sur votre système.
@item @b{Caméscopes DV}@*
Il existe une grande variété de caméscopes DV pouvant être utilisés avec
Cinelerra.  La plupart des caméscopes ayant une connexion firewire
fonctionnent.  Soyiez sûr de définir correctement les paramètres du système
d'acquisition vidéo afin qu'il corresponde à votre caméscope.
@uref{http://www.linux1394.org} pour une liste exhaustive des camescopes
supportés.
@end itemize

@c cincvdoc_node_number_9
@node Prérequis logiciels
@section Prérequis logiciels
@cindex Prérequis logiciels
@cindex Prérequis, logiciel

Afin de pouvoir installer Cinelerra, vous devriez avoir une version récente de
Linux avec XFree86 et un logiciel de gestion audio fonctionnant correctement.
Les bibliothèques suivantes devraient aussi être installées sur votre système
(liste non exhaustive) :
@itemize @bullet
@item a52dec
@item dv
@item faac
@item ffmpeg
@item fftw
@item lame
@item libavc1394
@item libfaad2
@item libraw1394
@item mjpegtools
@item OpenEXR
@item theora
@item x264
@end itemize

@c cincvdoc_node_number_11
@node Compiler Cinelerra CV
@section Compiler Cinelerra CV
@cindex Compiler Cinelerra CV

@menu
* Processus de compilation habituel::
* Compiler avec les symboles de débogage::
@end menu

@c cincvdoc_node_number_12
@node Processus de compilation habituel
@subsection Processus de compilation habituel
@cindex Processus de compilation habituel

Vous pouvez installer Cinelerra CV en récupérant les sources et en les
compilant vous-même.  C'est la méthode à utiliser si vous désirez utiliser la
version de Cinelerra CV la plus à jour.

@enumerate 1
@item Vous devez d'abord récupérer les sources de Cinelerra CV depuis le dépôt
SVN (environ 170Mo).  @w{Lancez :}@*
@command{svn checkout svn://svn.skolelinux.org/cinelerra/trunk/hvirtual}@*
Si vous avez déjà récupéré précédemment les sources d'une ancienne antérieure,
vous pouvez effectuer la mise à jour vers la dernière version en lançant,
depuis le dossier @w{@file{hvirtual} :}@*
@command{svn update}@*
Si vous désirez récupérer une ancienne version, @w{lancez :}@*
@command{svn checkout -r <révision>
svn://svn.skolelinux.org/cinelerra/trunk/hvirtual}

@item Allez dans le répertoire @w{hvirtual :}@*
@command{cd hvirtual}

@item Créez le fichier @file{./configure} en utilisant la @w{commande :}@*
@command{autoreconf -i --force}

@item Lancez ensuite @w{@file{.configure} :}@*
@command{./configure --with-buildinfo=svn/recompile}@*
Vous pouvez afficher les options disponibles à l'aide de la @w{commande :}@*
@command{./configure --help}

@item Et lancez @w{make :}@*
@command{make}
Si vous désirez enregistrer dans un fichier la sortie de make, afin de pouvoir
rechercher les erreurs, vous pouvez utiliser cette @w{commande :}@*
@command{make 2>&1 | tee logfile}

@item Finallement, installez Cinelerra @w{CV :}@*
@command{sudo make install}
@end enumerate

@b{Note :}
@itemize @bullet
@item @b{Machine SMP :}@*
Si vous compilez Cinelerra CV sur une machine multiprocesseur (SMP), nous vous
recommandons d'ajouter l'option @option{-j 3} afin de tirer bénéfice de la
présence de processeurs supplémentaires.
@item @b{Pour les processeurs x86 uniquement :}@*
Vous voudrez probablement activer la gestion MMX@.  Afin de le faire, lancez la
commande @command{./configure} avec l'option @option{--enable-mmx}.  Si vous le
faites, vous devrez utiliser conjointement l'option @option{--without-pic},
sinon, la compilation peut échouer.
@item @b{Pour les Pentium-M :}@*
Voici quelques options de @w{compilation :}@*
@command{./configure --prefix=/usr --enable-x86 --enable-mmx --enable-freetype2
--with-buildinfo=svn/recompile CFLAGS='-O3 -pipe -fomit-frame-pointer
-funroll-all-loops -falign-loops=2 -falign-jumps=2 -falign-functions=2
-ffast-math -march=pentium-m -mfpmath=sse,387 -mmmx -msse'}
@item @b{Installer plusieurs versions :}@*
Si vous désirez installer plusieurs versions de Cinelerra CV sur votre
ordinateur, créez un dossier @file{/usr/local_cinelerra}, et utilisez les
options suivantes avec la commande @command{./configure} (remplacer
@option{xxx} par le numéro de la révision que vous @w{compilez) :}@*
@option{--prefix=/usr/local_cinelerra/rxxx
--exec-prefix=/usr/local_cinelerra/rxxx --program-suffix=_rxxx}@*
Si vous installez Cinelerra en utilisant cette méthode, les fichiers de
traduction @file{.po} ne seront pas correctement installés.  Allez dans le
répertoire @file{hvirtual} où se trouvent les sources et @w{lancez :}@*
@command{./configure prefix=/usr}@*
@command{cd po}@*
@command{sudo make install}@*
Vous devrez lancer Cinelerra CV depuis le répertoire où il est @w{installé :}
@*
@command{cd /usr/local_cinelerra/r960}@*
@command{./cinelerra_r960}
@item @b{Version d'automake :}@*
Pour compiler le programme, vous aurez besoin de la version 1.7 d'automake.  La
version 1.4 ne fonctionnera pas.  Il est nécessaire aussi d'avoir autoconf
2.57.
@end itemize

@c cincvdoc_node_number_13
@node Compiler avec les symboles de débogage
@subsection Compiler avec les symboles de débogage
@cindex Compiler avec les symboles de débogage

Lorsque Cinelerra CV plante, on peut le compiler avec les symboles de débogage
et le lancer depuis gdb.  Les informations affichées par gdb sont beaucoup plus
détaillées et aideront les développeurs à résoudre les bogues plus rapidement.

D'abord, récupérez les sources comme d'habitude.  Ensuite, lancez les commandes
@w{suivantes :}@*
@command{cd hvirtual}@*
@command{nice -19 autoreconf -i --force}@*
@command{mkdir ../hvdbg}@*
@command{cd ../hvdbg}@*
@command{nice -19 ../hvirtual/configure CXXFLAGS='-O0 -g' CFLAGS='-O0 -g'
--with-buildinfo=svn/recompile}@*
@command{cd quicktime/ffmpeg}@*
@command{nice -19 make CFLAGS='-O3'}@*
@command{cd ../..}@*
@command{nice -19 make}@*
@command{nice -19 make install}

@xref{Signaler des bogues}, pour avoir plus d'informations concernant
l'exécution de Cinelerra depuis gdb.

@c cincvdoc_node_number_14
@node Lancer Cinelerra
@section Lancer Cinelerra
@cindex Cinelerra, lancer

La manière la plus simple de lancer Cinelerra est de lancer la commande
@command{/usr/bin/cinelerra}@*
Les options en ligne de commande sont aussi disponibles en tapant
@command{cinelerra -h}.  Ces options sont décrites dans d'autres sections
ci-dessous.  Pour effectuer le rendu en ligne de commande @xref{Le rendu de
fichiers}.

Si l'erreur suivante s'affiche lorsque vous lancez Cinelerra pour la première
@w{fois :}
@verbatim
WARNING:/proc/sys/kernel/shmmax is 0x2000000, which is too low}
@end verbatim
@xref{Libérer davantage de mémoire partagée}, pour plus d'information.

@c cincvdoc_node_number_15
@node Debian
@section Debian
@cindex Debian

@menu
* Binaires Debian::
* Prérequis pour Debian::
@end menu

@c cincvdoc_node_number_16
@node Binaires Debian
@subsection Binaires Debian
@cindex Binaires Debian
@cindex Binaires, Debian

Andraz @sc{Tori} maintient les règles de constructions pour Debian Sid.  Il
construit également des paquets binaires .deb pour Sid.  Ils sont construits
depuis les versions SVN non officielles.  Les paquets pour Debian Sid se
trouvent ici :
@itemize @bullet
@item @b{Source apt pour i386 :}@*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/sid/ ./}}
@item @b{Source apt pour Pentium4 (optimisé) :}@*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/pentium4/ ./}}
@item @b{Source apt pour Pentium-M (optimisé) :}@*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/pentiumm/ ./}}
@item @b{Source apt pour AthlonXP (optimisé) :}@*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/athlonxp/ ./}}
@item @b{Source apt pour Athlon64 (optimisé) :}@*
@command{@w{deb http://labbs.net/~vale/debian ./}}
@end itemize

@b{Note :} Si Cinelerra retourne l'erreur @w{suivante :}@*
@command{cinelerra: relocation error: /usr/lib/libavcodec.so.0.4.8: undefined
symbol: faacDecOpen}@*
Vous pouvez résoudre ce problème en entrant la commande suivante en tant
qu'administrateur @w{(root) :}@*
@command{apt-get install --reinstall libfaad2-0=2.0.0-0.5}

@c cincvdoc_node_number_17
@node Prérequis pour Debian
@subsection Prérequis pour Debian
@cindex Prérequis pour Debian
@cindex Prérequis, Debian

Vous aurez besoin de certains logiciels prérequis qui ne se trouvent pas dans
les dépôts officiels de Debian.  Vous pouvez ajouter à votre fichier
@file{/etc/apt/sources.list} la ligne suivante qui est le dépôt de Christian
@w{Marillat :}@*
@command{deb http://www.debian-multimedia.org/ sid main}

Pour pouvoir utiliser ce miroir, vous devrez ajouter la clé gpg de Marillat à
votre trousseau de clés @w{gpg :}@*
@command{gpg --keyserver hkp://wwwkeys.eu.pgp.net --recv-keys 1F41B907}@*
@command{gpg --armor --export 1F41B907 | sudo apt-key add -}@*
Si vous n'utilisez pas sudo, faites ce qui suit en tant qu'administrateur
@w{(root) :}@*
@command{gpg --armor --export 1F41B907 | apt-key add -}

@c cincvdoc_node_number_325
@node Ubuntu
@section Ubuntu
@cindex Ubuntu

@sc{Muzzol} a fabriqué des paquets pour Cinelerra sous Ubuntu Edgy.  Pour
réaliser l'installation au moyen du @b{gestionnaire de paquets Synaptic}, allez
dans @b{Configuration --> Dépôts}.  Dans la fenêtre de gestion des paquets,
cliquez sur le bouton @b{Ajouter} et renseignez les dépôts @w{suivants :}

@verbatim
deb http://www.kiberpipa.org/~muzzol/cinelerra/edgy-i386/ ./
@end verbatim

En cliquant sur @b{Ajouter le dépôt} vous verrez le nouveau dépôt activé dans
la fenêtre de gestion des paquets.  Vous pouvez aussi ajouter directement les
lignes suivantes dans le fichier @file{/etc/apt/sources.list} :

@verbatim
deb http://www.kiberpipa.org/~muzzol/cinelerra/edgy-i386/ ./
@end verbatim

Vous verrez alors apparaître Cinelerra dans Synaptic.

Pour installer Cinelerra avec @b{GDebi}, consultez cette @w{page :}@*
@uref{http://www.kiberpipa.org/~muzzol/cinelerra/edgy-i386/}.@*
Cliquez sur le lien @b{cinelerra_2.1.0+svn20070109-0ubuntu1_i386.deb}.  Une
fenêtre de dialogue va alors s'ouvrir vous demandant de confirmer votre
intention d'ouvrir ce fichier avec GDebi.  Si durant l'installation vous
rencontrez des problèmes de dépendances non satisfaites, essayez d'installer
les librairies manquantes en utilisant la même méthode, et la même page
internet.

Valentina @sc{Messeri} a aussi construit des paquets pour Ubuntu @w{Edgy :}

@b{Pour Ubuntu Edgy:}
@verbatim
deb http://giss.tv/~vale/ubuntu32 ./
deb-src http://giss.tv/~vale/ubuntu32 ./
@end verbatim

@b{Pour Ubuntu Edgy AMD64:}
@verbatim
deb http://giss.tv/~vale/ubuntu64 ./
deb-src http://giss.tv/~vale/ubuntu64 ./
@end verbatim

Les personnes désirant compiler Cinelerra peuvent consulter le tutoriel dédié à
l'installation de Cinelerra sur Ubuntu (en anglais) à cet @w{endroit :}@*
@uref{http://www.ubuntuforums.org/showthread.php?t=320701&highlight=cinelerra}

@c cincvdoc_node_number_18
@node Gentoo
@section Gentoo
@cindex Gentoo

L'installation sur Gentoo GNU/Linux est assez simple.  Lancez @w{simplement :}
@verbatim
emerge cinelerra-cvs
@end verbatim
avec le compte root et l'installation devrait s'effectuer sans problème.  Notez
que vous pouvez avoir besoin de placer Cinelerra dans le fichier
@file{/etc/portage/package.keywords} afin de pouvoir @w{l'utiliser :}
@verbatim
echo "=media-video/cinelerra-cvs-20061020" >> /etc/portage/package.keywords
@end verbatim

Voyez
@uref{http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=3&chap=3}
pour plus d'information.

@b{Note:} L'ebuild Gentoo media-video/cinelerra-cvs-20061020 ne possède pas
d'icônes de modes d'édition.  @xref{r943_r944_editing_modes,,The insertion
point}, pour plus d'information.

L'installation pour Gentoo GNU/Linux est aisée.  Lancez @w{simplement :}@*
@command{emerge cinelerra}@*
en tant qu'administrateur et il devrait s'installer et fonctionner sans
problème.

@c cincvdoc_node_number_19
@node Live CD
@section Live CD
@cindex Live CD

Vous pouvez essayer et utiliser Cinelerra sur votre ordinateur sans avoir à
l'installer sur le disque-dur.  Ceci est rendu possible grâce aux Live CD, qui
sont des distributions GNU/Linux démarrant à partir d'un CD, sans qu'il soit
nécessaire d'installer quoi que ce soit sur l'ordinateur.  Voici quelques
distributions Live CD qui contiennent @w{Cinelerra :}

@itemize @bullet
@item @b{Knoppix} - la distribution LiveCD "originale", basée sur Debian -
@uref{http://www.knoppix.org}
@item @b{dyne:bolic} - pour la production multimédia - repose sur l'utilisation
du gestionnaire de fenêtres Window Maker - @uref{http://www.dynebolic.org}
@item @b{Elive} - distribution basée sur Debian, qui utilise le gestionnaire de
fenêtres Enlightenment - @uref{http://www.elivecd.org}
@item @b{Mediainlinux} - basée sur Knoppix - @uref{http://www.mediainlinux.org/}
@item @b{pho} (garbure) - dédiée à l'édition vidéo -
@uref{http://garbure.org/pho/}   
@item @b{Slo-Tech} - basée sur Debian et Morphix -
@uref{http://linux.slo-tech.com}
@end itemize


Knoppix est un CD amorçable comportant une collection de logiciels GNU/Linux,
une détection automatique du matériel, et la gestion de nombreuses cartes
graphiques, cartes son, périphériques SCSI, USB ou autres.  Knoppix peut être
utilisé comme démonstration de GNU/Linux, comme CD éducatif, comme système de
dépannage, ou adapté et utilisé comme plateforme pour des démonstrations de
logiciels commerciaux.  Il n'est pas nécessaire d'installer Knoppix sur le
disque dur.  @w{(source :} @uref{http://www.knoppix.org})

Distributions Knoppix connues incluant Cinelerra :
@itemize @bullet
@item @uref{http://www.dynebolic.org}
@item @uref{http://linux.slo-tech.com}
@item @uref{http://garbure.org/pho}
@end itemize

@c cincvdoc_node_number_326
@node Fedora
@section Fedora
@cindex Fedora

Cinelerra est inclu dans le dépôt Freshrpms à l'adresse
@uref{http://freshrpms.net}.  La méthode la plus simple pour installer des
paquets depuis Freshrpms est d'inclure ce dépôt dans la configuration de
@b{yum}.  Vérifiez bien que le dépôt "Extras" de Fedora est activé.  C'est le
cas par défaut pour Fedora 5 et 6, et les dépôts Core et Extras ne font plus
qu'un pour Fedora 7.

Sous Fedora 6, tapez depuis le compte @w{root :}
@verbatim
rpm -ivh http://ftp.freshrpms.net/pub/freshrpms/fedora/linux/6/\
freshrpms-release/freshrpms-release-1.1-1.fc.noarch.rpm
@end verbatim

Sous Fedora 5, @w{tapez :}
@verbatim
rpm -ivh http://ftp.freshrpms.net/pub/freshrpms/fedora/linux/5/\
freshrpms-release/freshrpms-release-1.1-1.fc.noarch.rpm
@end verbatim

Ensuite, @w{tapez :}
@verbatim
yum -y install cinelerra
@end verbatim
afin de récupérer et installer Cinelerra et ses dépendances, y compris ffmpeg
et mjpegtools.  Si cela ne fonctionne pas, examinez le fichier
@file{/etc/yum.conf} et vérifiez que le paramétrage pour Freshrpms et bien
récupéré depuis @file{/etc/yum.repos.d}.

@b{Notes :}
@itemize @bullet
@item 
La collection de paquets du dépôt Freshrpms peut entrer en conflit avec des
dépôts tiers tels que Livna ou RPMForge, qui peuvent eux-aussi fournir des
librairies audio et vidéo, ainsi que Cinelerra.  Il est préférable de se
contenter de l'utilisation d'un seul dépôt, et de ne pas mélanger des paquets
provenant de dépôts tiers différents.
@item Les fichies d'entête de plusieurs librairies sont nécessaires pour
compiler Cinelerra depuis son code-source.  Les fichiers d'entête sont présents
dans des paquets de développement qui sont disponibles dans les dépôts de
Fedora et Freshrpms, et peuvent être installés avec yum.  Les paquets suivants
sont nécessaires (il ne s'agit pas d'une liste @w{exhaustive) :}@*
OpenEXR-devel SDL-devel a52dec-devel alsa-lib-devel e2fsprogs-devel faac-devel
faad2-devel ffmpeg-devel fftw-devel imlib2-devel lame-devel libXv-devel
libXxf86vm-devel libavc1394-devel libdv-devel libiec61883-devel libogg-devel
libraw1394-devel libsndfile-devel libtheora-devel libvorbis-devel
mjpegtools-devel x264-devel xvidcore-devel
@end itemize

@c cincvdoc_node_number_20
@node Mandriva
@section Mandriva
@cindex Mandriva

Des paquets Cinelerra pour Mandriva sont mis à disposition par PLF et prêts à
être installés.  Lisez la page @uref{http://plf.zarb.org/packages.php} pour
plus d'information.

@c cincvdoc_node_number_21
@node Slackware
@section Slackware
@cindex Slackware

Rafael @sc{Diniz} construit des paquets Slackware de Cinelerra.

@itemize @bullet
@item @b{Pour x86 :}@*
@uref{http://slack.sarava.org/packages/slackware/slackware-11.0/multimedia/}
@item @b{Pour slackintosh :}@*
@uref{http://slack.sarava.org/packages/slackintosh/slackintosh-11.0/multimedia/}
@end itemize

@c cincvdoc_node_number_22
@node Suse
@section Suse
@cindex Suse

Des RPM pour SuSE 9 sont construit depuis les sources SVN par Kevin
@sc{Brosius}, ils sont disponibles à @uref{http://cin.kevb.net/files/RPM/}

Des RPMs pour OpenSUSE 10.1 et 10.2, architecture i586 et x86_64, sont
construits à partir des sources SVN par Leon @sc{Freitag} chez Packman.  Ils
sont disponibles à
@uref{http://packman.links2linux.org/package/cinelerra/16413}.

Les packages RPM peuvent être installés avec le compte root dans une console en
utilisant cette @w{commande :}
@verbatim
rpm -Uvh package_name.rpm
@end verbatim

L'exemple qui suit montre quatre copies d'écrans d'installation graphique de
Cinelerra sur OpenSUSE 10.2 i586 en utilisant YaST2.  Tout d'abord en ajoutant
le répertoire YaST2 de Packman aux sources d'installation, et ensuite en
ajoutant le paquet d'installation avec le gestionnaire de logiciels YaST2.

Démarrez le centre de contrôle YaST sur OpenSUSE 10.2 et entrez le mot de passe de root
lorsqu'on vous le @w{demande :}

@center @image{manual_images_intl/yast2_control_center,100mm}

Démarrez l'outil YaST2 d'installation des sources, et sélectionnez le protocole
HTTP et ajoutez le nom du serveur pour Packman, comme indiqué.  La
synchronisation avec Zenworks peut prendre quelque temps, attendez que cela
soit terminé.

@center @image{manual_images_intl/yast2_installation_source,120mm}

Démarrez le gestionnaire de logiciel de YaST2.  Entrez "Cinelerra" dans le
champs de recherche situé à gauche et ensuite cochez les paquets Cinelerra
situés dans la fenêtre de droite.  Si une ancienne version de Cinelerra est
installée, elle est indiquée avec une icône représentant un cadenas.
Effacez-la ou bien tentez une mise à jour.

@center @image{manual_images_intl/yast2_cinelerra_installation,120mm}

Cliquez sur Accepter pour lancer l'installation du paquet, puis cliquez sur
Suivant pour terminer l'installation.

@center @image{manual_images_intl/yast2_package_installation,120mm}

@c cincvdoc_node_number_23
@node MacOSX
@section MacOSX
@cindex MacOSX

FIXME

@c cincvdoc_node_number_24
@node Configuration
@chapter Configuration
@cindex Configuration

En raison de sa flexibilité, Cinelerra ne peut tourner de manière optimale sans
être finement configuré pour répondre à vos besoins particuliers.
Malheureusement, peu de paramètres sont ajustables lors de la compilation.  En
conséquence de quoi la configuration lors de l'exécution est la seule
possibilité pour la plupart des systèmes en raison de la multitude des
paramètres.@*
Ci-dessous se trouvent les options de configuration ainsi que les différentes
API de GNU/Linux qui sont supportées.@*
Dans Cinelerra, allez à @b{Configuration->Préférences} afin de voir les
options.

@menu
* Variables d'environnement::	Ces variables d'environnement sont reconnues par Cinelerra.
* Pilotes audio::          	Informations concernant les pilotes audio.
* Pilotes vidéo::          	Informations concernant les pilotes vidéo.
* Lecture::			Configurer les paramètres relatifs à la lecture.
* Acquisition::		        Configurer les paramètres relatifs à l'enregistrement.
* Performances::            	Configurer les paramètres permettant d'accélérer les choses.
* Interface::              	Configurer l'interface utilisateur.
* A propos::                  	Afficher certaines informations concernant le programme.
@end menu

@c cincvdoc_node_number_25
@node Variables d'environnement
@section Variables d'environnement
@cindex Variables d'environnement
@cindex Ladspa, chemin

Dans les variantes d'UNIX, les variables d'environnement sont des variables
globales de l'interpréteur de commande (shell) que toutes les applications
peuvent lire.  Elles sont définies en utilisant des commandes telles que
@command{set VARIABLE=value}.  Toutes les variables d'environnement peuvent
être affichées avec la commande @command{env}.  Cinelerra reconnaît les
variables d'environnement suivantes :

@itemize @bullet
@item @b{LADSPA_PATH}@*
Cette variable doit être définie si vous désirez utiliser des greffons LADSPA ;
c'est une liste de répertoires, séparés par des ":", où les greffons LADSPA
sont recherchés.  Ce ne sont pas des greffons natifs de Cinelerra.  @xref{Les
effets Ladspa}.

@item @b{GLOBAL_PLUGIN_DIR}@*
C'est le répertoire où Cinelerra recherchera les greffons natifs.  La valeur
par défaut est @file{/usr/lib/cinelerra} mais vous pouvez avoir besoin d'un
autre répertoire si vous partagez le même répertoire exécutable avec de
nombreuses machines via NFS@.  Des greffons ayant des formats binaires
différents doivent se trouver dans des répertoires différents.

@item @b{LANG}@*
Cinelerra a été traduit dans de nombreuses langues.  Les paramètres de langue
de Cinelerra sont normalement lus depuis vos paramètres régionaux de GNU/Linux.
Pour faire tourner Cinelerra dans une langue différente de celle de votre
système.  Modifiez simplement la variable d'environnement LANG@.
Par exemple ouvrez un terminal et entrez la @w{commande :} @command{export
LANG=fr_FR}, et lancez ensuite @command{cinelerra} depuis la même fenêtre.  Il va
s'ouvrir configuré en français.@*
Les langues disponibles sont :
@itemize @bullet
@item en_EN - anglais
@item es_ES - espagnol
@item sl_SI - slovène
@item fr_FR - francais
@item eu_ES - Euskera
@item de_DE - allemand
@item pt_BR - portugais (Brésil)
@item it_IT - Italien
@end itemize
Si vous avez installé Cinelerra CV en le compilant depuis les sources, et que
vous avez indiqué une option @option{--prefix=} différente de
@file{/usr/local}, les fichiers traduits ne seront probablement pas installés.
@xref{Processus de compilation habituel}, pour davantage d'informations.
@end itemize

@c cincvdoc_node_number_26
@node Pilotes audio
@section Pilotes audio
@cindex Pilotes audio

Les pilotes audio sont utilisés à la fois pour l'enregistrement et la lecture
du son.  Leur fonctionnalité est décrite ici dans une section @w{ci-dessous :}

@menu
* Attributs communs aux pilotes audio:: attributs qui ne sont pas propres à un seul pilote audio.
* OSS:: notes concernant le pilote OSS.
* OSS Envy24:: notes concernant le pilote OSS pour le composant Envy24.
* Alsa:: notes concernant le pilote ALSA.
* Esound:: notes concernant le pilote ESound.
* Raw 1394:: notes concernant le pilote Raw1394.
* DV 1394:: notes concernant le pilote DV1394.
* IEC 61883:: notes concernant le pilote IEC 61883.
@end menu

@c cincvdoc_node_number_27
@node Attributs communs aux pilotes audio
@subsection Attributs communs aux pilotes audio
@cindex Attributs communs aux pilotes audio

@itemize @bullet
@item @b{Chemin vers le périphérique} @*
C'est habituellement un fichier dans le répertoire @file{/dev/}, qui contrôle
le périphérique.

@item @b{Bits}@*
Nombre de bits de précision pour lequel Cinelerra doit configurer le
périphérique.  Ceci a parfois une signification figurée.  Certains pilotes
audio ont besoin d'être configurés avec 32 bits pour pouvoir effectuer la
lecture du son sous 24 bits et ne joueront rien s'ils sont configurés avec 24
bits.  Certains pilotes ont besoin d'être configurés avec 24 bits pour une
lecture du son en 24 bits.

@item @b{Canaux}@*
Nombre de canaux devant être configurés par Cinelerra pour le périphérique.
Indépendemment du nombre de canaux du projet, le nombre de canaux configurés
ici sera écrit à destination du périphérique.  Lorsqu'il est défini à 2 et que
le projet n'a qu'un canal, vous pourrez entendre le son par le haut-parleur de
gauche et non centré comme on pourrait s'y attendre avec un projet mono.
Lorsqu'il est défini à 1 et que le projet a deux canaux, vous entendrez le
canal de gauche centré et non les deux canaux mélangés.
@end itemize

@c cincvdoc_node_number_28
@node OSS
@subsection OSS
@cindex OSS

Ce fut le premier pilote audio pour GNU/Linux.  Il possédait une implémentation
libre ainsi qu'une implémentation commerciale qui pouvait gérer davantage de
cartes.  C'était le pilote audio standard jusqu'à GNU/Linux 2.4.  C'est encore
le seul pilote audio avec lequel un binaire i386 peut être utilisé lorsqu'il
tourne sur un système x86_64.

@c cincvdoc_node_number_29
@node OSS Envy24
@subsection OSS Envy24
@cindex OSS Envy24
@cindex Envy24

La version commerciale d'OSS comportait une variante pour les cartes son 24 bit
96 kHz.  Cette variante avait besoin de modifications significatives dans la
manière d'utiliser les pilotes audio, d'où le besoin d'un nouveau pilote.

@c cincvdoc_node_number_30
@node Alsa
@subsection Alsa
@cindex Alsa

ALSA est le plus courant des pilotes audio utilisés sous GNU/Linux 2.6.  Il
sait maintenant gérer la plupart des cartes son.  Il profite des
fonctionnalités de faible latence de GNU/Linux 2.6 pour procurer de meilleures
performances que ce qui est obtenu avec OSS et GNU/Linux 2.4, mais les
performances sont sensiblement les mêmes que celles qu'OSS permettait d'avoir
avec la version 2.0.  Malheureusement ALSA est en perpétuelle évolution.  Un
programme qui fonctionne avec un jour, peut très bien ne plus fonctionner le
lendemain.  De nouvelles interfaces sont développées autour d'ALSA au même
rythme.  Nous prévoyons d'en ajouter la gestion à intervalle régulier, mais pas
chaque fois qu'il en sortira un nouveau.@*
ALSA n'est maintenant plus portable entre i386 et x86_64.  Si un binaire i386
tente une lecture du son avec un noyau x86_64, il va se planter.  Dans ce cas,
utilisez OSS@.

@c cincvdoc_node_number_31
@node Esound
@subsection Esound
@cindex Esound

ESOUND est un serveur de son qui s'appuie sur OSS@.  Il a été écrit pour un
gestionnaire de fenêtres appelé Enlightenment.  Il gère un nombre limité de
bits et possède une latence élevée par rapport aux pilotes plus modernes, mais
il permet de multiplexer des sources audio multiples.  On ne sait pas s'il
fonctionne toujours.

@c cincvdoc_node_number_32
@node Raw 1394
@subsection Raw 1394
@cindex Raw 1394

C'était la première interface entre les logiciels GNU/Linux et les caméscopes
firewire.  C'est la méthode la moins fiable pour reproduire l'audio vers un
caméscope et elle consiste en une bibliothèque reposant sur des commandes du
noyau.

@c cincvdoc_node_number_33
@node DV 1394
@subsection DV 1394
@cindex DV 1394

Deuxième réécriture de la gestion des caméscopes DV sous GNU/Linux.  C'est la
méthode la plus fiable de reproduire l'audio vers un caméscope et elle consiste
en des commandes directes du noyau.

@c cincvdoc_node_number_34
@node IEC 61883
@subsection IEC 61883
@cindex IEC 61883

Troisième réécriture de la gestion DV pour GNU/Linux.  C'est une bibliothèque
résidant au-dessus de RAW 1394 qui est lui même au-dessus des commandes du
noyau.  Elle est moins fiable que DV 1394 mais plus fiable que RAW 1394.  La
prochaine réécriture devrait résoudre cela.  Consultez
@uref{http://www.linux1394.org} pour plus d'information sur les derniers
pilotes.

@c cincvdoc_node_number_35
@node Pilotes vidéo
@section Pilotes vidéo
@cindex Pilotes vidéo

Les pilotes vidéo sont utilisés pour la visualisation dans le compositeur et la
visionneuse

@menu
* Attributs communs aux pilotes vidéo:: Paramètres qui ne sont pas restreints à un seul pilote.
* X11::
* X11-XV::
* X11-OpenGL::
* Buz::
* Lecture vidéo raw 1394::
* Lecture vidéo DV 1394::
* Lecture vidéo IEC 61883::
@end menu

@c cincvdoc_node_number_36
@node Attributs communs aux pilotes vidéo
@subsection Attributs communs aux pilotes vidéo
@cindex Attributs communs aux pilotes vidéo

@itemize @bullet
@item @b{Affichage}@*
@cindex Affihages à deux moniteurs
L'interface est conçue pour les systèmes à deux moniteurs.  Selon la valeur de
ce paramètre, la fenêtre de composition apparaîtra sur un moniteur différent du
reste des autres fenêtres.

@item @b{Chemin vers le périphérique}@*
C'est habituellement un fichier du répertoire @file{/dev/} qui contrôle le
périphérique.

@item @b{Permuter les champs}@*
Rendre pairs les champs impairs et impairs les champs pairs lors de leur envoi
vers le périphérique.  Sur un moniteur NTSC ou 1080i les champs doivent être
permutés pour éviter les sautillements lors des déplacements.

@item @b{Canal de sortie}@*
Vous pouvez avoir besoin d'un connecteur spécifique pour envoyer de la vidéo
vers des périphériques ayant plusieurs sorties.

@item @b{Port}@*
La norme IEEE1394 indique quelque chose appelé le @b{port}.  C'est probablement
le numéro de la carte firewire du système à utiliser.

@item @b{Canal}@*
La norme IEEE1394 précise quelque chose appelé @b{channel}.  Pour les
caméscopes DV, il s'agit toujours de @b{63}.
@end itemize

@c cincvdoc_node_number_37
@node X11
@subsection X11
@cindex X11

Ce fut la première méthode pour afficher de la vidéo sur les systèmes UNIX.  Le
triplet RVB de chaque pixel est simplement envoyé directement vers la fenêtre.
C'est la méthode de lecture la plus lente.  Elle est encore utilisée comme
méthode de repli lorsque le matériel de gestion graphique ne permet pas de
gérer de très grandes images.

@c cincvdoc_node_number_38
@node X11-XV
@subsection X11-XV
@cindex X11-XV

Ce fut une amélioration de X11 en 1999.  Elle convertit le signal YUV en RVB au
niveau matériel avec mise à l'échelle.  C'est la méthode conseillée pour la
lecture vidéo mais elle ne peut pas gérer de très grandes images.  La taille
maximale des vidéo avec XV est habituellement de 1920x1080.

@c cincvdoc_node_number_39
@node X11-OpenGL
@subsection X11-OpenGL
@cindex X11-OpenGL
@cindex OpenGL

Le méthode la plus puissante pour reproduire la vidéo est OpenGL@.  Avec ce
pilote, la plupart des effets effectués par le matériel.  OpenGL permet des
dimensions de vidéo jusqu'à la taille maximale des textures, qui est
généralement plus grande que ce que permet XV, en fonction du pilote graphique
utilisé.  Pour l'activer, vous devrez utiliser un binaire compilé avec la
gestion d'OpenGL@.  L'option de la commande @command{configure} pour activer
OpenGL est @option{--enable-opengl}.  Il vous faudra une carte graphique qui
gère OpenGL 2.0.  Les cartes récentes de Nvidia devraient fonctionner.  Il vous
faudra aussi utiliser un pilote vidéo gérant OpenGL 2.0, tel que le pilote
binaire de Nvidia.  Pour savoir si votre pilote vidéo gère OpenGL 2.0, utilisez
la commande @w{suivante :} @command{glxinfo | grep "OpenGL version"}

@itemize @bullet
@item Pilote vidéo gérant le rendu matériel OpenGL @w{2.0 :}@*
@command{OpenGL version string: 2.0.2 NVIDIA 87.74}
@item Pilote vidéo ne gérant pas le rendu matériel OpenGL @w{2.0 :}@*
@command{OpenGL version string: @b{1.4} (2.0.2 NVIDIA 87.74)}
@end itemize

OpenGL repose sur des PBuffers et des shaders afin d'effectuer le rendu vidéo.
Le pilote graphique doit pouvoir gérer OpenGL 2.0 et Cinelerra doit avoir été
explicitement compilé avec la gestion OpenGL 2.0.  Ceci demande à ce qu'il soit
compilé sur un système avec les en-têtes OpenGL 2.  Les PBuffers sont connus
pour être incohérents.  Si la carte graphique ne possède pas assez de mémoire
ni les bons visuels, les PBuffers ne fonctionneront pas.  Si OpenGL ne
fonctionne pas, essayez de vous déplacer de quelques images ou de redémarrer
Cinelerra.

@b{Limitations :}
@itemize @bullet
@item OpenGL n'affecte pas le rendu.  Il permet juste d'accélérer la
visualisation.
@item X11-OpenGL traite tout dans un modèle colorimétrique de 8 bit, cependant
la différence entre YUV et RVB est conservée.
@item OpenGL ne fonctionne pas avec les images dont la taille est supérieure à
4096x4096.@*
Voici ce qui est affiché à l'écran de la console lorsque vous travaillez avec
de grandes @w{images :}@*
@code{BC_Texture::create_texture frame size <frame_width>x<frame_height> bigger
than maximum texture 4096x4096.}
@item L'équation de mise à l'échelle définie dans la fenêtre des préférences
est ignorée par OpenGL@.
OpenGL utilise toujours une mise à l'échelle linéaire.
@item La taille du projet et des pistes doit être un multiple de quatre pour
qu'OpenGL puisse fonctionner.
@item Afin d'obtenir le maximum d'accélération, les effets utilisant OpenGL
doivent être placés après les effets purement logiciels.  Tout le rendu placé
avant le dernier effet purement logiciel sera effectué par logiciel.  Le coeur
des opérations de Cinelerra comme la caméra et le projecteur sont sous OpenGL@.
@item Les effets ne gèrent pas tous l'accélération OpenGL@.  Les effets suivants
supportent @w{OpenGL :} Luminosité, clé chromatique, clé chromatique hsv, équilibre
des couleurs, Déentrelacement, Clé différence, Fondu enchaîné, Images vers
Champs, Figer l'image, Gamma, Dégradé, Histogramme, Teinte/Saturation,
Interpoler les Pixels,  Vidéo inverdée, Flou linéaire, Overlay, Perspective,
Flou Radial, RVB601, Rotation, Redimensionner, Seuil, Flou de zoom.
@end itemize

@c cincvdoc_node_number_40
@node Buz
@subsection Buz
@cindex Buz
@cindex Video4Linux

C'est une méthode pour reproduire directement les fichiers animés de type
JPEG-A sous la forme d'un signal analogique composite.  Il utilise une astuce
populaire du pilote Video4Linux 1 depuis 2000 pour décompresser le JPEG au
niveau matériel.  Bien que la vidéo analogique soit largement obsolète, des
pilotes plus récents ont remplacé BUZ@.

@c cincvdoc_node_number_41
@node Lecture vidéo raw 1394
@subsection Lecture vidéo raw 1394
@cindex Raw 1394

Première interface entre le logiciel GNU/Linux et les caméscopes firewire.
C'est la méthode la moins fiable de transmettre de la vidéo vers un caméscope
et elle consiste en une bibliothèque reposant sur des commandes du noyau.

@c cincvdoc_node_number_42
@node Lecture vidéo DV 1394
@subsection Lecture vidéo DV 1394
@cindex DV 1394

Deuxième réécriture de la gestion des caméscopes DV sous GNU/Linux.  C'est la
méthode la plus fiable pour transmettre de la vidéo vers un caméscope et elle
consiste en des commandes directes du noyau.

@c cincvdoc_node_number_43
@node Lecture vidéo IEC 61883
@subsection Lecture vidéo IEC 61883
@cindex IEC 61883

Troisième réécriture de la gestion DV pour GNU/Linux.  C'est une bibliothèque
au-dessus de RAW 1394 et qui est moins fiable que DV 1394 mais plus fiable que
RAW 1394.  La prochaine réécriture devrait résoudre cela.  Consultez
@uref{http://www.linux1394.org} pour plus d'information et les derniers
pilotes.

@c cincvdoc_node_number_44
@node Lecture
@section Lecture
@cindex Lecture

@menu
* Sortie audio::
* Sortie vidéo::
@end menu

@c cincvdoc_node_number_45
@node Sortie audio
@subsection Sortie audio
@cindex Sortie audio
@cindex Echantillons audio

Ceci détermine ce qui se passe lorsque vous jouez un son depuis la timeline.

@cindex Echantillons à envoyer à la console
@itemize @bullet
@item @b{Echantillons à envoyer à la console}@*
Pour reproduire l'audio, de petits segments sonores sont lus depuis le disque
et traités séquentiellement dans une console virtuelle.  Une plus grande valeur
engendre davantage de latence lorsque vous modifierez les paramètres de mixage
mais permettra une lecture plus fiable.@*
Certains pilotes audio ne permettent pas de changer la fragmentation de la
console, la latence demeure donc inchangée quelque soit la valeur.@*
Précédemment, une bonne manière de s'assurer de la bonne qualité de la lecture
était de lire de plus gros fragments depuis le disque et de les découper en
plus petits fragments pour la carte son.  Ceci a changé lorsque la console
virtuelle est passée d'un modèle "push" à un modèle "pull".  Comme différentes
étapes du pipeline de rendu peuvent modifier le taux des données entrantes, il
serait difficile de différencier la taille des fragments de la console de la
taille de ceux lus sur le disque.

@cindex Décalage audio
@item @b{Décalage audio}@*
La possibilité d'indiquer la position de lecture exacte avec les pilotes de
GNU/Linux est mauvaise.  Comme cette information est nécessaire pour une
synchronisation correcte de la vidéo, elle doit être précise.  Le @b{décalage
audio} permet à l'utilisateur d'ajuster la position retournée par le pilote
audio afin de rendre compte de la réalité.  Le décalage audio ne modifie en
rien la lecture audio ni le rendu.  Il modifie simplement la synchronisation de
la lecture vidéo.@*
La manière la plus simple de définir le décalage audio est de créer une
timeline avec une piste vidéo et une piste audio.  D'étendre la piste audio et
de centrer sa commande de panoramique (stéréo).  Le débit des images doit être
supérieur à 24 i/s et le taux d'échantillonnage doit être supérieur à 32000.
Les images doivent être de petite taille pour que votre ordinateur puisse en
effectuer le rendu en temps réel.  Mettez en surbrillance la région de la
timeline commençant à 10 secondes et se terminant à 20 secondes.  Déposez un
effet @b{Dégradé} sur la piste vidéo et configurez-le de façon à ce qu'il soit
clairement visible.  Déposez une effet @b{Synthétiseur} sur l'audio et
configurez-le de façon à ce qu'il soit clairement audible.@*
Lisez la timeline à partir de 0 et regardez si l'effet de dégradé et le son
commencent en même temps.  Si ce n'est pas le cas, étendez la piste audio et
ajustez le décalage.  Si le son commence avant la vidéo, diminuez la valeur de
décalage.  Si le son commence après la vidéo, augmentez la valeur de décalage.
Une fois la lecture des pistes synchronisée, copiez la valeur du décalage dans
la valeur du @b{décalage audio} des préférences.@*
@b{Note :} si vous changez de pilotes audio ou si vous modifiez la valeur de
@b{Utiliser le logiciel pour les informations de positionnement}, vous devrez
modifier le décalage audio parce que les différents pilotes audio présentent
des imprécisions différentes.

@cindex L'affichage suit la lecture
@item @b{L'affichage suit la lecture}@*
Ceci fait défiler la fenêtre de la timeline lorsque le curseur de visualisation
se déplace.  Ceci peut bloquer le serveur X ou figer la fenêtre de la timeline
durant de longues périodes lors du dessin des objets graphiques.

@cindex Utiliser le logiciel pour les informations de positionnement
@item @b{Utiliser le logiciel pour les informations de positionnement}@*
La plupart des cartes son et des pilotes audio ne donnent pas une information
fiable concernant le nombre d'échantillons que la carte a joué.  Vous avez
besoin de cette information pour la synchronisation lorsque vous visualisez de
la vidéo.  Grâce à cette option le pilote audio est ignoré et un temporisateur
logiciel est utilisé pour la synchronisation.

@cindex Lecture audio en temps réel
@item @b{Lecture audio en temps réel}@*
Lorsque 150 MHz était la vitesse maximum d'un ordinateur personnel, ce
paramètre permettait d'avoir une lecture non saccadée lorsque la charge de la
machine était élevée.  Cette option force la plus haute priorité dans le noyau
pour la lecture sonore.  Aujourd'hui, ceci a plutôt son utilité pour obtenir
une très faible latence entre les réglages de la console et la sortie de la
carte son.  Vous devez être administrateur (root) pour pouvoir obtenir la
priorité temps réel.

@cindex Pilote audio
@item @b{Pilote audio}@*
Il y a de nombreux pilotes audio pour GNU/Linux.  Cette option permet de
choisir un pilote et ses paramètres spécifiques.  Les pilotes audio et leurs
paramètres sont décrits dans la section des pilotes audio.  @xref{Pilotes
audio}.
@end itemize

@c cincvdoc_node_number_46
@node Sortie vidéo
@subsection Sortie vidéo
@cindex Sortie vidéo

Ceci détermine comment la vidéo est affichée depuis la timeline.

@cindex Reproduire toutes les images
@cindex Images, reproduire toutes
@itemize @bullet
@item @b{Reproduire toutes les images}@*
Ceci forcera l'affichage de toutes les images de la vidéo, même si cela lui
fait prendre du retard par rapport à l'audio.  Cette option devrait toujours
être activée à moins que vous n'utilisiez principalement des codecs non
compressés.  La plupart des codecs compressés n'autorisent plus de sauter des
d'images.  Au 1/2007, la plupart des codecs compressés ne supportent plus le
saut d'images.

@cindex Fréquence des images obtenues
@item @b{Fréquence des images obtenues}@*
Nombre d'images par seconde affichées lors d'une lecture.  Ce n'est mis à jour
que lors de la lecture uniquement.

@cindex Décoder les images de manière asynchrone
@item @b{Décoder les images de manière asynchrone}@*
Si vous avez beaucoup de mémoire et plus d'un processeur, cette option peut
améliorer les performances en lecture en décodant la vidéo aussi rapidement que
possible sur l'un des processeurs tout en dédiant l'autre processeur à
l'affichage vidéo.  Ceci suppose que toutes les opérations de lecture se font
dans le sens normal et qu'on ne saute aucune image.  Les opérations demandant
une lecture en sens inverse ou sautant des images seront impactées de manière
négative.@*
Comme cette option demande énormément de mémoire, Cinelerra peut planter si les
images en entrée sont très grandes.

@cindex Equation de mise à l'échelle
@item @b{Equation de mise à l'échelle}@*
Cet algorithme est utilisé lorsque la lecture de la vidéo nécessite une mise à
l'échelle ou une translation dans la console virtuelle.  La lecture à l'échelle 1:1 n'est pas affectée
par cet algorithme.
@itemize @bullet
@item @b{Plus proche voisin utilisé pour la réduction et l'agrandissement}@*
Qualité d'affichage relativement médiocre, mais lecture rapide.  Produit des
bordures irrégulières et des déplacements saccadés.
@item @b{Agrandissement bicubique et réduction bilinéaire}@*
Haute qualité d'affichage, accompagnée d'une lecture plus lente.  Une
interpolation bicubique est utilisée pour l'agrandissement ce qui ajoute un peu
de flou mais ne crée pas d'effet d'escalier sur l'image.  Une interpolation
bilinéaire et utilisée pour la réduction, ce qui donne des images très piquées
et réduit le bruit.  Les images réduites avec une interpolation bilinéaire
peuvent être accentuées à l'aide d'un effet de netteté avec moins de bruit que
des images normalement redimensionnées.
@item @b{Agrandissement bilinéaire et réduction bilinéaire}@*
Lorsque de faibles agrandissements sont nécessaires, un agrandissement
bilinéaire donne de meilleurs résultats qu'un agrandissement bicubique.
@end itemize

@cindex Tampon pour Quicktime
@cindex Quicktime, tampon pour
@item @b{Tampon pour Quicktime}@*
Le décodeur Quicktime/AVI peut mieux gérer des sources DVD si cette valeur est
fixée aux alentours de 10000000.  Ceci diminue le nombre de déplacements
nécessaires.  Malheureusement, lors de la lecture depuis le disque dur de
sources ayant un débit binaire élevé, ceci tend à impacter négativement les
performances en ralentissant le décodage de l'image.  Dans le cadre d'une
utilisation normale, la valeur devrait être de 0.

@cindex DVD, sous-titres
@item @b{Sous-titres du DVD à afficher}@*
Les fichiers IFO DVD contiennent généralement des pistes de sous-titres.  Elles
doivent être décodées par le décodeur MPEG@.  Sélectionnez @b{Activer les
sous-titres} afin d'activer le décodage des sous-titres.  Il y a habituellement
plusieurs pistes de sous-titres, indexées par un chiffre commencent à 0.
Entrez le numéro de l'index de la piste de sous-titres à décoder dans la case
"Sous-titre à afficher" ou utilisez le curseur pour augmenter sa valeur.  Allez
à l'objet correspondant au fichier MPEG dans la fenêtre des ressources et
faites un clic droit.  Cliquez sur Info.  Le numéro de la piste de sous-titres
est indiqué en bas.

@cindex Images CR2
@item @b{Interpoler les images CR2}@*
Activer l'interpolation des images CR2.  Une interpolation est nécessaire car
les images brutes dans un fichier CR2 se présentent sous forme d'une matrice de
Bayer.  L'interpolation utilise l'algorithme d'interpolation de dcraw qui est
très lente.  Cette opération peut être désactivée et l'effet @b{Interpoler les
Pixels} utilisé en remplacement afin d'obtenir un aperçu plus rapide.

@cindex Balance des blancs des images CR2
@item @b{Balance des blancs des images CR2}@*
Ceci active la balance des blancs des images CR2 si l'interpolation est aussi
activée.  En effet une bonne balance des blancs nécessite un mélange de
l'ensemble des 3 couleurs primaires.  La balance des blancs utilise la matrice
de l'appareil photo qui est contenue dans le fichier CR2.@*
Désactiver la balance des blancs est utile pour des opérations qui mettent en
oeuvre la soustraction d'images d'obscurité.  L'image d'obscurité et
l'exposition longue doivent avoir la même matrice de couleurs.@*
Si vous désactivez @b{Interpoler les images CR2} et utilisez l'effet
@b{Interpoler les Pixels}, soyez conscient que l'effet @b{Interpoler les
Pixels} effectue à la fois l'interpolation et la balance des blancs en
utilisant la matrice de l'appareil photo, indépendamment des paramètres définis
dans les préférences.  La soustraction d'une image d'obscurité doit être
effectuée avant @b{Interpoler les pixels}.

@cindex Pilote vidéo
@item @b{Pilote vidéo}@*
Normalement, la vidéo sur la timeline est dirigée vers la fenêtre de
composition à la fois lors de lecture en continu et lorsque le point
d'insertion est repositionné.  Plutôt que d'envoyer la vidéo vers la fenêtre du
Compositeur, le pilote vidéo peut être configuré pour l'envoyer vers un autre
périphérique de sortie lors de la lecture en continu.  Cependant, ceci
n'affecte pas la destination de la vidéo lorsque le point d'insertion est
repositionné.@*
Les pilotes vidéo et leurs paramètres sont décrits dans la section des pilotes
vidéo.  @xref{Pilotes vidéo}.
@end itemize

@c cincvdoc_node_number_47
@node Acquisition
@section Acquisition
@cindex Acquisition

Ces paramètres permettent de rendre la fonction @b{Fichier->Enregistrer...}
aussi rapide que possible en permettant à l'utilisateur de pré-configurer le
format de fichier à enregistrer.  Le format de fichier est appliqué à tous les
enregistrements.  Le matériel utilisé pour l'enregistrement est aussi défini
ici, puisque le matériel détermine le format du fichier dans la plupart des
cas.

@menu
* Format de fichier::
* Entrée audio::
* Entrée vidéo::
@end menu

@c cincvdoc_node_number_48
@node Format de fichier
@subsection Format de fichier
@cindex Format de fichier

Ceci détermine le format des fichiers utilisé lors de l'acquisition.  Il dépend
largement du type de pilote utilisé.  Les menus sont les mêmes que ceux de
l'interface de rendu.  @xref{Le rendu de fichiers}.  La case à cocher
@b{Enregistrer les pistes audio} doit être validée pour enregistrer l'audio.
La case à cocher @b{Enregistrer les pistes vidéo} doit être validée pour
enregistrer la vidéo.  Le bouton "clé anglaise" situé à gauche de chacune des
cases ouvre une boîte de dialogue de configuration permettant de définir la
méthode de compression (codec) à utiliser pour chaque flux audio et vidéo en
sortie.  L'audio et la vidéo sont encapsulées dans in conteneur défini par le
menu @b{Format de fichier}.  Certains conteneurs ne permettent d'enregistrer
que de l'audio, d'autres que de la vidéo, ou bien des deux.

Certains pilotes vidéo ne peuvent enregistrer que vers un certain conteneur.
DV, par exemple ne peut enregistrer que vers Quicktime avec une compression
vidéo de type DV@.  Si le pilote vidéo est changé, le format de fichier peut
devoir être modifié afin d'obtenir une sortie gérée.  Si vous changez le format
du fichier pour un format non géré, il peut ne pas fonctionner avec le pilote
vidéo.

@c cincvdoc_node_number_49
@node Entrée audio
@subsection Entrée audio
@cindex Entrée audio

Ceci détermine ce qui se passe lorsque vous enregistrez de l'audio.

@cindex Pilote d'enregistrement
@cindex Chemin vers le périphérique
@cindex Bits
@itemize @bullet
@item @b{Pilote d'enregistrement}@*
Il est utilisé pour enregistrer de l'audio dans la fenêtre d'acquisition.  Il
peut être configuré de façon identique au pilote d'enregistrement pour la vidéo
si l'audio et la vidéo sont encapsulées dans le même flux.  Les paramètres
disponibles dépendent du pilote.  A noter que les pilotes sont les mêmes que
ceux qui sont disponibles dans Préférences->Lecture.
@itemize @bullet
@item @b{Chemin vers le périphérique}@*
C'est habituellement un fichier dans le répertoire @file{/dev/} qui contrôle le
périphérique.
@item @b{Bits}@*
Nombre de bits de précision avec lequel Cinelerra doit configurer le
périphérique.  La signification en est parfois figurée.  Certains pilotes audio
ont besoin d'être configurés avec 32 bits pour effectuer des enregistrements 24
bit et n'enregistreront rien lorsqu'ils seront configurés avec 24 bits.
Certains pilotes audio doivent être configurés avec 24 bits pour enregistrer en
24 bit.
@end itemize

@item @b{Canaux}@*
Nombre de canaux que Cinelerra doit configurer pour le périphérique.
Indépendamment du nombre de canaux du projet, ce nombre de canaux indique ceux
qui seront écrits vers le périphérique.  Lorsqu'il est configuré à 2 et que le
projet comporte 1 canal, vous entendrez le son dans le haut-parleur de gauche
et non centré comme on pourrait s'y attendre avec un projet monophonique.
Lorsqu'il est défini à 1 et que le projet possède deux canaux, vous pourrez
entendre le canal de gauche centré et non pas les deux canaux mélangés.

@cindex Echantillons à écrire en une fois
@item @b{Echantillons à écrire en une fois}@*
Tout d'abord, l'audio est lue sous forme de petits fragments depuis le
périphérique.  Ensuite, de nombreux petits fragments sont combinés en un gros
fragment avant d'être écrits sur le disque.  L'écriture sur disque est effectué
par un autre processus système ("thread").  La valeur indiquée ici détermine la
taille de la combinaison des fragments utilisée lors de chaque opération
d'écriture sur disque.

@cindex Taux d'échantillonage pour l'enregistrement
@item @b{Taux d'échantillonage pour l'enregistrement}@*
Indépendamment des paramètres du projet, la valeur définie ici est le taux
d'échantillonnage utilisé pour l'enregistrement.  Le taux d'échantillonnage
devrait être égal à la valeur la plus élevée que puisse gérer le périphérique
audio.
@end itemize

@c cincvdoc_node_number_50
@node Entrée vidéo
@subsection Entrée vidéo
@cindex Entrée vidéo

Ceci détermine ce qui se passe lorsque vous enregistrez de la vidéo.

@cindex Pilote d'enregistrement
@itemize @bullet
@item @b{Pilote d'enregistrement}@*
Il est utilisé pour enregistrer de la vidéo dans la fenêtre d'acquisition.  Il
peut être configuré à l'identique du pilote d'enregistrement de l'audio si
l'audio et la vidéo sont encapsulées dans le même flux.  Les paramètres
disponibles dépendent du pilote.  A noter que les pilotes disponibles sont les
mêmes que ceux disponibles dans Préférences->Lecture.

@cindex Images à enregistrer à la fois sur le disque
@item @b{Images à enregistrer à la fois sur le disque}@*
Les images sont enregistrées dans un pipeline.  Tout d'abord, les images sont
mises en tampon dans le périphérique.  Ensuite, elles sont lues dans un tampon
de taille plus importante afin d'être écrites sur le disque.  L'écriture sur
disque est effectuée par un processus système ("thread") différent de celui
effectuant la lecture depuis le périphérique.  Pour certains codecs, l'écriture
disque utilise plusieurs processeurs.  La valeur définie ici détermine combien
d'images sont écrites simultannément sur le disque.

@cindex Images à mettre en tampon dans le périphérique
@item @b{Images à mettre en tampon dans le périphérique}@*
Il s'agit du nombre d'images à enregistrer dans le périphérique avant d'en
effectuer la lecture, et cette valeur détermine le temps de latence qu'il peut
y avoir dans le système avant que des images ne soient sautées.

@cindex Utiliser le logiciel pour les informations de positionnement
@item @b{Utiliser le logiciel pour les informations de positionnement}@*
La vidéo utilise l'audio pour la synchronisation, mais la plupart des cartes
son ne donnent pas d'information de position suffisamment précise.
Sélectionner cette option fait que Cinelerra calcule une estimation de la
position de l'audio par le logiciel plutôt que d'utiliser le matériel pour la
synchronisation.

@cindex Synchroniser les disques automatiquement
@item @b{Synchroniser les disques automatiquement}@*
Pour les enregistrements à un débit binaire élevé, les disques durs que vous
utilisez peuvent être suffisamment rapides pour enregistrer les données, mais
le système d'exploitation peut attendre plusieurs minutes avant d'effectuer
l'opération d'écriture, il semble alors être figé alors qu'il est en train
d'écrire plusieurs minutes de données en une seule fois.  Cette option permet
de forcer le système d'exploitation à vider ses tampons chaque seconde plutôt
que toutes les quelques minutes afin d'avoir un comportement temps réel un peu
meilleur.

@cindex Taille de l'image capturée
@item @b{Taille de l'image capturée}@*
C'est la taille des images enregistrées, exprimée en pixels.  Ceci est
indépendant de la taille d'image du projet parce que la plupart des
périphériques vidéo ne permettent d'enregistrer qu'une taille fixe d'image.  Si
la taille d'image indiquée ici n'est pas gérée par le périphérique, Cinelerra
peut planter.

@cindex Fréquence des images en enregistrement
@item @b{Fréquence des images en enregistrement}@*
La fréquence des images enregistrées est différente de celle des paramètres du
projet.  Ceci définit le débit des images enregistrées.
@end itemize

@c cincvdoc_node_number_51
@node Performances
@section Performances
@cindex Performances

Vous allez passer la plupart de votre temps à configurer cette section.  Le but
principal de cette section est de configurer les paramètres qui ne sont pas
disponibles dans le dialogue de rendu.

@cindex Entités en cache
@itemize @bullet
@item @b{Entités en cache}@*
Pour accélérer le rendu, certains objets sont conservés ouverts simultanément.
Ceci détermine combien peuvent être conservés ouverts.  Une valeur trop grande
va très vite vous faire dépasser la capacité mémoire de votre machine et
provoquer un plantage.  Une valeur trop petite entraînera une visualisation
lente car les objets devront être réouverts plus fréquemment.

@cindex Durée d'anticipation de rendu
@item @b{Durée d'anticipation de rendu}@*
Certains effets ont besoin d'un certain temps pour être appliqués.  En
utilisant cette option, vous pouvez définir la durée de la vidéo, exprimée en
secondes, dont il faut effectuer le rendu sans écrire sur le disque avant que
le rendu de la région sélectionnée ne soit effectué.  Lors de l'utilisation
d'une grappe de rendu, vous devrez parfois utiliser l'anticipation de rendu
pour avoir des transitions sans heurt.  Chaque tâche d'une grappe de calcul est
anticipée de cette valeur.  Ceci n'affecte cependant pas le rendu en tâche de
fond.  Le rendu en tâche de fond utilise une valeur d'anticipation différente.

@cindex Forcer l'utilisation d'un seul processeur
@cindex SMP, forcer l'utilisation d'un seul processeur
@item @b{Forcer l'utilisation d'un seul processeur}@*
Par défaut Cinelerra essaie d'utiliser tous les processeurs du système, mais
vous voudrez peut-être parfois n'en utiliser qu'un seul, par exemple pour le
client d'une grappe de calcul.  Ceci force l'utilisation d'un seul processeur.
De plus, le système d'exploitation utilise quand même le second processeur pour
les accès disque.  Donc cette option est en fait un mode avec 1,25 processeurs.
La valeur de ce paramètre est utilisée par les clients de la grappe de calcul.
@end itemize

@menu
* Rendu en tâche de fond::
* La grappe de calcul::
@end menu

@c cincvdoc_node_number_52
@node Rendu en tâche de fond
@subsection Rendu en tâche de fond
@cindex Rendu en tâche de fond

Le rendu en tâche de fond a été conçu à l'origine pour permettre aux effets
HDTV (TV Haute Définition) de pouvoir être affichés en temps réel.  Le rendu en
tâche de fond effectue en permanence le rendu lorsque la timeline est modifiée.
La sortie temporaire est affichée lors de la visualisation lorsque cela est
possible.  Ceci est utile pour les transitions et pour prévisualiser les effets
qui seraient trop lents à afficher en temps réel.  Si une grappe de calcul est
activée, elle est utilisée pour le rendu en tâche de fond.  Ceci vous offre
tout le potentiel des effets en temps réel si la bande passante du réseau et le
nombre de noeuds de calcul sont suffisants.

Le rendu en tâche de fond est activé depuis l'onglet @b{Performances} de la
fenêtre des @b{Préférences}.  Il possède une fonction interactive
@b{Configuration -> Point de départ du rendu en tâche de fond}.  Ceci définit
comme l'endroit où le rendu en tâche de fond commence, jusqu'au point
d'insertion.  S'il y a de la vidéo, une barre rouge apparaît dans la barre
temporelle indiquant qu'un rendu en tâche de fond est en cours.

Il est souvent utile d'insérer un effet ou une transition et de sélectionner
ensuite @b{Configuration -> Point de départ du rendu en tâche de fond} juste
avant l'effet dont on veut l'aperçu en temps réel et à la fréquence d'images
normale.

@cindex Nombre d'images par processus de rendu en tâche de fond
@itemize @bullet
@item @b{Nombre d'images par processus de rendu en tâche de fond}@*
Ceci ne fonctionne que si une grappe de calcul est utilisée, sinon, le rendu en
tâche de fond ne crée qu'une seule tâche pour toute la timeline.  Le nombre
d'images indiqué ici est rendu proportionnel à la vitesse des processeurs des
noeuds de calcul et utilisé pour chacune des tâches de la grappe de calcul.  Le
nombre optimum est compris entre 10 et 30 car la bande passante du réseau est
utilisée pour initialiser chaque tâche.

@cindex Nombre d'images d'anticipation en tâche de fond
@item @b{Nombre d'images d'anticipation en tâche de fond}@*
C'est le nombre d'images à rendre au début de chacune des tâches de rendu en
tâche de fond.  Le rendu en tâche de fond est dégradé lorsque l'anticipation
est utilisée en raison de la petite taille des tâches.  Lorsque le rendu en
tâche de fond est utilisé, ce nombre est idéalement de 0.  Certains effets ont
besoin de 3 images d'anticipation.

@cindex Sortie pour le rendu en tâche de fond
@item @b{Sortie pour le rendu en tâche de fond}@*
Le rendu en tâche de fond crée une séquence de fichiers images dans un
répertoire donné.  Ce paramètre détermine le préfixe du nom des fichiers
d'images.  Le répertoire doit se trouver sur un disque rapide, accessible par
le même chemin depuis n'importe quel noeud de la grappe de calcul.  Comme des
centaines de milliers de fichiers images sont habituellement créés, la commande
@command{ls} ne fonctionne pas dans le répertoire de rendu.  Le bouton de
recherche de fichiers @image{manual_images_intl/magnify,7mm} ne fonctionne
habituellement pas non plus, mais le bouton de configuration
@image{manual_images_intl/wrench,4.33mm} fonctionne avec cette option.

@cindex Format de fichier
@item @b{Format de fichier}@*
Le format de fichier pour le rendu en tâche de fond doit être une séquence
d'images.  Le format de la séquence d'images détermine la qualité et la vitesse
de la lecture.  La plupart du temps, le format JPEG est un bon choix.
@end itemize

@c cincvdoc_node_number_53
@node La grappe de calcul
@subsection La grappe de calcul
@cindex Grappe de calcul

Définissez ces options si vous utilisez une grappe de calcul.  Ignorez-les sur
un système isolé.

@cindex Utiliser la grappe de calcul pour le rendu
@itemize @bullet
@item @b{Utiliser la grappe de calcul pour le rendu}@*
Lorsque cette option est choisie, toutes les opérations de @b{Fichier->Rendu}
utiliseront la grappe de calcul.

@cindex Noeuds
@item @b{Noeuds}@*
Affiche tous les noeuds de la grappe de calcul et indique ceux qui sont sont
actifs.  Des noeuds sont ajoutés en entrant le nom d'hôte du noeud, en
vérifiant le numéro du @b{port} et en cliquant sur @b{Ajouter le noeud}.  Si
vous avez à disposition des centaines de noeufs, les utilisateurs expérimentés
préféreront éditer le fichier @file{~/.bcast/.Cinelerra_rc} plutôt que
d'utiliser cette méthode s'ils ont des centaines de noeuds à configurer.
Souvenez-vous que @file{.Cinelerra_rc} est écrasé chaque fois qu'une instance
de Cinelerra se termine.@*
Une fois que les noeuds sont créés, sélectionner la colonne @b{Actif} pour
activer ou désactiver des noeuds.  Les noeuds peuvent être modifiés en mettant
leur ligne en surbrillance et en cliquant sur @b{Appliquer les modifications}.

@cindex Nom d'hôte, grappe de rendu
@item @b{Nom d'hôte}@*
Editer le nom d'hôte d'un noeud existant ou entrer ici le nom d'un nouveau
noeud.

@cindex Port, grappe de rendu
@item @b{Port}@*
Editer le numéro de port d'un noeud existant ou entrer ici le port d'un nouveau
noeud.

@cindex Noeud, remplacer
@item @b{Remplacer le noeud}@*
Lors de l'édition d'un noeud existant, cliquez ici pour appliquer les
modifications de @b{nom d'hôte} et de @b{port}.  Les modifications ne seront
pas appliquées si vous ne cliquez pas sur ce bouton.

@cindex Noeud, ajouter un
@item @b{Ajouter un noeud}@*
Créer un nouveau noeud avec les paramètres de @b{nom d'hôte} et de @b{port}.

@cindex Noud, supprimer un
@item @b{Supprimer le noeud}@*
Supprime le noeud qui se trouve en surbrillance dans la liste des @b{noeuds}.

@cindex Trier les noeuds
@cindex Noeud, trier
@item @b{Trier les noeuds}@*
Trier les @b{noeuds} en fonction de leur nom d'hôte.

@cindex Fréquences, réinitialiser
@item @b{Réinitialiser les fréquences}@*
Ceci réinitialise la fréquence des images de tous les noeuds à 0.  Les
fréquences des images sont utilisées pour calibrer la taille des tâches en
fonction de la vitesse CPU@.  Les fréquences des images ne sont calculées que
lorsque la grappe de calcul est en service.

@cindex Nombre total de travaux à créer
@cindex Travaux, nombre total à créer
@item @b{Nombre total de travaux à créer}@*
Détermine le nombre total de travaux à répartir sur la grappe de calcul.  Plus
vous créez de travaux, plus la grappe de calcul sera finement équilibrée.@*
Déterminez le nombre total de travaux à créer en multipliant le nombre de
noeuds, y-compris le noeud principal par un certain nombre.  En les multipliant
par 1 vous obtenez un seul travail affecté à chaque noeud.  Multipliez-le par 3
pour avoir 3 travaux affectés à chacun des noeuds.  Si vous avez 10 noeuds
secondaires et un noeud principal, indiquez 33 pour avoir une grappe de calcul
bien équilibrée.
@end itemize

@c cincvdoc_node_number_54
@node Interface
@section Interface
@cindex Interface

Ces paramètres permettent simplement de modifier le comportement de l'interface
utilisateur.

@cindex Fichiers d'index, emplacement
@cindex Fichiers d'index
@itemize @bullet
@item @b{Emplacement des fichiers d'index}@*
Au temps où 4 Mo/s était un débit très élevé pour un disque dur, les fichiers
d'index ont été introduits pour accélérer le dessin des pistes audio.  Cette
option détermine où sont placés les fichiers d'index sur le disque dur.

@cindex Fichiers d'index, taille des
@item @b{Taille des fichiers d'index}@*
Ceci détermine la taille d'un fichier d'index.  Des tailles d'index plus
grandes permettent de dessiner plus rapidement les petits fichiers, tout en
ralentissant le dessin des fichiers les plus gros.  De plus petites tailles
d'index permettent aux gros fichiers d'être représentés rapidement en
ralentissant le dessin des petits fichiers.

@cindex Fichiers d'index, nombre à conserver
@item @b{Nombre de fichiers d'index à conserver}@*
Pour que le répertoire d'index ne se surcharge pas, les anciens fichiers
d'index sont effacés.  Ce paramètre détermine le nombre maximum de fichiers
d'index à conserver dans le répertoire en question.

@cindex Index, effacer tous
@item @b{Effacer tous les index}@*
Lorsque vous modifiez la taille de l'index ou lorsque vous désirez nettoyer un
nombre excessif de fichiers d'index, ceci vous permet de supprimer tous les
fichiers d'index.

@cindex Représentation du temps
@item @b{Utiliser heures:minutes:secondes.xxx}@*
Des représentations variées du temps sont proposées.  Choisissez celle qui vous
convient le mieux.  La représentation du temps peut aussi être modifiée par un
@key{Ctrl} + clic sur la barre temporelle.

@cindex Vignettes
@item @b{Utiliser les vignettes}@*
La fenêtre des ressources affiche par défaut des vignettes des objets.  Cet
affichage peut être assez long.  Cette option désactive l'affichage des
vignettes.

@cindex Points d'entrée/sortie, action d'un clic
@item @b{Action d'un clic sur les points d'entrée/sortie}@*
Cinelerra ne vous permet pas seulement de réaliser le montage en glissant les
points d'entrée et de sortie, mais aussi de définir trois opérations séparées
qui se produiront lorsque vous glisserez un point d'entrée ou de sortie.  Vous
pouvez pouvez définir ici le comportement de chacun des boutons de la souris.
L'utilisation de chacun des modes de montage est décrite dans la section
montage.

@cindex Vu-mètres, valeur min
@item @b{Valeur minimum pour les vu-mètres}@*
Certaines sources audio ont un seuil de bruit moins élevé que d'autres.  Tout
ce qui se trouve en-dessous du seuil de bruit est non significatif.  Cette
option règle les vu-mètres pour couper en-dessous d'un certain niveau.  Les
cartes son grand public ont en général un niveau minimum de -65 dB@.  Les cartes
son professionnelles descendent à -90 dB@.  @xref{La fenêtre des vu-mètres}.

@cindex Vu-mètres, valeur max
@item @b{Valeur maximum pour les vu-mètres}@*
Ceci permet de définir le niveau sonore maximum représenté par les vu-mètres.
Indépendemment de cette valeur, il n'y a aucune carte son capable de délivrer
des niveaux supérieurs à 0 dB@.  Cette valeur n'est indiquée que pour monter à
quelle distance de cette valeur se trouve le niveau de l'onde sonore.
@xref{La fenêtre des vu-mètres}.

@cindex Thème
@item @b{Thème}@*
Différents thèmes peuvent être utilisés avec Cinelerra.  Choisissez-en un ici
et redémarrez Cinelerra pour l'activer.
@end itemize

@c cincvdoc_node_number_55
@node A propos
@section A propos

Cette section vous donne des informations concernant le copyright, la date et
heure de compilation du binaire utilisé, l'absence de garantie et les versions
de certaines bibliothèques.  Assurez-vous d'être en accord avec les termes
d'absence de garantie.

@c cincvdoc_node_number_56
@node Attributs du projet
@chapter Attributs du projet
@cindex Attributs du projet

@menu
* Fenêtre de définition du format::
* Présélections::
* Attributs audio::
* Attributs vidéo::
@end menu

@c cincvdoc_node_number_57
@node Fenêtre de définition du format
@section Fenêtre de définition du format
@cindex Fenêtre de définition du format

Lorsque vous lisez des fichiers de média dans Cinelerra, ceux-ci comportent un
certain nombre de pistes, une certaine taille d'image, un certain taux
d'échantillonnage, et ainsi de suite.  Indépendamment des propriétés du fichier
de média, il est toujours joué en prenant en compte les attributs du projet.
Ainsi, si un fichier audio possède un taux d'échantillonnage différent que
celui des attributs du projet, il sera rééchantillonné.  De façon similaire, si
la taille de l'image d'un fichier vidéo est différente de celle des attributs
du projet, elle sera composée sur un fond noir, soit recadrée, soit entourée de
noir.

Les attributs du projet sont définis dans @b{Configuration->Format...} et, dans
une moindre mesure, dans @b{Fichier->Nouveau projet}.  Lorsque vous définissez
les attributs du projet dans @b{Fichier->Nouveau projet}, une nouvelle timeline
vide est créée.  Chaque timeline créée à partir de ce moment utilisera des
paramètres identiques.  Lorsque vous définissez les paramètres dans
@b{Configuration->Format...}, les médias sur la timeline sont inchangés.
Chaque timeline créée à partir de ce moment le sera en utilisant les mêmes
paramètres.

@center @image{manual_images_intl/format,70mm}
@center @b{Fenêtre de définition du format}

En plus des paramètres traditionnels tels que le taux d'échantillonnage, la
fréquence des images, la taille des images, Cinelerra utilise des paramètres
inhabituels tels que @b{position des canaux, modèle colorimétrique et rapport
d'aspect.}

@c cincvdoc_node_number_58
@node Présélections
@section Présélections
@cindex Présélections

Choisissez une option depuis ce menu pour que tous les paramètres du projet
soient positionnés selon l'une des normes connues.

@c cincvdoc_node_number_59
@node Attributs audio
@section Attributs audio
@cindex Attributs audio

@itemize @bullet
@item @b{Pistes}@*
Permet de définir le nombre de pistes audio que doit avoir le nouveau projet.
Des pistes peuvent être ajoutées ou supprimées par la suite, mais cette option
est présente ici par commodité.

@item @b{Canaux}@*
Définit le nombre de canaux que devra avoir le nouveau projet.  Le nombre de
canaux audio n'est pas forcément le même que le nombre de pistes.

@item @b{Taux d'échantillonnage}@*
Définit le taux d'échantillonnage de l'audio.  Le taux d'échantillonnage du
projet n'est pas forcément le même que celui du média que vous chargez.  Le
média est rééchantillonné afin que son taux d'échantillonnage corresponde à
celui du projet.

@item @b{Position des canaux}@*
Les canaux audio actuellement actifs et leurs positions dans les boîtes de
l'interface utilisateur son affichés à l'aide de l'élément graphique de
position.

@center @image{manual_images_intl/channelpositions,40mm}

Les canaux sont numérotés.  Lorsque le rendu est effectué, la sortie du canal 1
est rendue vers la première piste audio du fichier ou vers le premier canal de
la carte son.  Les canaux suivants sont rendus vers leurs pistes de sortie
numérotées consécutivement.

Les positions des canaux audio correspondent à l'emplacement où est situé
l'élément graphique de chaque sortie audio.  Plus la position de réglage est
proche de l'une des sorties audio, plus l'intensité sonore dans les
haut-parleurs est élevée.  Cliquez sur l'icône du haut-parleur et glissez-la
pour modifier l'emplacement du canal audio.

Les hauts-parleurs peuvent avoir une orientation quelconque.  Une disposition
différente des hauts-parleurs est enregistrée pour chaque nombre de canaux car
on n'utilise en général pas la même disposition des hauts-parleurs quelque soit
le nombre des canaux.

La position des canaux est le seul paramètre qui n'affecte pas nécessairement
la sortie.  Cliquez sur l'icône du haut-parleur et glissez-la afin de modifier
la position d'un des canaux.  C'est une simple commodité, afin que lorsque plus
de deux canaux sont utilisés, la commande de panoramique sur la timeline puisse
les distinguer l'un de l'autre.  Cela n'a rien à voir avec la disposition
réelle des canaux.

Différents canaux peuvent être disposés très proche l'un de l'autre de façon à
ce qu'ils aient la même sortie.
@end itemize

@c cincvdoc_node_number_60
@node Attributs vidéo
@section Attributs vidéo
@cindex Attributs vidéo

@itemize @bullet
@item @b{Pistes}@*
Définit le nombre de pistes vidéo que le nouveau projet se voit affecter.  Des
pistes peuvent être ajoutées ou supprimées par la suite, mais ces options sont
fournies ici par commodité.

@item @b{Fréquence des images}@*
Définit la fréquence des images de la vidéo.  La fréquence des images du projet
n'a pas besoin d'être identique à celle du média que vous chargez.  La
fréquence des images du média sera modifiée pour s'adapter à la fréquence des
images du projet.

@item @b{Taille de l'aire de travail}@*
Définit la taille de la sortie vidéo.  De plus, chaque piste a aussi sa propre
taille d'image.  Initialement, le dialogue @b{Nouveau projet} crée des pistes
vidéo dont les dimensions correspondent à celles de la sortie vidéo.  Les
dimensions des pistes vidéo pourront être modifiées ultérieurement sans
modifier la sortie vidéo.

@item @b{Rapport d'aspect}@*
Définit le rapport d'aspect.  Le rapport d'aspect est appliqué à la sortie
vidéo.  Le rapport d'aspect peut être différent du rapport résultat de la
formule @w{suivante :} h / v (nombre de pixels horizontaux divisé par le nombre de
pixels verticaux).  Si le rapport d'aspect diffère de la formule indiquée
ci-dessus, la sortie s'effectuera avec des pixels non carrés.

@item @b{Rapport d'aspect automatique}@*
Si cette case est cochée, le dialogue @b{Nouveau projet} recalculera toujours
le @b{Rapport d'aspect} en fonction de la taille de l'@b{aire de travail}.
Ceci permet de s'assurer que les pixels sont toujours carrés.

@item @b{Modèle colorimétrique}@*
Le projet sera enregistré dans le modèle colorimétrique intermédiaire choisi
parmi la liste déroulante.@*
Le modèle colorimétrique est très important pour la lecture vidéo car la vidéo
a le désavantage d'être très lente.  Bien que ce ne soit pas perceptible,
l'audio intermédiaire comporte beaucoup plus d'informations que l'audio sur le
disque et que l'audio lorsqu'elle est lue.  L'audio, parce qu'elle est rapide,
utilise toujours la bande passante intermédiaire la plus élevée.@*
La vidéo intermédiaire doit utiliser le moins de données possible pour la
qualité requise parce qu'elle est lente, mais la vidéo intermédiaire utilise
quand même un modèle colorimétrique de plus grande bande passante que la vidéo
enregistrée et que celle qui est reproduite.  Ceci permet d'effectuer davantage
de traitement avec moins de destruction des données d'origine.@*
La vidéo est enregistrée sur le disque dans un modèle colorimétrique,
généralement un dérivé de YUV@.  Lors de la lecutre , Cinelerra la décompresse
depuis son format de fichier directement dans le format du périphérique de
sortie.  Si des effets doivent être traités, Cinelerra décompresse d'abord la
vidéo dans un modèle colorimétrique intermédiaire puis converti ensuite le
résultat vers le format du périphérique de sortie.  Le choix du modèle
colorimétrique intermédiaire détermine la rapidité et la précision des effets.
@*
Les modèles colorimétriques de Cinelerra sont décrits en utilisant un certain
ordre d'encapsulage ("packing") des composantes et un certain nombre de
bits pour chacune des composantes.  L'ordre d'encapsulage est affiché à gauche
et le nombre de bits alloués est affiché à droite.
@cindex RVB-888
@itemize @bullet
@item @b{RVB-888}@*
Ce format alloue 8 bits pour le rouge, le vert et le bleu, sans canal alpha.
Il est normalement utilisé pour des médias non compressés et de faible plage
dynamique.
@cindex RVBA-8888
@item @b{RVBA-8888}@*
Ce format ajoute un canal alpha au modèle colorimétrique 8 bit RVB@.  Il est
utilisé pour superposer plusieurs pistes.
@cindex YUV-888
@item @b{YUV-888}@*
Ce format alloue 8 bits pour Y, U, et V@.  Il est utilisé pour les opérations à
faible dynamique dans lesquelles le média est compressé dans l'espace de
couleurs YUV@.  La plupart des médias compressés sont en YUV ce qui leur permet
d'être traité rapidement avec le moins de dégradation des couleurs possible.
@cindex YUVA-8888
@item @b{YUVA-8888}@*
Ce format ajoute au modèle colorimétrique 8 bit YUV un canal alpha pour la
transparence.
@cindex RGB-Flottant
@item @b{RVB-Flottant}@*
Ce format alloue 32 bits en virgule flottante pour les canaux R, V, et B, sans
canal alpha.  Il est utilisé pour des traitements avec une dynamique élevée
sans transparence.
@cindex RVBA-Flottant
@item @b{RGBA-Flottant}@*
Ce format ajoute un canal alpha sur 32 bits en virgule flottante au modèle
RVB-Flottant.  Il est utilisé pour du traitement avec une dynamique élevée et
de la transparence.
@end itemize
@b{De manière à utiliser des effets qui nécessitent un canal alpha, un modèle
colorimétrique avec canal alpha doit être sélectionné}.  Ce sont RVBA8888,
YUVA8888, et RVBA Flottant.  Les modèles colorimétriques à 4 canaux sont
plus lents que les modèles à 3 canaux, le plus lent étant RVBA
Flottant.  Certains effets tels que le fondu savent se passer d'un canal alpha
alors que d'autres comme la clé chromatique (chromakey), ont besoin d'un canal
alpha dans tous les cas.  C'est donc une bonne idée que d'essayer l'effet sans
canal alpha afin de voir s'il fonctionne avant de choisir un canal alpha et de
ralentir tout le processus.@*
Lors de l'utilisation de métrage compressé, les modèles YUV sont généralement
plus rapides que les modèles RVB.  Il détruisent moins de couleurs que les
modèles colorimétriques RVB@.  Si un métrage enregistré en JPEG ou MPEG est
traité de nombreuses fois en RVB, les couleurs vont se ternir alors que ce ne
sera pas les cas s'il est traité en YUV@.@*
Des années de travail avec du métrage en haute dynamique ont montrées que le
modèle RVB flottant était le meilleur format pour la dynamique élevée.  Les
formats entiers sur 16 bit étaient utilisés dans le passé et engendraient trop
de perte de qualité tout en étant trop lents au regard du niveau
d'amélioration.@*
Le RVB flottant ne détruit pas d'informations lorsqu'il est utilisé avec un
métrage source YUV et permet aussi une luminosité supérieure à 100%.  Soyez
conscient que certains effets, tels que l'histogramme, tronquent encore les
valeurs supérieures à 100% en virgule flottante.
@end itemize

@c cincvdoc_node_number_61
@node Charger et enregistrer des fichiers
@chapter Charger et enregistrer des fichiers
@cindex Charger et enregistrer des fichiers
@cindex Fichier, charger et enregistrer

@menu
* Formats de fichiers supportés::  Les formats que Cinelerra peut importer et exporter
* Charger des fichiers::		Charger tout type de fichier
* Charger la sauvegarde::         	Récupérer la session dans l'état précédant un plantage
* Enregistrer des fichiers::            Enregistrer la liste des décisions de montage
* Fusionner des projets::
@end menu

@c cincvdoc_node_number_62
@node Formats de fichiers supportés
@section Formats de fichiers supportés
@cindex Formats de fichiers supportés
@cindex Format de fichier

Voici la plupart des formats de fichiers supportés et des informations
concernant leur compression.  Il est possible de charger des fichiers ayant
d'autres formats que ceux indiqués ici.@*
Le format du fichier détermine ce que Cinelerra en fait.  Les paramètres du projet
sont sauvegardées dans une liste de décisions de montage (EDL) au format XML.  Les formats
qui contiennent des médias mais pas de décision de montage se contentent
d'ajouter des données aux pistes.  Si le taux d'échantillonnage de votre projet
est de 48 kHz et que vous chargez un fichier audio avec un taux de 96 kHz, vous
continuerez à le reproduire à 48 kHz.  Si vous chargez un fichier EDL à 96 kHz
et que le taux d'échantillonage du projet en cours est de 48 kHz, il sera
modifié pour 96 kHz.@*
Certains formats de fichiers sont très lents à s'afficher sur la timeline.
C'est en général parce qu'ils comportent de la vidéo avec un fort taux de
compression.  Dessiner les vignettes d'une vidéo très compressée peut être très
lent.  Il faut désactiver le dessin des vignettes pour ces fichiers à l'aide du
bouton @b{dessiner le média} et ainsi accélérer les opérations.

Les formats supportés sont actuellement :
@itemize @bullet
@item WAV
@item PCM
@item AIFF
@item Audio AC3
@end itemize

@menu
* Quicktime::
* Audio MPEG-4::
* Séquence d'images::
* Images fixes::
* AVI::
* Fichiers MPEG contenant de la vidéo::
* Films sur DVD::
* Audio MPEG 1::
* Ogg Theora/Vorbis::
* Liste de décisions de montage::
@end menu

@c cincvdoc_node_number_63
@node Quicktime
@subsection Quicktime
@cindex Quicktime

Quicktime n'est pas le standard sous UNIX mais nous l'utilisons parce qu'il est
bien documenté.  Tous les films Quicktime sur Internet sont compressés.
Cinelerra prend en compte certains fichiers compressés en Quicktime.  Mais si
Cinelerra plante lors du chargement d'un tel fichier, cela est probablement dû
au fait que le format n'a pas pû être parfaitement pris en compte.@*
Quicktime est un conteneur pour deux flux, un flux vidéo et un flux audio.  Ces
flux sont compressés en utilisant des méthodes différentes.  L'encodage préféré
pour les sorties Quicktime est la vidéo MPEG-4 et l'audio MPEG-4.  Ce format
est compatible avec la plupart des logiciels commerciaux de lecture vidéo sous
Windows, possède un bon taux de compression et une bonne qualité de sortie.
Pour une meilleure compression, il faut utiliser la vidéo H-264.
Malheureusement le décodage H-264 est tellement lent qu'il ne permet pas de
reproduire de très grandes tailles d'images.@*
Cinelerra supporte deux codecs non @w{standards :} vidéo MPEG-4 Dual et vidéo H.264
Dual.  Il ne pourront être lus nulle part ailleurs que dans Cinelerra et
XMovie.  Il sont conçus pour des films dont les images ont été divisées en deux
champs, chaque champ étant affiché séquentiellement.  Les codecs dual
entrelacent les deux flux vidéo de façon à améliorer l'efficacité sans demander
de modification majeure au logiciel de lecture.

@c cincvdoc_node_number_64
@node Audio MPEG-4
@subsection Audio MPEG-4
@cindex Audio MPEG-4

C'est le même que Quicktime avec un codec audio Audio MPEG-4.

@c cincvdoc_node_number_65
@node Séquence d'images
@subsection Séquence d'images
@cindex Séquence d'images

Le rendu d'une séquence d'images n'est pas identique au rendu d'une image
isolée.  Lorsqu'il effectue le rendu d'une séquence d'images, Cinelerra génère
un fichier de table des matières pour la séquence d'images et crée un fichier
image différent pour chaque position de la timeline.  Pour obtenir de
meilleures performances, la table des matières peut être chargée à la place de
chaque image.  Pour en apprendre davantage concernant les différents formats
d'images pris en compte dans une séquence d'images, veuillez lire ce qui
concerne les images fixes.

@c cincvdoc_node_number_66
@node Images fixes
@subsection Images fixes
@cindex Images fixes
@cindex Images, fixes

@menu
* Charger des images fixes::
* Dimensions des images fixes::
* Images Open EXR::
* Images brutes d'appareils numériques::
@end menu

@c cincvdoc_node_number_67
@node Charger des images fixes
@subsubsection Charger des images fixes
@cindex Charger des images fixes
@cindex Images fixes, chargement d'

Le rendu d'une image isolée provoque l'écrasement du fichier image pour chaque
position de la timeline.  Aucune table d'index n'est créée.  Lors du
chargement, l'image occupe la place d'une image vidéo et ne modifie pas les
attributs du projet.  Pour voir une image, zoomez sur la timeline jusqu'à ce
que puissiez la voir.  Pour allonger la durée d'une image, étendez-la comme
vous le feriez avec un média vidéo normal.  Vous pouvez allonger sa durée autant
que vous le désirez.  Les images dans Cinelerra ont la possibilité d'être
étendues sur une durée infinie.@*
Cinelerra vous permet de définir la durée initiale des images chargées.  Le
paramètre est défini dans la section Images de @b{Configuration->
Préférences->Acquisition}.@*
A moins que votre matériau d'origine ne provienne d'une source numérique (tel
qu'un appareil photo numérique), la première chose à faire avant de pouvoir
l'utiliser est, d'une manière ou d'une autre, de faire l'acquisition vers un
format de média numérique utilisable.@*
Pour des photos anciennes, des cartes en papier, des dessins ou des schémas,
vous devrez effectuer une numérisation dans un format tel que PNG, TIF, TGA ou
JPG à l'aide d'un scanner.  Vous pourrez utiliser Gimp pour retoucher les
images, nettoyer les zones endommagées ou en corriger les couleurs.@*
Si vous objets proviennent d'un appareil photo numérique ou d'une copie
d'écran, assurez vous d'effectuer l'acquisition avec la meilleure résolution
possible.  Ceci vous permettera d'obtenir de vos projets Cinelerra une sortie
de meilleure qualité.

@c cincvdoc_node_number_68
@node Dimensions des images fixes
@subsubsection Dimensions des images fixes
@cindex Dimensions des images fixes
@cindex Images fixes, dimensions des

@b{Important :} les images importées demeurent toujours dans leurs dimensions
d'origine.  Vous devrez donc tenir compte du rapport d'aspect de votre vidéo
dans Cinelerra, et devrez redimensionner vos images avant de les importer dans
Cinelerra.@*
Par exemple, le rapport d'aspect en PAL est de 4/3, mais 720x576 fait 5/4.
Pour que les images que vous importez soient affichées correctement, vous devez
redimensionner leur taille @w{horizontale :}@*
Nouvelle dimension horizontale=@math{(5 / 4) / (4 / 3)} x taille horizontale
d'origine@*
Pour les vidéo PAL, vous devrez multiplier la dimension horizontale des images
que vous désirez importer par un facteur de 0.9375.@*
Voici un petit script de l'interpréteur de commandes qui, lorsqu'il est lancé
depuis un répertoire contenant des images au format jpg, redimensionne ces
images et met les nouvelles images dans le dossier @file{resized} :
@verbatim
#/bin/sh
mkdir resized
for element in `ls . | grep jpg`;
do
    size=`identify ${element}`
    width=`echo ${size} | sed '+s+.*JPEG ++' | sed '+s+x.*++'`
    height=`echo ${size} | sed '+s+.*JPEG [0-9]*x++' | sed '+s+DirectClass.*++'`
    let new_width=${width}*9375/10000
    convert -resize ${new_width}x${height} -quality 100 ${element} resized/${element}
done
@end verbatim

@c cincvdoc_node_number_69
@node Images Open EXR
@subsubsection Images Open EXR
@cindex Images EXR
@cindex Images, EXR

Vous ne connaissez peut-être pas le format Open EXR@.  Ce format enregistre des
images RVB en virgule flottante.  Il peut aussi gérer un faible niveau de
compression.  Un projet qui effectue un rendu vers EXR doit être configuré avec
un modèle colorimétrique en virgule flottante pour pouvoir bénéficier de l'EXR.
Voir @xref{Attributs du projet}.  Un certain nombre d'options de compression
sont disponibles avec le format EXR@.

@cindex Compression
@cindex Compression PIZ
@itemize @bullet
@item @b{PIZ :} compression par ondelettes sans pertes.  C'est la meilleure
compression.
@cindex Compression ZIP
@item @b{ZIP :} algorithme gzip sans pertes.
@cindex Compression RLE
@item @b{RLE :} encodage sans pertes "run length".  C'est la compression
la plus rapide mais la moins efficace
@cindex Compression PXR24
@item @b{PXR24 :} compression avec pertes où les nombres flottants sont
convertis sous 24 bits et compressés avec gzip.
@end itemize

Choisissez @b{Utiliser un canal alpha} si le modèle colorimétrique du projet
comporte un canal alpha et que vous désirez le conserver dans le fichier.
Sinon, les couleurs primaires seront multipliées par le canal alpha.

@c cincvdoc_node_number_70
@node Images brutes d'appareils numériques
@subsubsection Images brutes d'appareils numériques
@cindex Images brutes d'appareils numériques
@cindex Images d'appareil numérique

Les images brutes de capteur (RAW) des appareils photos numériques sont un type
particulier d'images que Cinelerra ne sait qu'importer.  Une fois positionnées
sur la timeline, elle doivent être traitées dans un espace colorimétrique en
virgule flottante.  Les images brutes des appareils Canon sont les seules à
avoir été testées.  On doit leur appliquer un effet de @b{Gamma} pour en
corriger le gamma.  Parce qu'il faut beaucoup de temps pour interpoler des
images brutes, elles sont habituellement visualisées dans un fichier proxy et
ensuite retouchées.

Appliquez d'abord l'effet de gamma à la piste où se trouvent les images brutes
et configurez cet effet en mode @b{automatique} avec un gamma de @b{0,6}.
Effectuez ensuite le rendu de la timeline sous forme d'un fichier Quicktime
JPEG@.  Ajoutez le fichier Quicktime JPEG à une nouvelle piste et désactivez
l'ancienne piste.  Maintenant, la copie avec le gamma corrigé de chaque image
brute peut être prévisualisée relativement rapidement à la même position de la
timeline que l'image d'origine.

@c cincvdoc_node_number_71
@node AVI
@subsection AVI
@cindex AVI

Etant donné que le format AVI est très fragmenté, avec des codecs audio et
vidéo variés, il se peut que vous ne soyiez pas en mesure de visualiser tous
les fichiers de format AVI.

@c cincvdoc_node_number_72
@node Fichiers MPEG contenant de la vidéo
@subsection Fichiers MPEG contenant de la vidéo
@cindex Fichiers MPEG contenant de la vidéo
@cindex mpeg3toc

Les fichiers MPEG contenant de la vidéo peuvent être chargés directement dans
Cinelerra.  Si le format du fichier est supporté, une table d'index est
construite.  Si le format n'est pas géré, il s'ensuit habituellement un
plantage ou alors seules quelques pistes très courtes sont affichées.
Malheureusement cette méthode de chargement des fichiers MPEG n'est pas valable
si vous projetez d'utiliser les fichiers avec une grappe de calcul.@*
Pour utiliser les fichiers MPEG avec une grappe de calcul, vous devez utiliser
mpeg3toc pour créer une table d'index pour le fichier, puis ensuite charger la
table d'index.  Il faut indiquer à mpeg3toc le chemin absolu vers le fichier
MPEG@.  Si vous n'utilisez pas un chemin absolu, il va supposer que le fichier
MPEG se trouve dans le même répertoire que celui d'où a été lancé Cinelerra.@*
Les flux MPEG sont structurés en plusieurs pistes.  Chaque piste pouvant être
de type audio ou vidéo.  Une piste audio peut avoir de 1 à 6 canaux.  Cinelerra
convertit chaque canal en une piste.

@cindex mpeg2enc
@b{Notes concernant l'encodage vidéo MPEG :}@*
L'encodage vidéo MPEG est effectué séparément de l'encodage audio MPEG@.  Il y a
deux modèles colorimétriques possibles pour la vidéo MPEG@.  Le modèle YUV 4:2:0
est encodé par une version de mpeg2enc très optimisée avec des préréglages
correspondant à de l'électronique grand public standard.  Dans le processus
d'optimisation de mpeg2enc, ils se sont débarrassé de l'encodage YUV 4:2:2.  Le
modèle colorimétrique YUV 4:2:2 est encodé en utilisant une version moins
optimisée de mpeg2enc.@*
L'encodage YUV 4:2:2 a été conservé parce que la version NTSC de la vidéo DV
perd trop en qualité lors de la conversion vers YUV 4:2:0.  Cette vidéo DV doit
être convertie en YUV 4:2:2.@*
Lors de l'encodage YUV 4:2:0, le paramètre de débit binaire change de
signification selon que le débit binaire ou la quantification est fixe.  Si le
débit binaire est fixe, c'est le débit binaire à atteindre.  Si la
quantification est fixe, c'est le débit binaire maximum autorisé.  C'est une
astuce de la version de mpeg2enc.

@c cincvdoc_node_number_73
@node Films sur DVD
@subsection Films sur DVD
@cindex Films sur DVD
@cindex Fichier IFO

Les DVD sont constitués d'un certain nombre de programmes, chacun d'entre-eux
est identifié par un fichier @file{IFO} unique.  Si vous désirez charger un
DVD, recherchez le fichier IFO correspondant au programme qui vous intéresse.
Chargez le fichier IFO directement et une table d'index sera construite.  Si
vous utilisez une grappe de calcul, une table d'index peut être construite
séparément.@*
@cindex mpeg3toc
@w{Lancez :} @command{mpeg3toc -v /cdrom/video_ts/vts_01_0.ifo dvd.toc}@*
ou quelque chose de similaire.  Chargez ensuite le fichier @file{dvd.toc}.

@c cincvdoc_node_number_74
@node Audio MPEG 1
@subsection Audio MPEG 1
@cindex Audio MPEG 1

Ce sont des fichiers .mp2 et .mp3.  Si ces fichiers sont encodées avec un débit
binaire fixe, ils peuvent être chargés directement sans table d'index.  Les
flux à débit variable ont besoin d'une table d'index créée alors avec mpeg3toc.

@c cincvdoc_node_number_75
@node Ogg Theora/Vorbis
@subsection Ogg Theora/Vorbis
@cindex Ogg Theora/Vorbis

Le format OGG est un format dépassé, supposé libre de brevets pour compresser
de l'audio et de la vidéo.  La qualité n'est pas aussi bonne qu'en H.264 ou en
MPEG-4 Audio.  En réalité, quiconque en ayant les moyens et la volonté peut
trouver un brevet dans n'importe quoi, la justification d'OGG est donc sujette
à caution.

@c cincvdoc_node_number_76
@node Liste de décisions de montage
@subsection Liste de décisions de montage
@cindex EDL

Les listes de décisions de montage (EDL) sont créées par Cinelerra pour
l'enregistrement des projets.  Les fichiers EDL possèdent l'extension .xml.
Quand ils sont chargés, ils modifient les attributs du projet.  Comme les
listes de décisions de montage sont des fichiers texte, elles peuvent être
modifiées avec un simple éditeur de texte.

@c cincvdoc_node_number_77
@node Charger des fichiers
@section Charger des fichiers
@cindex Charger des fichiers
@cindex Fichiers, chargement

Toutes les données avec lesquelles vous travaillez dans Cinelerra sont
récupérées soit par @b{acquisition depuis un périphérique} soit en les
@b{chargeant depuis un disque}.  Cette section traite du chargement depuis un
disque.@*
Charger et reproduire des fichiers fonctionne exactement comme vous vous y
attendez.  Allez simplement dans @b{Fichier->Charger des fichiers...},
choisissez un fichier à charger et cliquez sur le bouton @b{ok}.  Cliquez le
bouton de lecture et cette dernière doit commencer, qu'une barre d'avancement
soit affichée ou non.

@center @image{manual_images_intl/load, 80mm}
@center @b{La fenêtre de chargement}

Si le fichier est une image fixe, les attributs du projet ne sont pas modifiés
et la première image de la piste devient cette image.  Si le fichier contient
de l'audio, Cinelerra peut construire un fichier d'index afin d'en accélérer le
dessin.  Vous pouvez effectuer des opération de montage ou reproduire le
fichier alors que l'index est en cours de construction.

@menu
* Stratégie d'insertion::
* Charger plusieurs fichiers::
* Charger des fichiers depuis la ligne de commande::
* Filtrer les fichiers selon leur extension::
* Charger d'autres formats::
@end menu

@c cincvdoc_node_number_78
@node Stratégie d'insertion
@subsection Stratégie d'insertion
@cindex Stratégie d'insertion

Habituellement, il se produit trois choses lorsque vous chargez un @w{fichier :}
@enumerate 1
@item le projet existant est effacé de l'écran
@item les attributs du projet sont modifiés pour correspondre à ceux du fichier
@item les nouvelles pistes correspondant au fichier sont crées sur la timeline.
@end enumerate
Cependant, Cinelerra vous permet de modifier son comportement lors du
chargement d'un fichier.@*
Dans la boîte de sélection de fichier, allez à la boîte @b{Stratégie
d'insertion} et sélectionnez-là.  Chacune de ses options permet de charger le
fichier de manière différente.
@itemize @bullet
@item @b{Remplacer le projet actuel}@*
Toutes les pistes du projet en cours sont supprimées et de nouvelles pistes
sont crées en correspondance avec la source.  Les attributs du projet ne sont
modifiés que si vous chargez un fichier XML@.  Si plusieurs fichiers sont
sélectionnées, Cinelerra créé une piste pour chaque fichier.

@item @b{Remplacer le projet actuel et concaténer les pistes}@*
Identique à "Remplacer le projet actuel", si ce n'est que si plusieurs fichiers
sont sélectionnés, Cinelerra concatène chaque piste de chaque fichier, l'une
après l'autre, dans un ordre alphanumérique.

@item @b{Ajouter de nouvelles pistes}@*
Le projet actuel n'est pas supprimé et de nouvelles pistes correspondant à la
source sont ajoutées.

@item @b{Concaténer aux pistes existantes}@*
Le projet actuel n'est pas supprimé et les nouveaux fichiers sont concaténés
aux pistes existantes.

@item @b{Coller au point d'insertion}@*
Le fichier est collé sur la timeline au point d'insertion.

@item @b{Créer de nouvelles ressources uniquement}@*
La timeline demeure inchangée et de nouvelles ressources sont créées dans la
fenêtre des ressources.
@end itemize

La stratégie d'insertion est une option que l'on retrouve dans de nombreuses
fonctions de Cinelerra.  A chaque fois, les options ont la même action.  En
utilisant ces options, vous pouvez faire presque tout votre montage rien qu'en
chargeant des fichiers.  Si vous chargez des fichiers en les passant à
Cinelerra en paramètres de la ligne de commande, les fichiers seront chargés
avec la règle @b{Remplacer le projet actuel}.

@c cincvdoc_node_number_79
@node Charger plusieurs fichiers
@subsection Charger plusieurs fichiers
@cindex Charger plusieurs fichiers
@cindex Fichiers, charger plusieurs

Dans la boîte de sélection allez à la liste des fichiers.  Sélectionnez un
fichier.  Déplacez-vous sur un autre fichier et sélectionnez-le en maintenant
la touche @key{Ctrl} enfoncée.  Ceci permet de sélectionner un fichier
supplémentaire.  Déplacez-vous sur un autre fichier et sélectionnez-le en
maintenant la touche @key{Majuscule} appuyée.  Ceci sélectionnera tous les
fichiers se trouvant entre les fichiers sélectionnés.  Ce comportement est
disponible avec la plupart des listes.@*
Utilisez cette méthode avec la stratégie d'insertion @b{Concaténer aux pistes
existantes} pour créer un diaporama de vos images ou une liste de lecture de
vos chansons.

@c cincvdoc_node_number_80
@node Charger des fichiers depuis la ligne de commande
@subsection Charger des fichiers depuis la ligne de commande
@cindex Charger des fichiers depuis la ligne de commande

Une autre manière de charger des fichiers est de passer le nom des fichiers en
paramètres de la ligne de commande.@*
@command{cinelerra myvideo.mov myothervideo.mov}@*
Ceci crée de nouvelles pistes pour chaque fichier et lance le programme en
chargeant tous les fichiers passés en paramètres.

@c cincvdoc_node_number_81
@node Filtrer les fichiers selon leur extension
@subsection Filtrer les fichiers selon leur extension
@cindex Filtrer les fichiers selon leur extension
@cindex Fichiers, extension
@cindex Extension, fichiers

S'il y a trop de fichiers dans votre répertoire de médias, il peut être
difficile de trouver le fichier que vous désirez parmi tous les autres.  Afin
de résoudre cette difficulté, la @b{fenêtre de chargement} vous permet de
filtrer les fichiers à afficher dans la liste en fonction de leur extension.@*
Cliquez sur la liste déroulante (juste en-dessous de la zone d'entrée du nom de
fichier) et sélectionnez l'extension de votre média (par @w{exemple :} mpg,
mov, mp3, avi, etc).  La liste des fichiers ne comporte maintenant plus que les
fichiers ayant l'extension indiquée.

@c cincvdoc_node_number_82
@node Charger d'autres formats
@subsection Charger d'autres formats
@cindex Charger d'autres formats

Si vous ne pouvez pas charger un type particulier de clip vidéo, et que vous ne
disposez pas de la source d'origine, vous devrez le convertir dans un format
pris en compte par Cinelerra.  Convertir votre fichier en mpeg2 est une bonne
solution, puisque Cinelerra charge ce format sans problème.  Dans ce cas, vous
devrez utiliser ffmpeg pour effectuer la conversion.  Cependant, le format
mpeg2 requiert que la vidéo possède une taille d'image et un nombre d'images
par seconde @w{spécifiques :}
@itemize @bullet
@item @b{PAL} est en 720x576 à 25 images/seconde
@item @b{NTSC} est en 720x480 à 29.97 (=30000/1001) images/seconde
@end itemize
Pour les fichiers qui n'ont pas ces propriétés, vous devriez utiliser mencoder
afin de convertir en MPEG4@.  Vous pouvez identifier les codecs et le conteneur
d'une vidéo en exécutant la commande @w{suivante :}@*
@command{mplayer -identify <your_video_file.xyz>}

@itemize @bullet
@item @b{Convertir avec ffmpeg :}@*
@command{ffmpeg -sameq -i original_video.xyz converted_video.mpeg}@*
L'option @option{-sameq} maintient la qualité de l'original.

@item @b{Convertir avec mencoder :}@*
@command{mencoder original_video.xyz -ovc lavc -lavcopts vcodec=mpeg4:\}@*
@command{vhq:vbitrate=6000 -oac mp3lame -lameopts br=256:vol=1 \}@*
@command{-ffourcc DIVX -o converted_video.avi}
@end itemize

@c cincvdoc_node_number_83
@node Charger la sauvegarde
@section Charger la sauvegarde
@cindex Charger la sauvegarde
@cindex Sauvegarde, charger la

En permanence se trouve sur le disque un fichier XML particulier.  Après chaque
opération de montage, Cinelerra enregistre le projet en cours dans une
sauvegarde placée dans @file{$HOME/.bcast/backup.xml}.  En cas de plantage, la
première opération à effectuer et de sélectionner @b{Fichier->Charger la
sauvegarde} afin de charger la sauvegarde.  Ceci aura pour effet de relancer
Cinelerra au moment de vos opérations de montage situé juste avant le plantage.
Il est important, après un plantage, de relancer Cinelerra sans faire aucune
opération de montage sinon la sauvegarde sera écrasée.

@c cincvdoc_node_number_84
@node Enregistrer des fichiers
@section Enregistrer des fichiers
@cindex Enregistrer des fichiers
@cindex Fichier, enregistrer
@cindex Fichiers, XML
@cindex Fichiers XML

Lorsque Cinelerra enregistre un fichier, il enregistre une liste des intentions
de montage mais n'enregistre aucun média.  Allez à @b{Fichier->Enregistrer
sous...}.  Choisissez un fichier à écraser ou entrez un nouveau nom de fichier.
Cinelerra ajoutera automatiquement l'extension @samp{.xml} au nom de fichier si
elle n'est pas indiquée.

Le fichier enregistré contient tous les paramètres du projet et l'emplacement
de chacun des plans.  A la place du média, il contient des pointeurs vers les
fichiers de média d'origine sur le disque.

Pour chaque fichier de média, le fichier XML enregistre soit le chemin absolu
soit uniquement un chemin relatif.  Si le média se trouve dans le même
répertoire que le fichier XML, un chemin relatif est enregistré.  S'il se
trouve dans un répertoire différent, un chemin absolu est enregistré.

Afin de pouvoir déplacer les fichiers XML sans casser les liens vers les
médias, vous devez soit toujours conserver les médias dans le même répertoire
que le fichier XML ou enregistrer le fichier XML dans un autre répertoire que
les médias et ne plus jamais déplacer les médias par la suite.

Si vous désirez créer une liste de lecture audio pour la graver sur un CD,
enregistrez le fichier XML dans le même répertoire que les fichiers audio et
gravez l'ensemble du répertoire.  Ceci permettra de conserver des chemins
relatifs.

Les fichiers XML sont utiles pour enregistrer l'état actuel de Cinelerra avant
de terminer sa session de montage.  Les fichiers XML sont spécifiques à
Cinelerra.  Vous ne pouvez pas lire des fichiers XML dans un lecteur vidéo
dédié.  Les effets en temps réel d'un fichier XML doivent être resynthétisés
chaque fois que vous les rejouez.  Le fichier XML nécessite aussi que vous
conserviez tous les objets source sur le disque dur, ce qui prend de la place
et coûte de l'électricité pour les faire tourner.  Effectuez le rendu de vos
vidéos dans un format final pour un stockage plus long du résultat final.

@c cincvdoc_node_number_85
@node Fusionner des projets
@section Fusionner des projets
@cindex Fusionner des projets

Pour fusionner plusieurs projets séparés en un même gros projet :
@enumerate 1
@item Lancer Cinelerra
@item Charger le projet A
@item Lancer une seconde instance de Cinelerra
@item Charger le projet B
@item Couper et coller depuis A vers B
@end enumerate

@c cincvdoc_node_number_86
@node La fenêtre de programme
@chapter La fenêtre de programme
@cindex La fenêtre de programme

@menu
* Naviguer dans la fenêtre de programme::
* Le montage::                           déplacer le média dans le temps.
@end menu

Elle contient la timeline et c'est le point d'entrée pour toutes les opérations
lancées depuis le menu.  La timeline consiste en une pile verticale de pistes
avec une représentation horizontale du temps.  Ceci définit la sortie des
opérations de rendu et ce qui sera enregistré lorsque vous enregistrez des
fichiers.  A la gauche de la timeline se trouve la boîte à boutons (patchbay)
qui contrôle les options affectant chacune des pistes.

@center @image{manual_images_intl/program_insertion_point,120mm}
@center @b{La timeline}

Dans le menu @b{Fenêtre}, vous trouverez des options qui affectent les fenêtres
principales.  L'option @b{Positions par défaut} permet de repositionner les
fenêtres dans une configuration de montage à 4 fenêtres.  Sur les systèmes à
deux écrans, l'opération de positionnement par défaut ne place les fenêtres que
sur un seul écran.

@c cincvdoc_node_number_87
@node Naviguer dans la fenêtre de programme
@section Naviguer dans la fenêtre de programme
@cindex Naviguer dans la fenêtre de programme
@cindex Fenêtre de programme

La fenêtre de programme comporte de nombreuses fonctionnalités pour naviguer
sur la timeline et l'afficher comme elle est structurée en @w{mémoire :} les pistes
sont empilées verticalement et se déroulent horizontalement dans le temps.  La
barre de défilement horizontal vous permet de balayer le temps.  La barre de
défilement vertical vous permet de faire défiler les différentes pistes.

@menu
* Les pistes vidéo::
* Les pistes audio::
* La navigation sur les pistes::
* Le menu déroulant de la piste::
* Le point d'insertion::
* Les points d'entrée/sortie::
* Utiliser les marques dans la fenêtre de programme::
@end menu

@c cincvdoc_node_number_88
@node Les pistes vidéo
@subsection Les pistes vidéo
@cindex Les pistes vidéo

@center @image{manual_images_intl/track_video,120mm}
@center @b{Une piste video}

Les pistes vidéo représentent la succession de vos séquences vidéo, comme si
vous aviez placé des pellicules photographiques bout à bout sur une table.  Les
images individuelles que vous voyiez sur la piste sont un extrait de ce qui est
situé dans la vidéo à instant donné.

@c cincvdoc_node_number_89
@node Les pistes audio
@subsection Les pistes audio
@cindex Les pistes audio

@center @image{manual_images_intl/track_audio,120mm}
@center @b{Une piste audio}

Les pistes audio représentent votre média sonore par une forme d'onde audio.
En poursuivant l'analogie avec le film, c'est comme si vous pouviez "voir" la
bande magnétique horizontalement sur votre table.@*
Vous pouvez ajuster le grossissement horizontal et vertical des pistes en
utilisant la @b{la barre du panneau de zoom}.@*
Les commandes situés à la gauche des pistes sont appelées la @b{boîte à
boutons}.  La @b{boîte à boutons} est utilisée pour contrôler le comportement
des pistes.

@c cincvdoc_node_number_90
@node La navigation sur les pistes
@subsection La navigation sur les pistes
@cindex Navigation sur les pistes

La navigation sur les pistes demande à choisir une piste spécifique (audio ou
vidéo) et se déplacer jusqu'à un point précis de la piste.  La fenêtre de
programme comporte de nombreuses fonctionnalités de navigation et affiche la
timeline telle qu'elle est structurée en mémoire.

La barre de défilement horizontal vous permet de balayer le temps.

La barre de défilement vertical vous permet de parcourir les pistes.

En plus des outils graphiques, vous pouvez aussi utiliser le clavier pour
naviguer.  En règle générale, la navigation au clavier est plus rapide que la
navigation à la souris.  Utilisez @kbd{PAGE PREC} et @kbd{PAGE SUIV} pour faire
défiler les pistes vers le haut et vers le bas.

Vous aurez souvent besoin de vous déplacer au-delà des limites de la timeline,
mais les barres de défilement ne vous le permettent pas.  A la place, utilisez
la flèche DROITE pour vous déplacer après la fin de la timeline.

Les touches de @key{DEBUT} et de @key{FIN} vous permettent de vous déplacer
instantanément au début ou à la fin de la timeline.  Dans le mode @b{I-beam},
maintenir la touche @key{MAJ} enfoncée en pressant la touche @key{DEBUT} ou
@key{FIN} vous permettra de sélectionner tout ce qui se trouve entre le point
d'insertion et la touche pressée.

Sous la timeline, vous trouverez le panneau de zoom.  Le panneau de zoom
comporte la @b{valeur de zoom}, l'@b{amplitude}, le @b{zoom de piste}, et le
@b{zoom de courbe}.  En plus des barres de défilement, ces valeurs sont les
outils principaux pour positionner la timeline.

@center @image{manual_images_fr/zoompanel,100mm}

Modifier la @b{valeur de zoom} change l'unité de temps affichée sur la
timeline.  Cela permet de visualiser votre média depuis un affichage image par
image jusqu'à un affichage complet de la timeline.  Plus cette valeur est
élevée, et plus vous verrez d'images à l'écran.  @b{Si votre souris possède une
molette et qu'elle fonctionne avec X11, plutôt que les boutons de réglage,
utilisez la molette pour zoomer et dézoomer}.

@cindex Amplitude
L'@b{amplitude} n'affecte que l'audio.  Elle détermine la taille de la forme
d'onde lorsqu'elle est dessinée.

@cindex Zoom de piste
Le @b{zoom de piste} affecte toutes les pistes.  Il détermine la hauteur de
chaque piste.  Si vous changez la valeur du zoom de piste, le zoom d'amplitude
permet d'effectuer une compensation afin que les formes d'onde audio
apparaissent proportionnelles.

@cindex Zoom de courbe
Le @b{zoom de courbe} affecte les courbes de toutes les pistes.  Il détermine
l'amplitude et le décalage des courbes.  Les boutons de réglage règlent
l'amplitude de la courbe, mais la seule façon de modifier le décalage de courbe
est d'utiliser le @image{manual_images_intl/fit_curves} bouton @b{remplir les
courbes}.

Utilisez les flèches @kbd{GAUCHE} et @kbd{DROITE} pour vous déplacer dans le
temps avec de petits incréments.  Vous aurez souvent besoin de vous déplacer
au-delà de la fin de la timeline, mais les boutons de défilement ne vous le
permetteront pas.  A leur place, utilisez la flèche @kbd{DROITE} afin d'aller
au-delà de l'extrémité de la timeline.

Les flèches @kbd{HAUT} et @kbd{BAS} permettent de modifier la valeur de zoom
par puissances de deux.

@kbd{CTRL-HAUT} et @kbd{CTRL-BAS} permettent de modifier le zoom d'amplitude.

@kbd{CTRL-PAGE PREC} et @kbd{CTRL-PAGE SUIV} permettent de modifier le zoom de
piste.

@kbd{ALT-HAUT} et @kbd{ALT-BAS} permettent de modifier le zoom de courbe.

@c cincvdoc_node_number_91
@node Le menu déroulant de la piste
@subsection Le menu déroulant de la piste
@cindex Le menu déroulant de la piste

Chaque piste possède un menu déroulant.  Pour activer le @b{menu déroulant de
la piste}, faites un clic droit sur la piste.  Le menu déroulant affecte la
piste, qu'elle soit armée sur la @b{boîte à boutons} ou non.  Le menu de piste
contient certaines @w{options :}
@itemize @bullet
@item Attacher un effet
@item Déplacer vers le bas - déplace la piste sélectionnée vers le haut de la
pile.
@item Déplacer vers le haut - déplace la piste sélectionnée vers le bas de la
pile.
@item Supprimer la piste - supprime la piste du programme
@item Ajouter une piste - ajoute une piste du même type de média (audio/vidéo)
que celle qui est sélectionnée.
@item Redimensionner la piste - redimensionne la piste
@item Adapter aux dimensions de la sortie - fait correspondre les dimensions
des pistes à celle de la sortie
@end itemize

@c cincvdoc_node_number_92
@node Le point d'insertion
@subsection Le point d'insertion
@cindex Point d'insertion

La première fois que vous lancerez Cinelerra, vous pourrez voir un point
d'insertion clignotant dans la fenêtre de programme.  Semblable au curseur d'un
traitement de texte, le point d'insertion marque l'emplacement de la timeline
où la prochaine opération du programme commencera.  C'est aussi le point de
départ de toutes les opérations de lecture.  Lors du rendu, il définit la
région de la timeline dont il faut effectuer le rendu.

@center @image{manual_images_intl/program_insertion_point,100mm}
@center @b{Le point d'insertion sur la fenêtre principale du programme,}
@center @b{indiqué par la fine ligne verticale au point 00:00.500}

Normalement, le point d'insertion se déplace en cliquant sur la barre
temporelle.  Toute région de la barre temporelle qui n'est pas obscurcie par
des marques ou par les points d'entrée/sortie est une cible possible pour
repositionner le point d'insertion.

@center @image{manual_images_intl/main_timebar,160mm}
@center @b{La barre temporelle principale}

En fonction du mode d'opération, le point d'insertion peut être déplacé en
cliquant sur la timeline elle-même.  Le point d'insertion possède deux modes de
@w{fonctionnement :}
@itemize @bullet
@item Mode glisser-déposer
@item Mode couper-coller
@end itemize

Le mode de fonctionnement est déterminé en choisissant la flèche ou le i-beam
dans la barre d'outils.

@anchor{r943_r944_editing_modes}@b{Note:} Les révisions 943 et 944 de Cinelerra CV (versions SVN allant du 19
au 21 octobre 2006) ne possèdent pas d'icônes de sélection des modes.  Les
modes "glisser-déposer" et "copier coller" ne font, dans ces révisions, plus
qu'un.  La touche @kbd{MAJ} permet de passer de l'un à l'autre de ces modes.
C'est le cas de l'ebuild Gentoo media-video/cinelerra-cvs-20061020.

@center @image{manual_images_intl/editing_mode,15mm}
@center @b{Les boutons de mode de montage}

@cindex Mode glisser-déposer
Si la flèche est en surbrillance, le @b{mode glisser-déposer} est actif.  Dans
le mode glisser-déposer, cliquer sur la timeline ne repositionne pas le point
d'insertion.  En fait, cela sélectionne l'ensemble du plan.  Un glisser sur la
timeline repositionne le plan, le collant à la limite d'un autre plan.  C'est
particulièrement utile pour modifier l'ordre des listes de lecture audio et
pour déplacer des effets.

@cindex Mode copier-coller
Si le i-beam est en surbrillance, le @b{mode couper-coller} est actif.  Dans le
mode couper-coller, cliquer sur la timeline repositionne le point d'insertion.
Un glisser sur la timeline met la région en surbrillance.  La région en
surbrillance sera la région à reproduire lors de la prochaine opération de
lecture, la plage à rendre lors de la prochaine opération de rendu et la région
affectée par les opérations de couper-coller.

@center @image{manual_images_intl/program_highlight,100mm}
@center @b{Pistes avec une zone en surbrillance, affichée à l'intérieur de la zone verte}

@b{MAJ-clic} sur le timeline étend la région en surbrillance.

Un @b{double-clic} sur la timeline permet de sélectionner l'ensemble du plan
sur lequel se trouve le curseur.

Lorsqu'on déplace le point d'insertion ou qu'on sélectionne des régions, les
positions sont alignées soit sur les images soit sur les échantillons.  Lorsque
vous montez de la vidéo, vous choisirez d'effectuer un alignement sur les
images alors que vous choisirez un alignement sur des échantillons si vous
montez de l'audio.  Indiquez votre préférence en définissant
@b{Configuration->Aligner le curseur sur les images}.

Si la région en surbrillance est la région affectée par les opérations
couper-coller, comment effectuer un couper et coller en @b{mode
glisser-déposer} ? Dans ce cas, il faut placer les @b{points d'entrée et de
sortie} de manière à définir la région affectée.

@c cincvdoc_node_number_93
@node Les points d'entrée/sortie
@subsection Les points d'entrée/sortie
@cindex Points d'entrée/sortie

Dans les deux mode de montage, vous pouvez définir un point d'entrée et un point de sortie.
Les points d'entrée/sortie définissent la région affectée.  Dans le mode
glisser-déposer, c'est la seule manière de définir une région affectée.  A la
fois dans le mode glisser-déposer et dans le mode couper-coller, la région en
surbrillance a préséance sur les points d'entrée/sortie.  Si une zone en
surbrillance a été définie ainsi que les points d'entrée/sortie, la zone en
surbrillance est affectée par les opérations de montage et les points
d'entrée/sortie sont ignorés.  S'il n'y a pas de région en surbrillance, les
points d'entrée/sortie sont utilisés.

Normalement, les points d'entrée/sortie n'affectent pas la région qui est lue.
Les points d'entrée/sortie déterminent la région qui sera lue uniquement si
vous pressez la touche @key{CTRL} en même temps que vous lancez la commande de
lecture.

Pour placer les points d'entrée/sortie, allez sur la barre temporelle et placez
le point d'insertion quelque part.  Sélectionnez le
@image{manual_images_intl/in_point_button,5mm} @b{bouton de point d'entrée}.
Allez à un endroit situé après le point d'entrée et cliquez sur le
@image{manual_images_intl/out_point_button,5mm} @b{bouton de point de sortie}.

@center @image{manual_images_intl/inout_points,160mm}
@center @b{Barre temporelle avec points d'entée/sortie définis}.

Si vous sélectionnez soit le point d'entrée, soit le point de sortie, le point
d'insertion va se déplacer à cet emplacement.  Après avoir sélectionné un point
d'entrée, si vous cliquez de nouveau le @b{bouton de point d'entrée}, le point
d'entrée sera effacé.  Après avoir sélectionné un point de sortie, si vous
cliquez le @b{bouton de point de sortie}, le point de sortie sera effacé.

@b{Astuce:} Pour rapidement vous débarasser des points d'entrée et de sortie,
sans vous préoccuper de l'endroit où ils se trouvent, ou bien s'ils sont
présents ou non, faites tout simplement un double-clic sur les boutons [ et ].
Le premier clic va définir au point d'insertion un nouveau point ou
repositionner celui qui existait déja;  le second clic va le supprimer.

Si vous sélectionnez une région n'importe où ailleurs alors que les points
d'entrée/sortie existent, les points existants seront repositionnés lorsque
vous cliquerez les boutons des points d'entrée/sortie.

@b{MAJ-clic} sur un point d'entrée/sortie étend la zone en surbrillance jusqu'à
ce point.  Si une région était déja en surbrillance, cette région sera étendue
jusqu'à ce point d'entrée/sortie.

A la place de la barre de boutons, vous pouvez utiliser les touches de
raccourcis @kbd{[} et @kbd{]} pour insérer ou supprimer les points
d'entrée/sortie.

A la fois dans le mode copier-coller et dans le mode glisser-déposer, les
points d'entrée/sortie on préséance sur la zone en surbrillance.  S'il existe à
la fois une région en surbrillance et les points d'entrée-sortie, la région en
surbrillance affecte la lecture alors que les points d'entrée-sortie affectent
les opérations de montage.  Afin d'éviter toute confusion, il est préférable
d'utiliser soit la surbrillance, soit les points d'entrée-sortie mais pas les
deux simultanément.

Le point d'insertion et les points d'entrée/sortie vous permettent de définir
la région affectée, mais ils ne vous permettent pas de vous déplacer très
facilement à des endroits précis de la timeline.  Les marques sont faites pour
cet usage.

@c cincvdoc_node_number_94
@node Utiliser les marques dans la fenêtre de programme
@subsection Utiliser les marques dans la fenêtre de programme
@cindex Marques, utiliser dans la fenêtre de programme

Les marques sont une manière simple de définir des emplacements précis de la
timeline où vous désirez vous déplacer.  Lorsque vous placez point d'insertion
quelque part et que vous cliquez @image{manual_images_intl/label_button,5mm} le
@b{bouton de marque}, une nouvelle marque est placée sur la timeline.

@center @image{manual_images_intl/timebar_label,160mm}
@center @b{Barre temporelle avec une marque}

Indépendamment des valeurs de zoom, en cliquant sur une marque, vous
positionnez le point d'insertion exactement où elle se trouve.  Vous effacerez
une marque en la sélectionnant et en cliquant sur le bouton de marque.

@b{MAJ-clic} sur une marque met en surbrillance la région située entre cette
marque et le point d'insertion.  Si une région était déja en surbrillance, cela
étend cette région en surbrillance jusqu'à la marque.

Un @b{double-clic} entre deux marques sur la barre temporelle met en surbrillance la région située
entre les deux marques.

Presser la touche @key{l} a le même effet que cliquer sur le bouton de marque.

Si vous cliquez le bouton de marque lorsqu'une région est en surbrillance,
l'état des deux marques placées à chaque extrémité de la zone en surbrillance
est inversé.  Cependant, si une extrémité comporte déjà une marque, la marque en question
sera supprimée.

Les marques peuvent repositionner le point d'insertion lorsqu'elles sont
sélectionnées mais elles peuvent aussi être parcourues avec
@image{manual_images_intl/label_traversal,15mm} les @b{boutons de parcours des
marques}.  Lorsqu'une marque est hors de vue, les boutons de parcours des
marques repositionnent la timeline de façon à ce que la marque soit visible.
Il y a aussi des raccourcis clavier pour le parcours des marques.

@b{CTRL-GAUCHE} repositionne le point d'insertion à la marque précédente.

@b{CTRL-DROITE} repositionne le point d'insertion à la marque suivante.

Avec le parcours des marques, vous pouvez vous déplacer rapidement en avant et
en arrière sur la timeline mais vous pouvez aussi sélectionner des régions.

@b{MAJ-CTRL-GAUCHE} étend la région en surbrillance jusqu'à la marque
précédente.

@b{MAJ-CTRL-DROITE} étend la région en surbrillance jusqu'à la marque
suivante.

Cliquer manuellement sur le bouton de marque, ou utiliser la touche @key{l}, de
manière répétitive pour supprimer une série de marques peut être fastidieux.
Pour supprimer un ensemble de marques, mettez tout d'abord en surbrillance une
région.  Ensuite, utilisez la fonction @b{Editer->Supprimer les marques}.  Si
les points d'entrée/sortie existent, les marques entre les points d'entrée et
de sortie seront supprimées et la région en surbrillance ignorée.

@b{Editer les marques ou empêcher leur déplacement :}@*
Uniquement dans le mode de montage par @b{Copier-Coller}, en validant @b{Editer
les marques} dans le menu de configuration, ou en désactivant
@image{manual_images_intl/locklabels_unlocked,5mm} le bouton @b{Empêcher le
déplacement des marques} sur la barre d'outils de la fenêtre principale, les
marques seront coupées, copiées et collées en même temps que la région
sélectionnée de la première piste armée.@*
De la même manière, si une zone sélectionnée d'une ressource est ajoutée depuis
la visionneuse vers la timeline à une position qui précède les marques, ces
marques seront poussées vers la droite de la barre temporelle de la durée de la
zone sélectionnée.@*
Pour éviter que les marques se déplacent sur la barre temporelle,
désactivez simplement l'option @b{Editer les marques} ou activez le
@image{manual_images_intl/locklabels_unlocked,5mm} bouton @b{Empêcher le
déplacement des marques}.@*
Dans le mode de montage par @b{glisser-déposer}, les marques seront toujours
verrouillées à la barre temporelle, même si l'option @b{Editer les marques}
est activée.

@c cincvdoc_node_number_95
@node Le montage
@section Le montage
@cindex Montage

Le montage s'effectue à la fois dans le domaine du temps et dans le domaine de
la piste.  Comme la timeline est constituée d'une pile de pistes, vous devez
vous préoccuper, en plus de l'instant où un média déterminé doit apparaître sur
la piste, de la manière de classer et de créer les pistes.

Dans le domaine du temps, Cinelerra offre de nombreuses manière d'aborder le
processus de montage.  Les trois méthodes principales sont le montage à deux
écrans, le montage par glisser-déposer, et le montage par couper-coller.

Lors du montage, Cinelerra utilise un certain nombre de concepts qui
s'appliquent à chacune des méthodes.  La @b{timeline} est le lieu où sont
représentées toutes les décisions de montage.  C'est une pile de pistes au
centre de la fenêtre principale.  On peut la faire défiler vers le haut, le
bas, la gauche et la droite à l'aide des barres de défilement qui se trouvent
sur sa droite et en bas.  On peut aussi la faire défiler vers le haut ou vers
le bas à l'aide de la molette de la souris.

La @b{région active} est la plage de temps qui est affectée par les commandes
de montage sur la timeline.  La région active est d'abord déterminée par la
présence des points d'entrée/sortie sur la timeline.  S'ils n'existent pas, la
région en surbrillance est utilisée.  Enfin, s'il n'y a pas de zone en
surbrillance, le point d'insertion est utilisé comme point de départ de la
région active.  Certaines commandes, comme le @b{rendu}, traitent tout l'espace
situé à droite du point d'insertion comme étant la région active, alors que
d'autres considèrent que la région active a une longueur nulle s'il n'y a pas
de point de fin de défini pour la région active.

Enfin, les décisions de montage n'affectent jamais le matériau source.  C'est
un @b{montage non destructif}, il est devenu populaire avec l'audio parce que
c'était beaucoup plus rapide que si vous aviez à copier tous les fichiers de
média affectés par une opération de montage.  Le montage n'affecte que des
pointeurs vers le matériau source, ce qui fait que si vous voulez avoir un
fichier de média qui représente vos décisions de montage à la fin de votre
session de montage, vous devez en effectuer le @b{rendu}.  @xref{Le rendu de
fichiers}.

Chaque piste de la timeline comporte un jeu d'attributs sur sa gauche.  Le plus
important est l'attribut de @b{piste armée}.

@xref{Raccourcis d'édition}, pour les informations concernant les raccourcis
d'édition.

@menu
* La boîte à boutons::           	Activer certaines fonctionnalités sur certaines pistes
* Décaler les pistes::        	 	Déplacer horizontalement une piste entière
* Panoramique des pistes::        	Modifier les canaux audio de sortie
* Panoramique automatique des pistes::  Panoramique des pistes selon des dispositions courantes de haut-parleurs
* Cartographie audio standard:: 	Réaliser un panoramique qui fonctionne sur d'autre lecteur.
* Manipuler les pistes::    		Déplacer d'un endroit à un autre une piste entière
* Le montage à deux écrans::     	Utiliser deux denêtre vidéo pour le montage
* Le montage par glisser-déposer::  	Glisser les objets à monter
* Le montage par copier-coller::  	Editer le média comme du texte
* Ajustement::               		Modifier les points d'entrée/sortie
@end menu

@c cincvdoc_node_number_96
@node La boîte à boutons
@subsection La boîte à boutons
@cindex La boîte à boutons

A gauche de la timeline se trouve une région affectueusement appelée patchbay,
la boîte à boutons.  La boîte à boutons active certaines fonctionnalités
spécifiques à chaque piste.  Toutes les pistes ont une zone de texte permettant
de les nommer.

Toutes les pistes ont un bouton permettant de les @b{déplier}
@image{manual_images_intl/expandpatch_checked,5mm} afin d'afficher davantage
d'options et pour afficher les effets sur la piste.  Cliquez sur ce bouton pour
déplier ou replier la piste.  S'il pointe vers le côté, la piste est repliée.
S'il pointe vers le bas, la piste est dépliée.  Les effets existants
apparaissent en-dessous du média pour la piste.

Toutes les pistes ont la ligne de boutons suivante correspondant à différentes
fonctions.

@center @image{manual_images_fr/track_attributes}
@center @b{Attributs de la piste}

Si le bouton est coloré, il est actif.  Si le bouton est d'une couleur
identique à l'arrière-plan de la plupart des fenêtres, il est désactivé.
Cliquez sur le bouton pour activer ou désactiver la fonction.  L'utilisation de
la souris accélère la configuration de plusieurs pistes en même temps.

Cliquer sur un attribut et le glisser sur les pistes adjacentes permet de
copier cet attribut sur toutes ces pistes.

Maintenez enfoncée la touche @key{MAJ} en cliquant sur un attribut de piste
pour activer l'attribut pour la piste en cours et basculer l'état de cet
attribut pour toutes les autres pistes.

Maintenez enfoncée la touche @key{MAJ} en cliquant sur un attribut.  Cliquez
jusqu'à ce que toutes les pistes exceptée celle qui est sélectionnée soient
désactivées.  Glissez ensuite le curseur par-dessus la piste adjacente pour
activer l'attribut pour la piste adjacente.

Autres attributs affectant la sortie de la piste :

@cindex Jouer la piste
@itemize @bullet
@item @b{Jouer la piste}@*
Détermine si la piste sera jouée ou pas.  S'il est désactivé, la piste ne sera
pas rendue.  Cependant, si la piste est chaînée avec une autre piste
quelconque, les autres pistes exécuteront tous les effets dans la piste
chaînée, indépendamment de l'état de ce bouton.

@cindex Armer la piste
@item @b{Armer la piste}@*
Détermine si la piste est armée ou pas.  Seules les @b{pistes armées} sont
affectées par les opérations de montage.  Assurez-vous que vous avez
suffisamment de pistes de destination armées lorsque vous collez ou insérez du
matériau ou certaines pistes du matériau ne seront pas traitées.@*
En plus de restreindre les opérations de montage, les pistes armées, en
association avec la région active, déterminent l'emplacement où le matériau
sera inséré lors du chargement de fichiers.  Si les fichiers sont chargés avec
une stratégie d'insertion qui n'efface pas le projet en cours, les pistes
armées seront utilisées en tant que pistes de destination.@*
Pressez la touche @key{TAB} alors que le curseur se trouve n'importe où sur une
piste pour modifier l'état armé de la piste.@*
Pressez @key{MAJ-TAB} alors que le curseur se trouve sur une piste pour
inverser l'état armé de chacune des autres pistes.

@cindex Grouper les réglages
@item @b{Grouper les réglages}@*
Permet de faire se déplacer le curseur de niveau audio de la piste de façon à
ce qu'il suive le mouvement du curseur d'une autre piste.  Un curseur ne peut
être groupé que si la piste est @b{armée}.  Ceci est normalement utilisé pour
ajuster les niveaux audio de toutes les pistes simultanément.  Le regroupage
permet aussi au paramètre de @b{décalage} d'être appliqué de manière synchrone
sur toutes les pistes regroupées.

@cindex Dessiner le média
@item @b{Dessiner le média}@*
Détermine si des vignettes ou formes d'onde doivent être affichées sur la
piste.  Par défaut, certains formats de fichiers se chargent avec ce paramètre
désactivé alors que d'autres se chargent avec ce paramètre activé.  Ceci dépend
du temps nécessaire à l'affichage des vignettes en fonction du format de
fichier.  Activez-le simplement si vous désirez voir les vignettes quel que
soit le format de fichier.

@cindex Muet
@item @b{Muet}@*
Fait abandonner la sortie lorsque la piste est complètement rendue.  Ceci se
produit que la piste soit @b{jouable} ou pas.  Si la piste fait partie d'une
chaîne d'effets, la sortie de l'effet est surchargée même si elle est reroutée
vers une autre piste.  Rendre une piste muette est utilisé pour éviter à la
piste d'effet en chaîne de surcharger la sortie de la piste source.

@cindex Réglage de niveau
@item @b{Réglage de niveau}@*
Toutes les pistes ont un curseur de réglage de niveau, mais les unités de
chacun des réglages dépendent du type, audio ou vidéo, de la piste.  Cliquez et
glissez le curseur pour diminuer/augmenter le niveau de l'audio/vidéo de cette
piste.  Si elle est regroupée avec d'autres pistes du même type de média, et
que l'option @b{armée} est active, les autres curseurs suivront.  Pour centrer
le curseur sur 0, maintenez touche @key{Majuscule} et glissez le curseur.
@end itemize

@c cincvdoc_node_number_97
@node Décaler les pistes
@subsection Décaler les pistes
@cindex Décaler les pistes
@cindex Pistes, décaler

Chaque piste possède, dans la boîte à boutons, une boîte de texte dans laquelle
on peut inscrire une valeur du décalage.  Vous pouvez avoir besoin de déplier
la piste pour la voir.  Voici des vues de la boîte à boutons lorsqu'elle est
dépliée.

@center @image{manual_images_fr/apatches}
@center @b{Panoramique et décalage d'une piste audio}

@center @image{manual_images_fr/vpatches}
@center @b{Mode d'overlay et décalage d'une piste vidéo}

Le décalage est la valeur dont la piste est décalée vers la gauche ou vers la
droite lors de la lecture.  La piste n'est pas affichée décalée sur la timeline
mais elle est décalée lorsqu'elle est jouée.  Ceci est utile pour synchroniser
de l'audio avec de la vidéo, pour créer de la fausse stéréo, ou pour compenser
un effet qui décale le temps, tout ça sans avoir à effectuer d'opération de
montage.

Entrez simplement la durée de décalage pour obtenir instantanément un décalage
de la piste.  La piste sera jouée plus tard si la valeur entrée est négative.
Elle sera jouée plus tôt si cette valeur est positive.  Les unités de décalage
sont soit des @b{secondes}, soit les les unités natives de la piste.
Choisissez les unités par un @b{clic droit} dans la boîte de texte de décalage
et utilisez le menu contextuel.

Les paramètres de décalage sont regroupés avec le bouton de @b{regroupement des
réglages de niveau} et le bouton d'@b{armement} des pistes.

Utilisez la molette de la souris sur la boîte de texte de décalage pour
l'incrémenter ou le décrémenter.

@c cincvdoc_node_number_98
@node Panoramique des pistes
@subsection Panoramique des pistes
@cindex Panoramique des pistes
@cindex Pistes, panoramique

Les pistes audio ont une boîte de panoramique dans leur boîte à boutons.  Une
piste audio doit être dépliée pour que la boîte de panoramique soit visible.
La boîte de panoramique est affichée ici.

@center @image{manual_images_fr/apatches}
@center @b{Panoramique et décalage d'une piste}

Placez le pointeur dans la boîte de panoramique et cliquez-glissez pour
repositionner la sortie audio dans la disposition des haut-parleurs.  La
puissance sonore de chacun des haut-parleurs est indiquée lors de l'opération
de glisser.  La boîte de panoramique utilise un algorithme spécial afin de
permettre à l'audio d'être focalisée vers un seul haut-parleur ou d'être
distribuée vers les haut-parleurs les plus proches lorsque plus de 2
haut-parleurs sont utilisés.

@c cincvdoc_node_number_99
@node Panoramique automatique des pistes
@subsection Panoramique automatique des pistes
@cindex Panoramique des pistes, automatique

Un certain nombre de fonctions pratiques sont fournies qui permettent la
configuration automatique du panoramique selon des standards habituels.  Elles
se trouvent dans le menu @b{Audio}.  Ces fonctions n'affectent que les pistes
audio qui ont @b{enregistrement} activé.

@itemize @bullet
@item @b{Audio->Correspondance 1 vers 1}@*
Ceci fait correspondre chaque piste à son propre canal et recommence au début
lorsque tous les canaux ont été affectés.  C'est surtout utile pour faire
correspondre 2 pistes de 2 canaux avec de la stéréo et pour faire correspondre
6 pistes de 6 canaux à une carte son de 6 canaux.

@item @b{Audio->Correspondance 5.1 vers 2}@*
Ceci fait correspondre 6 pistes à 2 canaux.  Le projet doit avoir 2 canaux
lorsqu'on utilise cette fonction.  Aller à @b{Configuration->Format...} pour
définir le nombre de canaux de sortie à 2.  Ceci surtout utile pour faire du
mixage d'audio 5.1 vers de la stéréo.
@end itemize

@c cincvdoc_node_number_100
@node Cartographie audio standard
@subsection Cartographie audio standard
@cindex Cartographie audio standard
@cindex Cartographie audio, standard

Bien que Cinelerra vous permette de faire correspondre n'importe quelle piste
audio à n'importe quel haut-parleur, il existe des correspondances standard que
vous pouvez utiliser afin d'être certain que le média pourra être lu ailleurs.
De plus, la plupart des encodeurs ont besoin que les pistes audio correspondent
à des numéros de hauts-parleurs standards ou ils ne fonctionneront pas.

@cindex Position du canal
@cindex Canal, position
Dans l'élément graphique @b{position du canal}, @xref{Attributs du projet}, les
canaux sont numérotés afin de correspondre aux pistes de sortie vers lesquelles
ils sont rendus.  Pour de la stéréo, la source du canal 1 doit être la piste de
gauche et la source du canal 2 doit être la piste de droite.

Pour le son 5.1 "surround", les sources pour les 6 canaux doivent être, dans
l'ordre, le centre, l'avant-gauche, l'avant-droit, l'arrière-gauche,
l'arrière-droit et les effets basses fréquences.  Si les pistes de droite ne
correspondent pas aux hauts-parleurs de droite, la plupart des encodeurs audio
n'encoderont pas l'information de droite, s'ils encodent quelque chose.  La
piste des effets basses fréquences, plus particulièrement, ne peut pas contenir
dans la plupart des cas de hautes fréquences.

@c cincvdoc_node_number_101
@node Manipuler les pistes
@subsection Manipuler les pistes
@cindex Manipuler les pistes
@cindex Pistes, manipuler

Dans Cinelerra, les pistes peuvent contenir soit de l'audio, soit de la vidéo.
Il n'y a pas de désignation particulière pour les pistes autre que le type de
média qu'elles contiennent.  Lorsque vous créez un nouveau projet, il comporte
un certain nombre de pistes par défaut.  Vous pouvez toujours ajouter ou
supprimer des pistes par la suite depuis les menus.  Le menu @b{Pistes}
comporte des options permettant de manipuler simultanément plusieurs pistes.
Chaque piste elle-même comporte un menu déroulant qui affecte une piste.

Affichez le menu déroulant en vous déplaçant sur une piste et en faisant un
clic-droit.  Le menu déroulant affecte la piste qu'elle soit armée ou non.@*
@cindex Déplacer les pistes
@cindex Pistes, déplacer
@b{Déplacer vers le haut} et @b{déplacer vers le bas} déplace la piste vers le
haut ou vers le bas dans la pile.  @b{Supprimer la piste} supprime la piste.

Les opérations depuis le menu des @b{Pistes} n'affectent que les pistes qui
sont armées :
@itemize @bullet
@item @b{Déplacer les pistes vers le haut} et @b{Déplacer les pistes vers le
bas} décalent toutes les pistes armées vers le haut ou vers le bas dans la
pile.
@cindex Supprimer les pistes
@cindex Pistes, supprimer
@item @b{Supprimer les pistes} supprime les pistes armées.
@item @b{Supprimer la dernière piste} efface la dernière piste, qu'elle soit
armée ou non.
Maintenir la touche @b{d} permet d'effacer rapidement toutes les pistes.
@cindex Concaténer les pistes
@cindex Pistes, concaténer
@item @b{Concaténer les pistes} est plus compliqué.  Il prend chaque piste
@b{jouable} et la concatène à la fin de la première @b{piste armée}.  S'il y a
deux pistes armées suivie de deux pistes jouables, l'opération de concaténation
place les deux pistes jouables après les deux pistes armées.  S'il y a trois
piste jouables, deux pistes sont placées après les pistes armées et une
troisième piste est placée à la fin de la première piste armée.  Les pistes de
destination sont rebouclées jusqu'à ce que toutes les pistes soient
concaténées.
@end itemize

Enfin, vous pouvez créer de nouvelles pistes.  Les menu @b{Audio} et @b{Vidéo}
comportent chacun une option permettant d'ajouter une piste de leur type
spécifique.  Dans le cas de l'audio, la nouvelle piste est placée en bas de la
timeline et le canal de sortie de la piste audio est incrémenté de un.  Dans le
cas de la vidéo, la nouvelle piste est placée en haut de la timeline.  De cette
manière, la vidéo se trouve dans un ordre naturel de composition.  Les
nouvelles pistes vidéo sont surchargées au-dessus des anciennes pistes.

@c cincvdoc_node_number_102
@node Le montage à deux écrans
@subsection Le montage à deux écrans
@cindex Le montage à deux écrans

C'est la manière la plus rapide de réaliser un montage à partir de fichiers de
films.  L'idée consiste à visualiser le fichier de film dans une fenêtre et de
visualiser le programme dans une autre fenêtre.  Des parties du film sont
définies dans la fenêtre de la visionneuse et transférées à la fin du programme dans
la fenêtre de programme.

La manière de commencer une session de montage à deux écrans est de charger des
ressources.  Depuis @b{fichier->Charger des fichiers}, chargez des vidéos avec
la stratégie d'insertion @b{Créer de nouvelles ressources uniquement}.  De cette manière,
la timeline demeure inchangée alors que les nouvelles ressources sont créées.
Allez dans la fenêtre des ressources et choisissez le dossier @b{Media}.  Les
ressources qui viennent d'être chargées devraient s'y trouver.  Double-cliquez sur une
ressource ou bien glissez-la de la partie média de la fenêtre vers la fenêtre de la visionneuse.

Il doit y avoir suffisamment de pistes armées sur la timeline pour pouvoir y
placer les coupes désirées du matériau source (généralement une piste vidéo et deux pistes audio).  Si ce n'est pas le cas, créez
de nouvelles pistes et armez-les.

Dans la visionneuse, définissez un clip depuis votre @w{film :}

@itemize @bullet
@item Définissez le point de début avec le
@image{manual_images_intl/in_point_button,5mm} @b{bouton de point d'entrée}.
@item Déplacez-vous à la fin du clip que vous désirez utiliser.
@item Définissez le point de fin avec le
@image{manual_images_intl/out_point_button,5mm} @b{bouton de point de sortie}
@end itemize

Les deux points devraient apparaître sur la barre temporelle et définir un
clip.@*
Vous pouvez alors faire plusieurs choses avec ce @w{clip :}

@itemize @bullet
@item @b{Insérer}@*
@image{manual_images_intl/splice_button,5mm} Insère le clip sur la timeline après le point d'insertion.@*
Après que l'insertion ait été faite, le point d'insertion
se déplace à la fin du clip, prêt à être utilisé pour réaliser l'insertion
suivante.  De cette manière, vous pouvez construire votre programme de manière
continue juste en insérant des clips.@*
Si un @b{point d'entrée} existe sur la timeline, le clip sera inséré après le
point d'entrée ou après le point de sortie.@*
Si à la fois un point d'entrée et un point de sortie sont définis sur la
timeline, le clip est inséré après le point d'entrée.@*
S'il y a un contenu après l'endroit que vous avez choisi pour réaliser
l'insertion, alors ce contenu sera poussé vers la droite.
@item @b{Remplacer}@*
@image{manual_images_intl/overwrite_button,5mm} Permet de remplacer la région de
la timeline située après le point d'insertion par un clip.@*
S'il existe un @b{point d'entrée} ou un @b{point de sortie} sur la timeline, le
remplacement à lieu après le point d'entrée ou après le point de sortie.@*
S'il existe à la fois un @b{point d'entrée} ou un @b{point de
sortie} sur la timeline, le remplacement à lieu après le point d'entrée.@*
Si une région est en
surbrillance ou que les points d'entrée/sortie existent tous les deux, ils délimitent
la région qui sera remplacée, et donc la durée du clip peut être réduite.
Cette astuce justifie l'explication @b{suivante :}@*
@b{ASTUCE: Pour remplacer une région précise de la timeline :}@*
- Armez uniquement les pistes sur lesquelles le remplacement doit être effectué.@*
- Définissez la région à remplacer en utilisant les crochets [ et ].@*
- Définissez le clip que vous voulez utiliser dans la visionneuse avec les crochets [ and ], sans avoir à vous inquiéter du fait que le clip soit plus long que la région à rémplacer.@*
- Remplacez, de la visionneuse à la timeline.  La portion du clip qui est plus longue que la région de destination ne sera pas copiée.  Sur la timeline, les clips situés après ne vont pas bouger.
@item @b{Mettre dans le dossier des clips}@*
@image{manual_images_intl/toclip_button,5mm} Crée, dans la fenêtre des
ressources, un nouveau clip qui contient la région affectée, sans modifier la
timeline.  Chaque clip comporte un titre et une description ; ils sont
optionnels.
@item @b{Copie}@*
@xref{Le montage par copier-coller}, la copie se comportant de la même manière
que dans le montage par couper-coller.
@end itemize

Le montage à deux écrans est aussi possible en n'utilisant que des raccourcis
clavier.  Lorsque vous survolez un bouton avec la souris, une infobulle devrait
apparaître et vous indiquer quelle touche est liée à ce bouton.  Dans la
visionneuse, les touches du pavé numérique permettent de commander le
déplacement et les touches @kbd{[}, @kbd{]} et @kbd{v} permettent de placer les
points d'entrée/sortie et l'insertion.

@c cincvdoc_node_number_103
@node Le montage par glisser-déposer
@subsection Le montage par glisser-déposer
@cindex Montage par glisser-déposer

Le @b{montage par glisser-déposer} est une manière rapide et simple de
travailler avec Cinelerra en n'utilisant que la souris.  L'idée de base est de
créer de nombreux clips, et ensuite de les glisser dans l'ordre sur la timeline
en construisant un prototype du film que vous pouvez visionner dans le
compositeur.  Si, après l'avoir visionné, vous désirez réarranger vos clips,
insérer des effets, ajouter des transition ou retrancher ou ajouter du
matériel, glissez-les simplement et déposez-les sur la timeline.

@enumerate 1
@item Chargez des fichier en utilisant @b{Fichier->Charger des fichiers}.
@item Positionnez le mode d'insertion à @b{Créer de nouvelles ressources}.
Ceci chargera les fichiers dans la fenêtre des ressources.
@item Créez quelques pistes audio et vidéo sur la timeline en utilisant les
menus vidéo et audio.
@item Ouvrez le dossier @b{Media} dans la fenêtre des ressources.
@item Assurez-vous que les pistes nécessaires sont armées et glissez un fichier
de média depuis la fenêtre des ressources sur la timeline.  Si le média
comporte de la vidéo, glissez-le sur une piste vidéo.  Si le média est de
l'audio pure, glissez-le sur une piste audio.

@center @image{manual_images_intl/drag_to_program,70mm}

@end enumerate
Cinelerra remplit les pistes audio et vidéo qui se trouvent sous le curseur
avec les données du fichier.  Ceci affecte les pistes que vous venez de créer
initialement et les pistes vers lesquelles vous glissez le média.  Si le média
comporte une piste vidéo et deux pistes audio, vous devrez créer une piste
vidéo et deux pistes audio sur la timeline et le média devra être glissé vers
la première piste vidéo.  Si le média ne comporte que de l'audio, vous aurez
besoin d'une piste audio sur la timeline pour chacune des pistes audio du média
et le média devra être glissé sur la première piste audio.

Lorsque vous glissez votre média choisi, le pointeur de la souris va glisser
l'image réduite du média, et une fois sur la timeline, les bords d'un rectangle
de la taille de l'édition que vous allez réaliser.@*

Glissez le média à la position désirée sur une piste vide et déposez-le.@*
S'il y a d'autres éditions sur la piste, quand vous déplacez le rectangle sur
une édition, vous allez voir des flèches apparaître aux frontières de
l'édition. Si vous déposez le média à cet endroit, la nouvelle édition va
débuter à l'endroit indiqué par les flèches.

Puisque le pointeur de la souris se trouve au milieu du rectangle, lorsque ce
rectangle est plus grand que la partie visible de la timeline, il n'est pas
évident d'indiquer la position où l'insertion doit être faite.  Ceci arrive
fréquemment pour les longs médias.  Augmenter la durée visible surla timeline
va réduire la taille du rectangle, et faciliter l'insertion au bon endroit.

Lors du glisser, le média se colle au début de la piste si elle est vide.  S'il
y a déjà des plans sur la piste, le média se colle à la limite de plan la plus
proche.

Vous pouvez aussi glisser plusieurs fichiers depuis la fenêtre des ressources.
Soit en dessinant une boîte autour des fichiers, soit en utilisant @key{MAJ},
soit en utilisant @key{CTRL} lors de la sélection des fichiers.  Lorsque vous
déposez les fichiers sur la timeline, ils sont concaténés.  Le comportement de
la touche @key{MAJ} ou de la touche @key{CTRL} change selon que les ressources
sont affichées sous forme de listes ou de vignettes.

Pour afficher les ressources sous forme de vignettes ou sous forme de liste,
faites un clic droit dans la liste des médias.  Choisissez soit @b{Afficher
sous forme de vignettes}, soit @b{Afficher sous forme de liste} pour modifier
le format de l'affichage.

Lors de l'affichage sous forme de liste dans la fenêtre des ressources,
@b{MAJ-clic} permet d'étendre le nombre de sélections en surbrillance,
@b{CTRL-clic} sur les fichiers de média en mode liste ajoute des fichiers un
par un.

Lors de l'affichage des icônes dans la fenêtre des ressources, @b{MAJ-clic} ou
@b{CTRL-clic} permet de sélectionner les fichiers de média un par un.

En plus de la possibilité de glisser des fichiers de média, si vous créez des
clips et ouvrez le dossier des @b{clips}, vous pouvez glisser des clips sur la
timeline.

Il y a sur la timeline d'autres fonctionnalités de glisser.  Glisser des plans
le long de la timeline vous permet de trier vos listes de lecture de musique,
de trier des séquences de film, et permet de meilleures démonstrations au NAB
mais guère plus.  Pour activer la fonction de glisser-déposer de la timeline,
choisissez le bouton avec la flèche @image{manual_images_intl/arrow,2.67mm}.
Déplacez-vous sur un plan et glissez-le.  Lors de l'opération de glisser, le
plan va être attiré à la limite la plus proche.

@center Sélectionnez une pistes avec diverses scènes.

@center @image{manual_images_intl/drop_before}

@center Piste d'origine avec trois scènes.

@center Allez à la scène n°3, cliquez et glissez-la vers le milieu.

@center @image{manual_images_intl/drag_track}

@center Lorsque vous déposez la scène n°3

@center @image{manual_images_intl/drop_concept}

@center la scène n°2 se décale vers la droite

@center @image{manual_images_intl/drop_after}

@center Et voici à quoi ressemble la séquence terminée.

S'il y a plus d'une piste armée, Cinelerra va glisser tous les plans qui
commencent à la même position que le plan où se trouve actuellement le curseur.
En d'autres termes, vous pouvez glisser et déposer un groupe de plans.
Cinelerra reconnaît comme groupe les plans de différentes pistes armées qui ont
leur point de départ aligné, et ce indépendemment du fait qu'ils appartiennent à la même source
ou qu'ils aient leur fin alignée.

Quand vous glissez et déposez des média sur la timeline:@*
Si vous déposez un média lorsque les flèches >< sont affichées, le clip sera
coupé et collé au début de la région délimitée par le centre des flèches ><.
Les éditions suivantes vont se déplacer.@*
Si vous déposez un média lorsque les flèches >< ne sont pas affichées,
l'affichage du clip d'origine sera désactivé, et il sera copié où vous l'avez
déposé.  Les éditions suivantes ne seront pas déplacées.  Un silence va
apparaître à la place du média d'origine.

Dans le mode d'édition par glisser-déposer, vous ne pouvez pas glisser et
déposer des marques.  Elles seront verrouillées à la barre temporelle, même
quand l'option "Editer les marques" est activée.  Cependant, avec l'option
"Editer les marques" activée, si une partie sélectionnée d'une ressource est
copiée de la visionneuse vers la timeline sur une position située avant des
marques, ces marques seront poussées vers la droite pour la durée de la partie
sélectionnée.

Avec les points d'entrée/sortie vous pouvez réaliser des opérations de
couper/coller dans le mode glisser-déposer tout comme dasn le mode
copier-coller.  Allez dans le menu Edition pour voir la liste des raccourcis.

@c cincvdoc_node_number_104
@node Le montage par copier-coller
@subsection Le montage par copier-coller
@cindex Montage par copier-coller

C'est la méthode traditionnelle pour effectuer le montage avec les outils de
montage audio.  Dans le cas de Cinelerra, vous devrez soit lancer une seconde
instance de Cinelerra et copier d'une instance vers l'autre, soit copier entre
pistes différentes de la même instance, soit charger un fichier de média dans
la visionneuse et effectuer la copie depuis cet endroit.

Chargez un certain nombre de fichiers sur la timeline.  Pour effectuer un
montage par couper-coller, sélectionnez le
@image{manual_images_intl/ibeam,1.67mm} bouton i-beam.  Sélectionnez une région
de la timeline au moyen d'un cliquer-glisser et utilisez le @image{manual_images_intl/cut,5.67mm} bouton couper
pour la couper.  Déplacez le point d'insertion à un autre endroit de la
timeline et sélectionnez le @image{manual_images_intl/paste,5mm} bouton coller.
En supposant que les points d'entrée/sortie sont définis sur la timeline, ceci
réalise une opération de couper-coller.

Si les points d'entrée/sortie sont définis, le point d'insertion et la région
en surbrillance seront écrasés par les points d'entrée/sortie lors des
opérations de presse-papiers.  De cette manière, avec les points
d'entrée/sortie, vous pouvez effectuer du couper-coller en mode glisser-déposer
comme en mode couper-coller.

Il y a d'autres opérations que vous pouvez réaliser.  Allez dans le menu Editer
pour en voir la liste ainsi que les raccourcis clavier qui y sont associés.

Dans le mode Couper-coller vous pouvez aussi éditer les marques.  En activant
@b{Editer les marquer} dans le menu Configuration, ou en désactivant le bouton
@b{Empêcher les marques de se déplacer}, les marques peuvent être coupées,
copiées ou collées en même temps que les sélections des pistes armées.

Lorsque l'on monte de l'audio, il est habituel de couper depuis une partie de
la forme d'onde vers la même partie d'une autre forme d'onde.  Le point de
départ et le point de fin de la coupe sont identiques sur chacune des formes
d'onde et peuvent être légèrement décalés, car les données de l'onde sont
différentes.  Il serait très difficile de mettre en surbrillance la forme
d'onde à couper et de mettre en surbrillance la seconde forme d'onde à coller
sans modifier les positions relatives de début et de fin.

Une possibilité pour simplifier ces opérations est de lancer une seconde
instance de Cinelerra, de couper et coller pour déplacer le média entre les
deux instances.  De cette manière, les deux régions en surbrillance peuvent
exister simultanément.

Une autre possibilité est de placer les points d'entrée/sortie correspondant à
la région source de la forme d'onde source et de placer des marques sur la
région de destination de l'onde de destination.  Effectuez une opération de
couper, supprimez les points d'entrée/sortie, sélectionnez la région entre les
marques et effectuez le coller.

Une dernière opération de montage par couper-coller est l'opération
@b{Editer->Réinitialiser}.  Si une région est en surbrillance ou si les points
d'entrée/sortie existent, la région affectée est réinitialisée par
@b{Editer->Réinitialiser}.  Mais si le point d'insertion est sur une limite de
plan et que les plans situés de chaque côté de cette limite de plan
appartiennent à la même ressource, les plans seront alors combinés en un seul
plan compris dans la ressource.  Le début de ce plan unique est le début du
premier plan et la fin de plan, la fin du deuxième.  Ceci peut soit étendre,
soit réduire le plan.

@c cincvdoc_node_number_105
@node Ajustement
@subsection Ajustement
@cindex Ajustement

Avec un certain nombre de plans sur la timeline, il est possible de faire de
l'ajustement.  Lors de l'ajustement, vous réduisez ou agrandissez les limites
des plans en les glissant.  Il est possible de faire de l'ajustement à la fois
dans le mode glisser-déposer et dans le mode couper-coller.  Déplacez le
curseur sur la limite d'un plan jusqu'à ce qu'il change de forme.  Le curseur
prendra la forme d'une flèche soit d'agrandissement vers la droite, soit
d'agrandissement vers la gauche.  Si le curseur se présente sous la forme d'une
flèche d'agrandissement vers la gauche, l'opération de glisser affectera le
début du plan.  Si la flèche est orientée vers la droite, l'opération de
glisser affectera la fin du plan.

Lorsque vous cliquez sur la limite d'un plan afin de débuter le glisser, le
bouton de la souris utilisé détermine le comportement du glisser qui suivra.
Il y a trois comportements possibles associés aux boutons de la souris définis
dans les préférences de l'interface utilisateur.  @xref{Interface}.

L'effet de chaque opération de glisser ne dépend pas seulement du comportement
des boutons mais aussi quelle est la limite - fin ou début - du plan qui est
glissée.  Lorsque vous relâchez le bouton de la souris, l'opération
d'ajustement est effectuée.

Dans une opération de @b{Glisser tous les plans qui suivent}, le début du plan
pourra soit supprimer des données du plan si vous le déplacez vers l'avant,
soit coller de nouvelles données depuis ce qui précède le plan si vous le
déplacez en arrière.  La fin du plan collera des données dans le plan si vous
le déplacez vers l'avant, ou coupera des données depuis la fin du plan si vous
le déplacez vers l'arrière.  Tous les plans qui suivent seront décalés.  Enfin,
si vous glissez la fin du plan avant le début du plan, le plan sera supprimé.

Dans une opération de @b{Ne glisser qu'un seul plan}, le comportement est le
même si vous glissez le début ou la fin du plan.  La seule différence est
qu'aucun des autres plans ne sera décalé.  A la place, tout ce qui est adjacent
au plan actuel sera agrandi ou réduit pour remplir les vides laissés par
l'opération d'ajustement.

Dans une opération de @b{Ne glisser que la source}, rien n'est coupé ni collé.
Si vous déplacez le début ou la fin du plan vers l'avant, la source de
référence dans le plan sera déplacée vers l'avant.  Si vous déplacez le début
ou la fin du plan vers l'arrière, la source de référence sera déplacée en
arrière.  Les plans restent au même endroit sur la timeline
mais la source se décale.

Pour tous les formats de fichiers autres que les images fixes, l'étendue de
l'opération d'ajustement est tronquée à la taille du fichier source.  Une
tentative de glisser le début du plan avant le début de la source le limitera
au début du fichier source.

Dans toutes les opérations d'ajustement, tous les plans qui commencent à la
même position que le curseur lorsque l'opération de glisser commence, sont
affectés.  Désarmez les pistes dont vous voulez éviter que les plans ne soient
affectés.

@c cincvdoc_node_number_106
@node La fenêtre de composition
@chapter La fenêtre de composition
@cindex Fenêtre de composition

Cette fenêtre affiche la sortie de la timeline.  C'est l'interface de la
plupart des opérations de composition ou des opérations qui affectent l'aspect
de la sortie de la timeline.  Les opérations effectuées dans le Compositeur
affectent la timeline mais n'affectent pas les clips.

@menu
* Les commandes du compositeur::
* La composition::
@end menu

@c cincvdoc_node_number_107
@node Les commandes du compositeur
@section Les commandes du compositeur
@cindex Commandes du compositeur

La sortie vidéo possède plusieurs fonctions de navigation.  La taille de la
sortie vidéo est soit verrouillée à la taille de la fenêtre ou libérée à l'aide
des barres de défilement pour la navigation.  On peut effectuer des zooms et
des panoramiques dans la sortie vidéo.  Naviguer dans la sortie vidéo de cette
manière n'affecte pas la sortie rendue, cela ne modifie que la vue dans la
fenêtre du compositeur.

Si le point de vue n'est pas verrouillé à la taille de la fenêtre, un clic avec
le bouton central et un glisser n'importe où dans la vidéo permettent
d'effectuer un panoramique.

Presser les touches @kbd{+} et @kbd{-} permet de zoomer ou de dézoomer la
sortie vidéo.

Une copie de la plupart des fonctions disponibles dans la fenêtre principale se
trouve sous l'affichage vidéo.  Il y a, de plus, un
@image{manual_images_intl/cwindow_zoom,30mm} menu de zoom et une
@image{manual_images_intl/cwindow_light,8mm} lampe-témoin.

Le menu de zoom permet d'obtenir tous les facteurs d'agrandissement disponibles et,
à l'aide de l'option @b{Auto}, d'adapter la taille de la vidéo à la taille de la
fenêtre.  Le menu de zoom n'affecte pas la taille de la fenêtre.

La lampe témoin s'allume en rouge lorsqu'une opération de rendu est en cours.
C'est utile pour savoir si la vidéo affichée est à jour.

Un clic droit n'importe où dans la vidéo affiche un menu avec les facteurs de
zoom et d'autres options.  Dans ce cas particulier, les facteurs de zoom
redimensionnent l'ensemble de la fenêtre et non pas la vidéo uniquement.

Les options @b{Réinitialiser la caméra} et @b{Réinitialiser le projecteur}
recentrent la caméra et le projecteur.  @xref{La composition}.

@cindex Cacher les commandes
@cindex Commandes, cacher
L'option @b{Cacher les commandes} cache tout sauf la vidéo.

Sur la gauche de la sortie vidéo se trouve une barre d'outils spécifique à la
fenêtre du compositeur.  Voici les fonctions de cette barre d'outils :

@menu
* Protéger la vidéo::
* La loupe::
* L'outil de masque::
* La caméra::
* Le projecteur::
* L'outil de découpage::
* La pipette à couleurs::
* Informations sur l'outil::
* L'outil zones sûres::
@end menu

@c cincvdoc_node_number_108
@node Protéger la vidéo
@subsection Protéger la vidéo
@cindex Protéger la vidéo

Ceci permet de désactiver les modifications dans le sortie du compositeur lors
des clics dans cette fenêtre.  C'est un calque supplémentaire au-dessus du
bouton d'armement des pistes servant à éviter les modifications non désirées.

@c cincvdoc_node_number_109
@node La loupe
@subsection La loupe
@cindex La loupe

Cet outil @image{manual_images_intl/magnify,7mm} permet des zooms dans la sortie
du compositeur sans avoir à redimensionner la fenêtre.  Si la sortie vidéo est
à ce moment-là liée à la taille de la fenêtre, un clic avec la loupe la
déverrouillera et créera les barres de défilement pour la navigation.

Un clic gauche permet de zoomer la vidéo.@*
Ctrl-clic gauche permet de dézoomer la vidéo.@*
Les opérations de zoom peuvent aussi se faire à l'aide de la molette de la
souris.

@c cincvdoc_node_number_110
@node L'outil de masque
@subsection L'outil de masque
@cindex L'oOutil de masque

Ce bouton @image{manual_images_intl/mask} permet d'activer l'outil de montage
masque.  @xref{Les masques}.  Activez la fenêtre d'informations pour afficher
les options de cet outil.

@c cincvdoc_node_number_111
@node La caméra
@subsection La caméra
@cindex La caméra

Ce bouton @image{manual_images_intl/camera,4.67mm} permet d'activer l'outil de
montage caméra.  @xref{La caméra et le projecteur}.  Activer la fenêtre
d'information pour afficher les options de cet outil.

@c cincvdoc_node_number_112
@node Le projecteur
@subsection Le projecteur
@cindex Le projecteur

Ce bouton @image{manual_images_intl/projector,4.67mm} permet d'activer l'outil de
montage projecteur @xref{La caméra et le projecteur}.  Activer la fenêtre
d'informations @image{manual_images_intl/toolwindow,2.67mm} pour afficher les
options de cet outil.

@c cincvdoc_node_number_113
@node L'outil de découpage
@subsection L'outil de découpage
@cindex L'outil de découpage

Ce bouton @image{manual_images_intl/crop,4.33mm} permet d'activer l'outil de
découpage.  @xref{Recadrage}.  La fenêtre d'information sur l'outil
@image{manual_images_intl/toolwindow,2.67mm} doit être activée pour pouvoir
utiliser cet outil.

@c cincvdoc_node_number_114
@node La pipette à couleurs
@subsection La pipette à couleurs
@cindex La pipette à couleurs

Ceci permet d'activer la pipette.  La pipette détecte la couleur sur laquelle
elle se trouve et l'enregistre dans une zone temporaire.  En activant la
fenêtre d'information @image{manual_images_intl/toolwindow,2.67mm}, la couleur
actuellement sélectionnée est affichée.  Cliquez n'importe où dans la fenêtre
de l'affichage vidéo pour sélectionner la couleur se trouvant à cet endroit.@*
La pipette ne vous permet pas uniquement de voir les couleurs qui ont été
capturées : sa valeur peut aussi être appliquée à de nombreux effets.  La
manière d'utiliser la pipette varie selon les effets.

@c cincvdoc_node_number_115
@node Informations sur l'outil
@subsection Informations sur l'outil
@cindex Informations sur l'outil

Cet bouton @image{manual_images_intl/toolwindow,2.67mm} ne fonctionne qu'en
conjonction avec l'une des autres commandes du compositeur.  En se basant sur
la commande active dans le compositeur, ce bouton va activer/désactiver la
boîte de dialogue correspondant à la commande.

Les commandes ayant des boîtes de dialogue sont :
@itemize @bullet
@item Editer le masque
@item La caméra
@item Le projecteur
@item Commande de découpage
@end itemize

@c cincvdoc_node_number_116
@node L'outil zones sûres
@subsection L'outil zones sûres
@cindex Outil zones sûres
@cindex Zones sûres, outil

Ce bouton @image{manual_images_intl/titlesafe} affiche les zones sûres de la
sortie vidéo.  Ceci n'affecte pas la sortie rendue.  @xref{Les zones sûres}.

@c cincvdoc_node_number_117
@node La composition
@section La composition
@cindex La composition

Une grande partie de la taille du binaire de Cinelerra est directement liée à
la composition.  Lorsque vous changez le format d'une vidéo en la passant du
4/3 au 16/9, vous faites de la composition.  La modification de la résolution
dans un affichage, la division d'écran, les fondus entrant et sortant, parmi
d'autres choses, sont toutes des opérations de composition dans Cinelerra.
Cinelerra détecte lorsqu'il est dans une opération de composition et n'effectue
la visualisation via le moteur de composition que dans ce cas.  Sinon, il
utilise le décodeur le plus rapide disponible avec le matériel.

Les opérations de composition sont effectuées sur la timeline et dans la
fenêtre de composition.  Il existe des raccourcis dans la fenêtre des
ressources pour modifier certains attributs de composition.  Une fois qu'un
certain nombre de fichiers vidéo se trouvent sur la timeline, la fenêtre du
compositeur est le bon endroit pour s'essayer à la composition.

@menu
* La caméra et le projecteur::
* Les masques::
* Recadrage::
* Les zones sûres::
* Les modes de calque::
* Les dimensions de la piste et de la sortie::
@end menu

@c cincvdoc_node_number_118
@node La caméra et le projecteur
@subsection La caméra et le projecteur
@cindex Caméra
@cindex Projecteur

@menu
* Le temporaire::
* Les commandes du projecteur de composition::
* Les commandes de la caméra de composition::
* Le menu déroulant des options::
* La fenêtre d'outil de la caméra et du projecteur::
@end menu

@c cincvdoc_node_number_119
@node Le temporaire
@subsubsection Le temporaire
@cindex Le temporaire

Dans la fenêtre du compositeur, les fonctions les plus importantes sont le
@image{manual_images_intl/camera,4.67mm} bouton de la caméra et le
@image{manual_images_intl/projector,4.67mm} bouton du projecteur.  Ils permettent
de commander les opérations de la caméra et du projecteur.  La routine
de composition de Cinelerra utilise un "temporaire", une image de la vidéo dans
l'espace mémoire de Cinelerra où tous les traitements graphiques sont
effectués.  A l'intérieur du pipeline de composition de Cinelerra, la caméra détermine d'où, dans la source
vidéo, le "temporaire" est copié.  Le projecteur détermine vers quel emplacement
de la sortie le "temporaire" est copié.

@center @image{manual_images_fr/temporary_explained,140mm}

Le processus ressemble beaucoup à la numérisation image par image d'une
bobine de film, suivie (en utilisant Gimp par exemple) d'une modification
numérique à l'aide de divers filtres.  Une fois l'image transformée par
les filtres (correction des couleurs par exemple), nous pouvons projeter
l'image terminée sur une nouvelle bobine de film, en créant ainsi une nouvelle
version "modifiée" de l'original.

Chaque piste possède un "temporaire" différent qui est défini par les dimensions
de la piste.  En redimensionnant les pistes vous pouvez créer des effets
multi-écran, des panoramiques et des zooms.

@center @image{manual_images_fr/compositing_pipeline,140mm}
@center @b{Représentation visuelle du pipeline de composition}

Lors du montage à l'aide de la caméra et du projecteur dans la fenêtre de
composition, la première piste ayant la fonction d'@b{enregistrement} active
est la piste affectée.  Même si la piste est entièrement transparente, c'est
tout de même la piste affectée.  S'il existe plusieurs pistes vidéo, la manière
la plus simple pour sélectionner une piste pour le montage est de faire
@b{MAJ-clic} sur l'icône d'enregistrement de la piste.  Ceci permet d'isoler
cette piste.

@center @image{manual_images_fr/projector_concept,120mm}

Le but du projecteur est de placer le contenu du temporaire dans la sortie du
projet.  Il doit mixer plusieurs sources depuis différentes pistes vers une
seule piste finale de sortie.

La trame d'alignement du projecteur est identique au visuel de la caméra, sauf
qu'il indique dans quelle partie de la sortie vidéo mettre le contenu de chaque
temporaire.

@center @image{manual_images_intl/projector_screen}

@c cincvdoc_node_number_120
@node Les commandes du projecteur de composition
@subsubsection Les commandes du projecteur de composition
@cindex Les commandes du projecteur de composition

Lorsque le bouton du @b{projecteur} est actif dans la fenêtre du compositeur,
vous êtes dans le @b{mode de montage du projecteur}.  Une boîte-guide apparaît
dans la fenêtre vidéo.  Un glisser n'importe où dans la fenêtre vidéo permet de
déplacer cette boîte-guide, ce déplacement s'effectuant avec la vidéo qu'elle
contient.  Vous pouvez redimensionner la boîte-guide avec la vidéo qu'elle
contient par l'utilisation de @b{MAJ-glisser} n'importe où dans la fenêtre
vidéo.  Une fois que vous avez placé la vidéo avec le projecteur, vous êtes
prêt à maîtriser la caméra.

@c cincvdoc_node_number_121
@node Les commandes de la caméra de composition
@subsubsection Les commandes de la caméra de composition
@cindex Les commandes de la caméra de composition

Sélectionnez le @image{manual_images_intl/camera,4.67mm} bouton de la caméra pour
activer le mode de montage de la caméra.  Dans ce mode, la boîte-guide montre
la position de la caméra en relation avec ses positions passées et futures et
non sa position en relation avec la source vidéo.  Un glisser de la boîte de la
caméra dans la fenêtre de composition ne déplace pas la boîte mais la position
de la vidéo à l'intérieur de la boîte.

@cindex Visuel
Le @b{visuel} est une fenêtre de la caméra qui encadre la zone de la source
vidéo à balayer.  Le visuel est représenté par un cadre rouge avec des
diagonales.

@center @image{manual_images_fr/camera_concept,100mm}
@center @b{Le visuel}

@center @image{manual_images_fr/viewport_sizes,150mm}
@center @b{Les dimensions du visuel}

Les dimensions du visuel sont définies par les dimensions de la piste en cours.
Un visuel plus petit (640x400) ne permet de faire l'acquisition que d'une
petite zone.  Un visuel plus grand (800x200) permet de faire l'acquisition
d'une zone plus grande que la source vidéo, les zones vides étant remplies par
du blanc.

Une fois que nous avons défini notre visuel, il nous faut encore placer la
caméra juste au-dessus de la zone de la source vidéo qui nous intéresse.  Pour
diriger la position de la caméra :
@enumerate 1
@item Ouvrez la fenêtre du compositeur avec une piste sélectionnée.
@item Sélectionnez le bouton de la caméra pour activer le mode de montage de la
caméra.
@item Utilisez un glisser sur la fenêtre d'affichage.
@end enumerate

Lorsque nous effectuons un glisser sur le visuel dans la fenêtre du compositeur
(bien que ce soit anti-intuitif au départ), le visuel ne se déplace pas mais la
zone de la vidéo qui se trouve sous l'emplacement de la caméra le fait, comme
si nous regardions sur un moniteur l'image produite par une caméra en mouvement.

@center @image{manual_images_intl/viewport_drag,100mm}
@center @b{Dans la fenêtre du compositeur, le visuel est toujours affiché}
@center @b{centré, ce qui se déplace est la vidéo qui se trouve en dessous}

Par exemple, si vous glissez la caméra vers le bas, le visuel se déplace
effectivement vers le bas sur la vidéo, mais de notre point de vue, sur l'écran
du compositeur, nous voyons la vidéo se déplacer vers le haut.  Lorsque vous
déplacez la caméra vers la droite, la vidéo semble se déplacer vers la gauche
et ainsi de suite.

@b{Note :} la boîte-guide s'affiche lorsque la position de la caméra est en
relation avec les positons passées et futures de la caméra, et non lorsqu'elle
est en relation avec la source vidéo.

@c cincvdoc_node_number_122
@node Le menu déroulant des options
@subsubsection Le menu déroulant des options
@cindex Le menu déroulant des options

Dans la fenêtre de composition, il y a un menu déroulant d'options pour la
caméra et le projecteur.  Faites un clic droit sur la partie vidéo de la
fenêtre de composition pour afficher ce menu.

@itemize @bullet
@item @b{Réinitialiser la caméra} fait retourner la caméra à la position
centrale.
@item @b{Réinitialiser le projecteur} fait retourner le projecteur à la
position centrale.
@end itemize

@c cincvdoc_node_number_123
@node La fenêtre d'outil de la caméra et du projecteur
@subsubsection La fenêtre d'outil de la caméra et du projecteur
@cindex La fenêtre d'outil de la caméra et du projecteur

La caméra et le projecteur possédent des raccourcis claviers qui n'apparaissent
pas dans le menu déroulant, et ne sont pas représentés sur la vidéo.
Ils sont accessibles depuis la @b{fenêtre des options de
l'outil}.  La plupart des opérations dans la fenêtre de composition ont une
fenêtre d'options qui est activée à l'aide du
@image{manual_images_intl/toolwindow,2.67mm} bouton point d'interrogation.

@center @image{manual_images_intl/compositor_campro_tool,40mm}
@center @b{La fenêtre d'outil de la caméra et du projecteur}

Dans le cas de la caméra et du projecteur, la fenêtre des options de l'outil
affiche les coordonnées x, y et z.  Les positions de la caméra et du projecteur
peuvent être placés très précisément soit à l'aide des curseurs, soit en
entrant directement les coordonnées.  Il existe 9 types de justification
prédéfinis pour un accès rapide.  Une justification habituelle est une
projection en haut et à gauche après avoir réduit l'image.  Ceci est utilisé
lorsqu'on réduit la taille de la vidéo avec un ajustement du rapport d'aspect.

@itemize @bullet
@item @image{manual_images_intl/button_justify_left} Gauche
@item @image{manual_images_intl/button_justify_centerH} Centré horizontalement
@item @image{manual_images_intl/button_justify_right} Droite
@item @image{manual_images_intl/button_justify_top} Haut
@item @image{manual_images_intl/button_justify_centerV} Centré verticalement
@item @image{manual_images_intl/button_justify_bottom} Bas
@end itemize

L'effet de translation permet d'effectuer simultanément une conversion de
rapport d'aspect et une réduction mais il est plus facile à utiliser si la
vidéo réduite est placée en haut et à gauche du temporaire plutôt qu'au milieu.
La taille de la piste est fixée à la taille originale de la vidéo et la caméra
est centrée.  La taille de la sortie est identique à la taille de la vidéo
réduite.  Sans aucun effet, ceci permet d'obtenir en sortie juste la partie
centrale recadrée de la vidéo.

L'effet de translation est déposé sur la piste vidéo.  Les dimensions en entrée
de l'effet de translation sont définies d'après la taille d'origine et les
dimensions de sortie à la taille réduite.  Pour placer la vidéo réduite au
centre de la section que le projecteur affiche, il faut décaler les @b{valeurs
de sortie de x et de y} par un calcul compliqué.  A la place, nous laissons les
@b{valeurs de sortie de x et de y} à 0 et nous utilisons la fenêtre d'options
de l'outil du projecteur.

En choisissant simplement @image{manual_images_intl/left_justify} la
justification à gauche et @image{manual_images_intl/top_justify} la justification
en haut, le projecteur affichera une image réduite du coin supérieur gauche du
temporaire au centre de la sortie.

@c cincvdoc_node_number_124
@node Les masques
@subsection Les masques
@cindex Les masques

Les masques permettent de sélectionner une région de la vidéo soit pour
l'afficher, soit pour la cacher.  Les masques peuvent aussi être utilisés en
conjonction avec un autre effet pour le restreindre à une certaine région de
l'image.  Une copie d'une piste vidéo peut être légèrement retardée et non
masquée dans les zones où se trouvent des objets indésirables sur l'une des
copies mais pas sur l'autre copie.  Une correction des couleurs peut être
nécessaire en une partie de l'image, mais pas dans une autre.  La suppression
des perches de microphones, d'avions ou de vos femmes sont d'autres
utilisations des masques.

L'ordre du pipeline de composition affecte ce qui peut être fait avec les
masques.  Principalement, les masques sont exécutés sur le temporaire après les
effets et avant le projecteur.  Ceci signifie que plusieurs pistes peuvent être
renvoyées vers une piste masquée et projetées avec le même masque.

Notre pipeline de composition comporte maintenant une étape de masquage.  Il y
a 8 masques possibles par piste.  Chaque masque est défini séparément, bien
qu'ils puissent effectuer la même opération, qu'il s'agisse d'addition ou de
soustraction.

@center @image{manual_images_fr/compositing_pipeline2,140mm}
@center @b{Pipeline de composition avec masques}

Pour définir un masque, allez à la fenêtre de composition et activez le
@image{manual_images_intl/mask} commutateur de @b{masque}.  Placez-vous
maintenant sur la vidéo et cliquez-glissez.

@b{IMPORTANT :} si vous désirez qu'un masque évolue dans le temps, vous devez
sélectionner @b{images-clés automatiques} (@xref{Les images-clés
automatiques},).  Si vous ne sélectionnez pas @b{images-clés automatiques}, la
position du masque restera la même, même si vous l'éditez en différents
emplacements de la timeline.

@center @image{manual_images_intl/compositor_mask1,60mm}

Cliquez-glissez ensuite sur une autre partie de l'image pour créer un nouveau
point du masque.  Bien que ce ne soit pas le comportement standard des courbes
de Bezier, cette interface de gestion des masques effectue en temps réel ce que
produira l'effet du masque.  La création de chacun des points du masque étend
une courbe en élastique.

Une fois les points définis, ils peuvent être déplacés par un @b{Ctrl-glisser}
à proximité d'un coin.

@center @image{manual_images_fr/compositor_mask_drag}
@center @b{CTRL-glisser vous permet de déplacer des points existants à}
@center @b{de nouveaux emplacements, en modifiant ainsi la forme du masque}

Ceci, cependant, ne lisse pas la courbe.  Les points d'entrée-sortie de la
courbe de Bezier sont accessibles par @b{MAJ-glisser} à proximité d'un coin.
@b{MAJ-glisser} près d'un point d'entrée/sortie permettra ensuite de déplacer
ce point.

@center @image{manual_images_fr/compositor_mask_bezier}
@center @b{MAJ-glisser pour activer les poignées de la courbe de Bezier}

@center @b{pour créer des courbes entre les points du masque}

Enfin, une fois que vous avez défini un masque, le masque peut être déplacé
d'un seul tenant par @b{ALT-glisser} sur le masque.  L'édition des masques dans
Cinelerra est identique à celle de Gimp sauf dans que dans ce cas, l'effet du
masque est toujours actif.

@center @image{manual_images_fr/compositor_mask_translate}
@center @b{CTRL-ALT-glisser déplace un masque entier}
@center @b{vers un nouvel emplacement de l'écran}

Les masques ont beaucoup d'autres paramètres qui ne peuvent pas être
représentés par des couches vidéo.  On les trouve dans la fenêtre des outils
pour les masques.  Choisir le @image{manual_images_intl/toolwindow,2.67mm} point
d'interrogation lorsque le @image{manual_images_intl/mask} bouton de masque est
en surbrillance permet d'afficher les options de masque.

@center @image{manual_images_intl/mask_dialog,70mm}
@center @b{Fenêtre des options de masque}

Le @b{mode} du masque détermine si le masque doit supprimer des données ou les
rendre visible.  Dans le mode soustractif, le masque fait disparaître la vidéo.
Dans le mode additif, le masque fait apparaître la vidéo, et tout ce qui se
trouve à l'extérieur du masque disparaît.

@center @image{manual_images_fr/compositor_mask_mode,160mm}
@center @b{Mode de masque}

La @b{valeur} du masque détermine l'intensité de l'addition ou de la
soustraction qui sera effectué.  Dans le mode soustractif, les valeurs les plus
élevées enlèvent davantage d'alpha.  Dans le mode additif, les valeurs les plus
élevées rendent la région du masque plus lumineuse alors que le région à
l'extérieur du masque reste toujours cachée.

@center @image{manual_images_fr/composite_mask_value}
@center @b{Valeur du masque}

Le numéro du masque détermine lequel des 8 masques possibles est en cours
d'édition.  Il y a 8 masques possibles par piste.  Lorsque vous cliquez-glissez
dans la fenêtre du compositeur, vous n'éditez qu'un seul des masques.  Changez
la valeur du @b{numéro de masque} pour en éditer un autre.  Le masque précédent
est encore actif mais seule la courbe soulignant le masque en cours est
visible.

Lorsque l'on utilise plusieurs masques, leurs effets sont affectés d'un OU.
Chaque masque d'une piste utilise la même valeur et le même mode.

@cindex Adoucir le masque
@cindex Masque, adoucir
Par défaut, les bords du masques sont nettement découpés ce qui est rarement
désiré.  Le paramètre d'@b{adoucissement} détermine de combien de pixels il
faut adoucir le masque.  Ceci crée des bords plus doux mais prend davantage de
temps lors du rendu.

@center @image{manual_images_fr/compositor_feather,120mm}
@center @b{Paramètre d'adoucissement}

Il y a enfin des paramètres qui affectent un point du masque en cours plutôt
que le masque tout entier.  Ce sont @b{Supprimer, x, y}.  Le point actif est
défini comme étant le dernier point glissé dans la fenêtre du compositeur.
Tous les points peuvent être activés simplement en faisant un @b{CTRL-clic} à
proximité sans déplacer le curseur.  Une fois qu'un point est actif,
@b{Supprimer} le supprimera et @b{x, y} permettent de le repositionner en
entrant des valeurs numériques des coordonnées.

@c cincvdoc_node_number_125
@node Recadrage
@subsection Recadrage
@cindex Recadrage

Le recadrage modifie les dimensions de l'image de sortie et le projecteur
réduit la partie visible de l'image.  Activez
@image{manual_images_intl/crop,4.33mm} l'outil de recadrage et la fenêtre des
options @image{manual_images_intl/toolwindow,2.67mm} de l'outil dans la fenêtre
de composition.

@center @image{manual_images_intl/compositor_crop_tool,60mm}
@center @b{Boîte de dialogue du contrôle de recadrage}

Cliquez n'importe où dans la vidéo pour définir la zone de recadrage.  Ceci
dessine un rectangle par dessus la vidéo.  Cliquez-glissez n'importe où dans la
vidéo pour créer un nouveau rectangle.  Cliquez-glissez sur n'importe quel coin
du rectangle pour repositionner ce coin.

@center @image{manual_images_intl/compositor_crop}
@center @b{Zone de recadrage définie}

@b{ALT-cliquer} dans le rectangle de recadrage déplace le rectangle vers
n'importe quelle position, sans le redimensionner.

La fenêtre de l'outil permet d'entrer les coordonnées sous forme de texte et
d'exécuter l'opération de recadrage.  Lorsque le rectangle est placé, cliquez
le bouton @b{Exécuter} dans la fenêtre de l'outil pour effectuer l'opération de
recadrage.

@b{Note :} Les coordonnées X1,Y1 et X2,Y2 du dialogue de contrôle du recadrage
permettent d'entrer sous forme de texte les coordonnées des coins supérieur
gauche et inférieur droit qui définissent le rectangle de recadrage.

@c cincvdoc_node_number_126
@node Les zones sûres
@subsection Les zones sûres
@cindex Les zones sûres
@cindex Régions, sûres

Sur les écrans grand public, les bords de l'image sont rognés et, à l'intérieur
de la zone redimensionnée, se trouve une zone qui n'est pas toujours
rectangulaire contrairement à ce que l'on voit dans le compositeur.  Les
bordures servent pour les signaux de suppression verticale (blanking).  Vous
pouvez afficher ces limites en actionnant le @image{manual_images_intl/titlesafe}
bouton des zones sûres.  Veillez à conserver les titres à l'intérieur du
rectangle intérieur et l'action à l'intérieur du rectangle extérieur.

@c cincvdoc_node_number_127
@node Les modes de calque
@subsection Les modes de calque
@cindex Les modes de calque

Chaque piste vidéo possède un mode de calque accessible en déployant la piste.
Le mode de calque est un menu déroulant sur la gauche et en-dessous du réglage
de niveau.  Lorsqu'il est replié, une icône représentant le mode actuel de
calque est affichée.

Sélectionnez le @image{manual_images_intl/expandpatch_checked} bouton d'expansion
pour afficher toutes les options d'une piste vidéo si le mode de calque n'est
pas affiché.  Le mode de calque des pistes vidéo est fixé à @b{normal} par
défaut.  Vous pouvez choisir un autre mode en cliquant le bouton de surcharge
et en choisissant le mode voulu depuis le menu contextuel.

Les modes de calque sont traités lors de l'étape projecteur de la composition.
Les différents modes sont résumés ci-dessous :

@cindex Mode de calque normal
@itemize @bullet
@item @b{Normal}@*
Ce mode utilise un équation traditionnelle de Porter-Diff pour effectuer la
fusion des pistes ayant un canal alpha.  Lorsque le modèle colorimétrique du
projet n'a pas de canal alpha, la nouvelle piste remplace toujours la sortie.

@cindex Mode de calque additionner
@item @b{Additionner}@*
Dans ce mode, tout ce qui se trouve sur la sortie est ajouté à la piste en
cours.  Le résultat est alors fusionné sur la sortie en se basant sur le canal
alpha de la piste en cours.

@cindex Mode de calque soustraire
@item @b{Soustraite}@*
Dans ce mode, la piste en cours est soustraite de la sortie et le résultat est
fusionnée sur la sortie en utilisant le canal alpha.

@cindex Mode de calque multiplier
@item @b{Multiplier}@*
C'est l'opération la plus utile.  La piste en cours est multipliée par la
sortie et le résultat est fusionné sur la sortie.  Habituellement, on utilise
comme piste en cours une image en noir et blanc sans canal alpha ou un titre
blanc sur une page noire.  Avec l'opération de multiplication, seules les
portions de la sortie se trouvant sous les zones blanches sont affichées.

@cindex Mode de calque diviser
@item @b{Diviser}@*
Ce mode divise la piste en cours par la sortie et le résultat est fusionné sur
la sortie.  Ceci conduit en général à une saturation des niveaux.

@cindex Mode de calque remplacer
@item @b{Remplacer}@*
Ce mode n'effectue pas de fusion mais écrase la sortie par le contenu de la
piste en cours.
@end itemize

@c cincvdoc_node_number_128
@node Les dimensions de la piste et de la sortie
@subsection Les dimensions de la piste et de la sortie
@cindex Les dimensions de la piste et de la sortie
@cindex Les dimensions de la sortie

@menu
* Les dimensions de la piste::
* Les dimensions de la sortie::
@end menu

Les dimensions du temporaire et les dimensions de la sortie dans notre pipeline
de composition sont indépendantes et variables.  Ceci est en conformité avec
tout ce qui a été dit jusqu'à présent.  Le visuel de la caméra a les mêmes
dimensions que le temporaire.  Les effets sont traités dans le temporaire et
sont affectés par les dimensions du temporaire.  Les projecteurs sont rendus
vers la sortie et sont affectés par les dimensions de sortie.  Si le temporaire
est plus petit que la sortie, le temporaire sera entouré de régions vierges sur
la sortie.  Si le temporaire est plus grand que la sortie, le temporaire sera
retaillé.

@c cincvdoc_node_number_149
@node Les dimensions de la piste
@subsubsection Les dimensions de la piste
@cindex Les dimensions de la piste

Les dimensions du temporaire sont définies comme étant les dimensions de la
piste.  Chaque piste a des dimensions différentes.  Faites un clic droit sur
une piste pour appeler son menu.  Choisissez @b{Redimensionner la piste} pour
redimensionner la piste à des dimensions arbitraires.  Vous pouvez aussi
choisir @b{Ajuster à la taille de la sortie} pour que la piste ait la même
taille que la sortie.

@center @image{manual_images_intl/resize_track,70mm}
@center @b{La fenêtre de redimensionnement de la piste}

Par exemple, l'image suivante montre à quoi ressemblent une piste vidéo et la
sortie d'un projet de mêmes dimensions lorsqu'ils sont affichés dans le
compositeur.

@center @image{manual_images_intl/compositor_output_equal,70mm}
@center @b{Sortie du projet et taille de piste vidéo}
@center @b{de mêmes dimensions (720x480)}

Si vous redimensionnez une piste, son apparence dans le compositeur changera en
conséquence.

Réduire la piste (vers 640 x 400) en conservant les dimensions de la sortie du
projet inchangées fait que la piste s'affiche plus petite dans le compositeur
et est encadrée avec une bordure vierge.

@center @image{manual_images_intl/compositor_output_small,70mm}
@center @b{Nouvelle piste (640x400), plus petite}
@center @b{que la sortie du projet (720x480)}

Agrandir la piste (vers 800 x 560) en conservant les dimensions de la sortie du
projet inchangées fait que la piste s'affiche plus grande dans le compositeur
et est retaillée aux dimensions de la sortie.

@center @image{manual_images_intl/compositor_output_large,70mm}
@center @b{Nouvelle piste (800x560), retaillée aux}
@center @b{dimensions de la sortie du projet (720x480)}

En utilisant cette relation entre les dimensions de la piste et les dimensions
de la sortie du projet, vous pouvez de façon efficace réduire ou agrandir les
dimensions d'une piste particulière par rapport à la sortie finale et donc
créer des "effets" visuels tels que des multi-écrans, des panoramiques et
des zooms dans le compositeur.

@c cincvdoc_node_number_129
@node Les dimensions de la sortie
@subsubsection Les dimensions de la sortie
@cindex Les dimensions de la sortie

Les dimensions de la sortie sont déterminées soit dans @b{Fichier->Nouveau
projet...} lors de la création d'un nouveau projet, soit dans
@b{Configuration->Format...}.  Il y a, depuis la fenêtre des ressources, une
autre manière de modifier les dimensions de la @w{sortie :} faites un clic
droit sur un objet vidéo et choisissez @b{Ajuster les dimensions du projet}
pour ajuster les dimensions du projet à celle de l'objet.  Dès que de nouvelles
pistes sont crées, leurs dimensions sont toujours adaptées à celles de la
sortie spécifiées par une de ces méthodes.

Lors du rendu, les dimensions de la sortie du projet sont celles de la piste
vidéo finale vers laquelle le pipeline temporaire effectue le rendu.

Si les dimensions de la sortie sont supérieures à celle du temporaire, alors
l'image transférée depuis le temporaire pourra tenir dans la piste de sortie.
L'espace restant dans la sortie sera laissé vierge.

@center @image{manual_images_intl/output_small}
@center @b{Les dimensions de la sortie (affichées en vert) sont plus grandes
que le temporaire}

Si les dimensions de la sortie sont plus petites que celles du temporaire,
alors certaines parties du temporaire vidéo seront recadrées.

@center @image{manual_images_intl/output_large}
@center @b{Les dimensions de la sortie sont trop petites pour le temporaire}

@c cincvdoc_node_number_130
@node La fenêtre de la visionneuse
@chapter La fenêtre de la visionneuse
@cindex La fenêtre de la visionneuse

La fenêtre de la visionneuse est l'endroit où charger et visualiser votre média
source et vos clips.  Depuis cette fenêtre, vous pouvez parcourir rapidement un
objet en utilisant les @b{commandes de curseur}, pointer sur une région de
travail particulière avec la @b{région de prévisualisation} ou utiliser les
@b{commandes de montage} pour couper et coller des segments dans le projet, ou
créer un clip afin de pouvoir l'utiliser plus tard.

@center @image{manual_images_intl/viewer,80mm}
@center @b{La fenêtre de la visionneuse}

Pour ouvrir la fenêtre de la visionneuse, utilisez @b{Fenêtre->Afficher la
visionneuse}

L'affichage est la zone de la visionneuse où vous voyez la lecture du média.
Avant de pouvoir lire un média quelconque, vous devez d'abord le charger dans
la visionneuse.

Pour charger le média dans la visionneuse :
@enumerate 1
@item Ouvrez la fenêtre du @b{gestionnaire de ressources} et sélectionnez le
dossier du @b{gestionnaire d'objets} ou du @b{gestionnaire de clips}.
@item Glissez un fichier depuis le @b{gestionnaire d'objets} ou le
@b{gestionnaire de clips} vers la visionneuse

@center @image{manual_images_intl/drag_to_viewer,101.75mm}
@end enumerate

Vous pouvez aussi charger un média dans la visionneuse par un clic droit sur un
fichier dans le @b{gestionnaire d'objets} et en sélectionnant @b{Afficher}
depuis le menu ou par un double-clic sur l'icône.

Une fois votre média chargé, vous le verrez apparaître à l'écran, pour le lire,
vous y déplacer vers l'avant ou vers l'arrière, utilisez la @b{navette de
commande} ou les @b{commandes de navigation}.

Vous pouvez modifier les dimensions du média affiché par un clic droit afin
d'afficher le menu de zoom d'affichage.  Sélectionnez un niveau de zoom de 50%,
100% ou 200% des dimensions d'origine du média.

Lors de l'affichage d'un média, la visionneuse utilise les dimensions définies
pour la sortie du projet et non le format de l'objet d'origine.  Vous pouvez
modifier la sortie du projet afin qu'elle corresponde au format de l'objet en
utilisant l'option de menu @b{Adapter la taille du projet} dans le
@b{gestionnaire d'objets}.

Depuis là, vous pouvez parcourir le média source et les clips, en sélectionnant
des régions à coller dans le projet.  Les opérations effectuées dans la
visionneuse affectent un EDL temporaire ou un clip mais pas la timeline.

@c cincvdoc_node_number_131
@node La fenêtre des ressources
@chapter La fenêtre des ressources
@cindex La fenêtre des ressources

@menu
* Naviguer dans les ressources::
@end menu

On accède aux effets, transitions, clips, et objets à cet endroit.  La plupart
des ressources sont insérées dans le projet en les glissant depuis la fenêtre
des ressources.  La gestion de l'allocation des ressources est aussi effectuée
à cet endroit.

@c cincvdoc_node_number_132
@node Naviguer dans les ressources
@section Naviguer dans les ressources
@cindex Naviguer dans les ressources

La fenêtre des ressources est divisée en deux parties.  La première partie
comporte une liste de dossiers et l'autre zone le contenu de ces dossiers.
Aller dans la liste des dossiers et cliquer sur un dossier mettra à jour la
zone du contenu avec le contenu de ce dossier.

@center @image{manual_images_intl/resources_audio_effects,60mm}
@center @b{La fenêtre des ressources}

Le dossier et son contenu peuvent être affichés sous forme d'icônes ou de liste
textuelle.

Un @b{clic droit} dans le contenu d'un dossier affichera un menu contextuel
avec les options de formatage.  Choisissez @b{Afficher sous forme de texte}
pour obtenir une liste textuelle.  Choisissez @b{Afficher sous forme d'icônes}
pour afficher les vignettes ou les icônes correspondant au dossier choisi.
Choisissez @b{Trier les entrées} pour trier alphabétiquement le contenu du
dossier.

La @b{fenêtre d'information de l'objet} affiche des informations détaillées sur
le fichier de média sélectionné.  Pour y accéder, allez dans le dossier de
gestion des objets et faites un clic droit sur l'étiquette ou sur l'icône du
fichier qui vous intéresse.  Un menu apparaît alors.  Cliquez sur l'entrée
@b{Info} de ce menu.

@center @image{manual_images_intl/asset_info,50mm}
@center @b{La fenêtre d'information sur l'objet}

@c cincvdoc_node_number_133
@node La fenêtre des vu-mètres
@chapter La fenêtre des vu-mètres
@cindex Vu-mètres, la fenêtre des

Une fenêtre supplémentaire, la @b{fenêtre des vu-mètres} peut être appelée
depuis le menu @b{Fenêtre}.  La fenêtre des @b{indicateurs de niveaux} permet
d'afficher les niveaux de sortie audio après que le mixage ait été effectué.

@center @image{manual_images_intl/sound_level_meters_window,,80mm}

@center @b{Fenêtre des niveaux sonores}

Les vu-mètres peuvent être affichés à différents emplacements.  On peut les
activer ou les désactiver depuis la visionneuse ou le compositeur à l'aide du
bouton des vu-mètres.  Ils apparaissent dans la boîte à boutons lorsque la
piste est dépliée (@xref{La boîte à boutons}.)  Ils sont affichés dans le
contrôleur d'enregistrement lors d'un enregistrement audio.

Les niveaux sonores dans la @b{fenêtre des niveaux, le compositeur et la
visionneuse} correspondent aux niveaux de la sortie finale avant qu'ils ne
soient tronqués pour entrer dans la dynamique de la carte son.  Dans le
@b{contrôleur d'enregistrement} ce sont les valeurs d'entrée issues de la carte
son.  Dans la @b{boîte à boutons}, ce sont les niveaux sonores de chacune des
pistes après que tous les effets aient été traités et avant de faire le mélange
en réduction ("down-mixing") vers la sortie.

La plupart du temps, les niveaux audio ont une échelle numérique en dB mais
dans la boîte à boutons, il n'y a pas assez de place pour cela.

Le niveau audio est codé par couleurs de façon à donner un autre moyen de
contrôler le niveau sonore.  Même sans les échelles numériques, la couleur
permet de distinguer entre plusieurs plage et la saturation.  Regardez le
codage des couleurs sur un vu-mètre avec une échelle numérique pour voir à
quelle couleur correspond tel ou tel niveau sonore.  Ensuite, il vous suffira
d'utiliser le codage des couleurs dans la boîte à boutons avec les pistes audio
dépliées pour vous assurer qu'il n'y a pas de saturation.

Soyez attentifs au fait que les niveaux sonores dans Cinelerra peuvent dépasser
0 dB@.  Ceci permet non seulement de voir qu'une piste présente une saturation
mais encore la quantité d'information qui sera perdue par cette saturation.
Une saturation de moins de 3 dB est en général acceptable.  Alors que la
saturation est traitée sous forme de nombres positifs par Cinelerra, elle est
tronquée à 0 lorsqu'elle est envoyée vers une carte son ou vers un fichier.

La plage visible des indicateurs de niveau audio est configurable depuis
@b{Configuration->Préférences...->Interface utilisateur} (@xref{Interface}.)

@c cincvdoc_node_number_134
@node Les commandes de transport
@chapter Les commandes de transport
@cindex Les commandes de transport

Les commandes de transport sont aussi utiles pour la navigation qu'elles le
sont pour la lecture, c'est pourquoi elles sont décrites dans cette section qui
concerne la navigation.  Chacune des fenêtres de visionneuse, de composition et
de programme possède un panneau de navigation.

@center @image{manual_images_fr/transport_panel,130mm}
@center @b{Le panneau de transport}.

Le panneau de transport peut être contrôlé par le clavier ou par l'interface
graphique.  Pour chacune des opérations qu'il permet d'effectuer, la position
de départ est le point d'insertion dans la fenêtre du programme et la navette
dans la fenêtre de composition.  La position de fin est soit la fin soit le
début de la timeline ou la fin ou le début de la région sélectionnée si elle
existe.

L'orientation du départ ou de la fin dépend du sens de la lecture.  Si elle se
déroule vers l'avant, la position de fin est la fin de la région sélectionnée.
En cas de la lecture en arrière, la position de fin est le début de la région
sélectionnée.

Le point d'insertion se déplace de façon à suivre la lecture de la piste.
Lorsque la lecture s'arrête, le point d'insertion reste à l'endroit où s'est
arrêtée la lecture.  Ce qui signifie que lorsque vous effectuez une lecture,
vous modifiez la position du point d'insertion.

L'interface clavier est habituellement la plus rapide et comporte différents
raccourcis.  Les touches de transport sont disposées sous la forme d'un @b{T}
renversé sur le pavé numérique.

@multitable @columnfractions .08 .17 .08 .17 .08 .17 .08 .17
@item @kbd{4}
@tab Déplacement arrière d'une image (image par image)
@tab @kbd{5}
@tab Déplacement arrière lent
@tab @kbd{6}
@tab Déplacement arrière normal (lecture arrière)
@tab @kbd{+}
@tab Déplacement arrière rapide
@item @kbd{1}
@tab Avancer d'une image (image par image)
@tab @kbd{2}
@tab Déplacement avant lent
@tab @kbd{3}
@tab Déplacement avant normal (lecture avant)
@tab @kbd{Entrée}
@tab Avance rapide
@item @kbd{0}
@tab Arrêt
@tab
@tab
@tab
@tab
@tab
@tab
@end multitable

Presser une touche quelconque du clavier deux fois permet d'entrer en mode
pause.

Lorsque l'on utilise la fonction d'avance image par image, le comportement peut
sembler étrange.  Si vous avancez d'une image, puis reculez d'une image,
l'image affichée ne change pas.  En effet la position de lecture n'est pas
l'image mais l'instant entre deux images.  L'image rendue est la zone que la
tête de lecture traverse.  Lorsque vous incrémentez le temps entre deux images
puis le décrémentez, vous rencontrez deux fois la même image et c'est donc la
même image qui est affichée.

Le comportement des commandes de déplacement change si vous maintenez la touche
@key{CTRL} enfoncée en utilisant une de ces touches.  Ceci fait que le point de
départ devient le point d'entrée si vous effectuez une lecture avant et le
point de sortie si vous faites une lecture arrière.  Lors d'une lecture avant,
le point de sortie devient le point de fin et lors d'une lecture arrière, le
point d'entrée devient le point de fin.  S'il n'y a pas de point
d'entrée/sortie indiqué, le comportement revient alors à utiliser le point
d'insertion et les limites de pistes comme points de départ et de fin.

Il est possible d'utiliser un périphérique de type Jog/Shuttle@footnote{voir le
message posté par David Arendt sur la liste de diffusion de Cinelerra CV le
11/11/2003 pour plus d'informations}

@c cincvdoc_node_number_135
@node La barre temporelle
@chapter La barre temporelle
@cindex La barre temporelle

Les fonctions de navigation dans la visionneuse et le compositeur se comportent
de manière très semblables.  Chacune comporte une barre temporelle avec un
curseur sous la sortie vidéo.  La barre temporelle et le curseur sont
fondamentaux pour la navigation.

@center @image{manual_images_fr/timebarslider,160mm}

@cindex Zone de prévisualisation
La barre temporelle représente l'ensemble de la plage de temps couverte par le
programme.  Lorsque vous définissez des marques et des points d'entrée/sortie,
elle les indique aussi.  Enfin on trouve sur la barre temporelle une région
appelée @b{zone de prévisualisation}.

La @b{zone de prévisualisation} est la partie de la timeline qui peut être
parcourue à l'aide de la navette.  La navette ne peut parcourir que la période de
temps qui se trouve dans la zone de prévisualisation.  En utilisant une zone de
prévisualisation à l'intérieur de l'ensemble du programme et en utilisant la navette
à l'intérieur de cette zone, vous pouvez vous déplacer rapidement et
avec précision dans la visionneuse et le compositeur.

Lorsque vous remplacez le projet en cours par un fichier, la zone de
prévisualisation est automatiquement redimensionnée pour couvrir l'ensemble du
fichier.  Lorsque vous ajoutez des données ou que vous modifiez la taille du
projet en cours, la zone de prévisualisation garde la même taille et se réduit.
Il vous faut donc redimensionner la zone de prévisualisation.

Chargez un fichier et déplacez-vous en utilisant la navette du compositeur.  Le point
d'insertion de la fenêtre principale suit le compositeur.  Survolez la barre temporelle
du compositeur avec la souris jusqu'à ce que le pointeur change de forme et se
présente sous la forme d'une flèche de redimensionnement orientée vers la gauche.
Cliquez alors et glissez vers la droite.  La zone de prévisualisation devrait avoir
changé et la navette s'être redimensionné proportionnellement.

Déplacez-vous vers la droite de la barre temporelle jusqu'à ce qu'une flèche
droite de redimensionnement apparaisse.  Glissez-la vers la gauche de façon à
réduire la taille de la zone de prévisualisation.

Déplacez-vous au centre de la région de prévisualisation sur la barre
temporelle et glissez-là de façon à vous convaincre qu'elle peut être déplacée.

@b{Note :} lorsque vous ajoutez des données ou que vous modifiez les dimensions
du projet en cours, la zone de prévisualisation conserve les mêmes dimensions
et se réduit.  Il vous faudra donc la redimensionner.

@center @image{manual_images_intl/previewregion,160mm}
@center @b{La zone de prévisualisation dans le compositeur}

Si vous utilisez la navette et que vous la déplacez avec la zone de
prévisualisation réduite, vous verrez que la navette n'affecte que la zone de
prévisualisation.  La barre temporelle et la fenêtre de visualisation
fonctionnent exactement de la même manière.

Les marques et les points d'entrée/sortie sont totalement gérés dans la
visionneuse et le compositeur.  La seule différence entre la visionneuse et le
compositeur est que le compositeur reflète l'état du programme alors que la
visionneuse reflète l'état d'un clip mais pas celui du programme.

Lorsque vous cliquez le @b{bouton de marque} dans le compositeur, la marque
apparaît à la fois dans la barre temporelle du compositeur et dans la barre
temporelle du programme.

Lorsque vous sélectionnez une marque ou un point d'entrée/sortie dans le
compositeur, la fenêtre de programme est déplacée jusqu'à cette position.

@center @image{manual_images_intl/viewer_labels,160mm}
@center @b{Marques et points d'entrée/sortie dans la visionneuse}.

Dans la visionneuse et le compositeur, les marques et les points
d'entrée/sortie sont affichés sur la barre temporelle.  Au lieu de n'afficher
qu'une région du programme, la barre temporelle affiche ici l'ensemble du
programme.

Comme la fenêtre de programme, le compositeur possède une possibilité de zoom.
On trouve d'abord un certain nombre d'options de zoom dans le menu qui se
trouve en bas de la fenêtre de composition.  Lorsque le zoom est configuré sur
@b{Auto}, la vidéo est zoomée pour s'adapter autant que possible à la taille de
la fenêtre.  Lorsqu'il est fixé à un autre pourcentage quelconque, la vidéo est
zoomée par puissances de 2, et les barres de défilement peuvent alors être
utilisées pour faire défiler la sortie.  Lorsque la vidéo est zoomée à des
dimensions plus grandes que celles de la fenêtre, les barres de défilement
ainsi que la souris permettent de la parcourir.  C'est exactement ce que fait
Gimp.

De plus, le @image{manual_images_intl/magnify,7mm} bouton de zoom fait entrer le
compositeur en mode zoom.  En mode zoom, cliquer dans la sortie vidéo permet de
zoomer alors que @b{CTRL-clic} permet de dézoomer.  Si vous avez une souris à
molette, les opérations de zoom peuvent aussi être réalisées en tournant la
molette.

Zoomer ou dézoomer avec l'outil de zoom ne modifie pas la sortie rendue.  Cela
ne sert qu'à examiner votre vidéo ou à lui permettre de s'adapter à votre
bureau.

Lire de la vidéo dans le compositeur alors qu'il se trouve avec un facteur de
zoom autre que 100% de la taille d'origine exige que Cinelerra effectue des
calculs supplémentaires.  Ceci peut affecter les performances sur les systèmes
les plus lents.

@c cincvdoc_node_number_136
@node Les effets en temps réel
@chapter Les effets en temps réel
@cindex Effets en temps réel
@cindex Effets, temps réel

Ils sont empilés sous la piste à laquelle ils s'appliquent.  Ils appliquent un
traitement à la piste lors de sa lecture, sans enregistrement permanent de la
sortie sauf lors du rendu final du projet.

Tous les effets en temps réel sont regroupés dans la fenêtre des ressources,
séparés en deux @w{groupes :} les effets audio et les effets vidéo.  Les effets
audio doivent être glissés depuis la fenêtre des ressources vers des pistes
audio.  Les effets vidéo doivent être glissés sur des pistes vidéo.

S'il y a des données sur la piste de destination, l'effet est appliqué à
l'ensemble de la piste.  S'il n'y a pas de données sur la piste, l'effet est
supprimé.  Enfin, si une région de la piste est sélectionnée, l'effet est collé
sur cette région, qu'il y ait ou non des données présentes sur la piste.

Certains effets ne traitent pas les données mais synthétisent des données.
Dans le cas d'un effet de synthèse, il vous faudra sélectionner une région de
la piste de façon à ce que, lors de l'opération de glisser, il puisse être
collé sans être supprimé.

Si vous glissez plus d'un seul effet sur une piste, ils apparaîtront empilés du
haut vers le bas, sous la piste.  Lorsque la piste est jouée, les effets sont
traités du haut vers le bas.  La sortie de l'effet du haut devient l'entrée de
l'effet qui se trouve en-dessous et ainsi de suite.

En plus du glisser depuis la fenêtre des ressources, les effets peuvent être
appliqués à une piste par l'intermédiaire d'un menu contextuel.  Faites un clic
droit sur une piste et choisissez @b{Attacher un effet} dans le menu.  Le
dialogue d'attachement de l'effet vous donne davantage de possibilités que le
simple glisser-déposer.  Il vous permet d'attacher deux types d'effets
@w{supplémentaires :} les effets partagés et les pistes partagées.  Choisissez
un greffon depuis la colonne des @b{greffons} et cliquez sur @b{Attacher},
en-dessous de la colonne des greffons, pour l'attacher.  L'effet est le même
que s'il avait été glissé depuis la fenêtre des ressources.

Lorsqu'un effet est présent sous une piste, il doit la plupart du temps être
configuré.  Placez le curseur sur l'effet et effectuez un clic droit pour
afficher son menu contextuel.  Dans ce menu est présente l'entrée @b{Afficher
les options}.  Celle-çi permet d'afficher l'interface graphique associée à
l'effet qui se trouve sous le curseur.  La plupart des effets ont une interface
graphique, mais pas tous.  Si l'effet n'a pas d'interface graphique, vous
n'obtiendrez pas de fenêtre d'options lorsque vous cliquerez sur @b{Afficher
les options}.  Lorsque vous ajustez les paramètres dans l'interface graphique,
les paramètres affectent normalement toute la durée de l'effet.

@menu
* Types d'effets en temps réel::
* Editer les effets en temps réel::
* Les effets audio en temps réel::     Effets audio en temps réel
* Les effets vidéo en temps réel::     Effets vidéo en temps réel
@end menu

@c cincvdoc_node_number_137
@node Types d'effets en temps réel
@section Types d'effets en temps réel
@cindex Types d'effets en temps réel

Les deux autres types d'effets gérés par le dialogue @b{Attacher un effet} sont
les effets recyclés.  Pour pourvoir utiliser un effet recyclé, trois conditions
doivent être remplies :
@itemize @bullet
@item Il doit y avoir d'autres effets sur la timeline.
@item Les autres effets doivent être du même type que la piste sur laquelle
vous êtes en train d'attacher l'effet.  Si la piste est une piste audio, les
effets doivent être des effets audio.  Si la piste est une piste vidéo, les
effets doivent être des effets vidéo.
@item Le point d'insertion ou la zone sélectionnée doivent commencer à
l'intérieur des autres effets.
@end itemize

Dans le cas d'un effet partagé, ces conditions doivent être remplies.  Dans le
cas d'une piste partagée, il doit y avoir une autre piste sur la timeline, qui
soit du même type que la piste à laquelle vous appliquez l'effet.  Si vous
faites un clic droit sur une piste vidéo pour attacher un effet, il n'y aura
rien dans la colonne @b{Pistes partagées} s'il n'y a pas d'autre piste vidéo.
Si vous faites un clic droit sur une piste audio, il n'y aura rien dans la
colonne @b{Pistes partagées} s'il n'y a pas d'autre piste audio.

S'il existe des effets partagés ou des pistes partagées, ils apparaîtront dans
les colonnes @b{Pistes partagées} ou @b{Effets partagés}.  Le bouton
@b{Attacher} sous chacune des colonnes permettra d'attacher sous la piste en
cours, tout ce qui se trouve en surbrillance dans la colonne.

Les effets partagés et les pistes partagées permettent de réaliser des choses
uniques.  Dans le cas d'un effet partagé, l'effet partagé est traité comme une
copie de l'effet d'origine sauf que vous ne pouvez pas afficher l'interface
utilisateur graphique de l'effet.  Toute la configuration de l'effet partagé se
fera depuis l'interface utilisateur de l'effet d'origine et on ne pourra
afficher l'interface utilisateur que pour l'effet d'origine.

Lorsqu'un effet partagé est lu, il effectue le traitement exactement comme un
effet normal à l'exception de la configuration qui est copiée depuis l'effet
d'origine.  Certains effets détectent qu'ils sont partagés, comme l'effet de
réverbération ou le compresseur.  Ces effets déterminent quelles sont les
pistes qui les partagent et soit ils mélangent les deux pistes entre-elles,
soit ils utilisent l'une des piste pour déterminer certaines valeurs.  La
réverbération mélange les pistes pour simuler une ambiance.  Le compresseur
utilise l'une des pistes partagées comme déclencheur.

@cindex Pistes renvoyées
Lorsqu'une piste d'origine possède une @b{piste partagée} pour l'un de ses
effets, la piste partagée elle-même est utilisée comme effet temps réel.  C'est
souvent appelé @b{piste renvoyée} mais Cinelerra permet de réaliser la même
opération en attachant des pistes partagées.  Le fondu et tous les effets de la
piste partagée sont appliqués à la piste d'origine.  Une fois que la piste a
effectué le traitement des données, la piste d'origine traite tous les effets
qui se trouvent sous la piste partagée et les compose ensuite sur la sortie.

De plus, une fois qu'une piste partagée à traité la sortie de la piste
d'origine comme un effet temps réel, la piste partagée se mélange elle-même sur
la sortie avec ses paramètres de panoramique, de mode et de projecteur.  De
cette manière, deux pistes effectuent le mélange des mêmes données vers la
sortie.  La plupart du temps, vous ne souhaiterez pas que la piste partagée
mélange vers la sortie les mêmes données que la piste d'origine, vous voudrez
qu'elle s'arrête juste avant l'étape de mélange et qu'elle restitue les données
vers la piste d'origine.  Ceci est obtenu en activant le
@image{manual_images_intl/mutepatch_up} bouton de sourdine associé à chaque piste
dont vous ne voulez pas effectuer le mélange vers la sortie.

Supposons que vous réalisiez une vidéo et que vous désiriez que la piste
partagée mixe la piste d'origine vers la sortie une seconde fois.  Dans le cas
de la vidéo, la vidéo de la piste partagée apparaîtra toujours sous la vidéo de
la piste d'origine, indépendamment du fait qu'elle soit au dessus de la piste
d'origine.  Ceci en raison du fait que les pistes partagées sont mixées dans
l'ordre de leur attachement.  Comme c'est une partie de la piste d'origine,
elle doit être mixée avant que la piste d'origine ne le soit.

@c cincvdoc_node_number_138
@node Editer les effets en temps réel
@section Editer les effets en temps réel
@cindex Effets temps réel, éditer
Il existe de nombreuses opérations pour manipuler des effets une fois qu'ils
ont été déposés sur la timeline.  Parce que le mélange des effets et des médias
est une chose très compliquée, les méthodes utilisées pour éditer les effets ne
sont pas aussi concises que le couper/coller.  Certaines opération sont
effectuées en glissant les points d'entrée/sortie, certaines par
l'intermédiaire de menus, et certaines en glissant des effets.

Normalement, lorsque faites du montage avec des pistes, les effets suivent les
décisions de montage.  Si vous effectuez un couper sur une piste, l'effet va se
raccourcir.  Si vous glissez les points d'entrée/sortie, les effets vont voir
leur durée varier.  Ce comportement peut être désactivé en choisissant
@b{configuration-> Editer les effets} dans la fenêtre du projet.  Ceci découple
les effets des opérations de montage, mais comment faire pour ne modifier que
les effets ?

Déplacez le curseur de la timeline sur les bords d'un effet jusqu'à ce qu'il
change de forme pour s'afficher sous la forme d'une icône de redimensionnement
vers la gauche ou vers la droite.  Dans cet état, si vous glissez la fin de
l'effet, il réalise une opération de montage exactement comme si vous glissiez
la fin de la piste.

Les trois comportements de l'ajustement des pistes s'appliquent à l'ajustement
des effets et sont liés aux boutons de la souris tels que vous les avez
configurés dans les préférences de l'@b{interface utilisateur}.
@xref{Interface}.  Lorsque vous effectuez l'ajustement d'un effet, les limites
de l'effet sont déplacées en les glissant.  A l'inverse de l'édition des
pistes, l'effet n'a pas de dimensions source.  Vous pouvez donc étendre la fin
d'un effet autant que vous le désirez sans être limité.

De même, à l'inverse de l'édition de pistes, la position de départ d'une
opération de glisser ne lie pas la décision de montage au média.  Le média
auquel est lié l'effet ne suit pas les modifications de l'effet.  Les autres
effets, cependant, suivent les décisions de montage faites sur cet effet.  Si
vous glissez la fin d'un effet qui est aligné avec des effets se trouvant sur
d'autres pistes, les effets des autres pistes seront modifiés bien que le média
reste le même.

Que se passe-t-il si vous ajustez la fin d'un effet en laissant beaucoup de
temps non affecté vers la fin de l'effet ? Lorsque vous glissez un effet depuis
la fenêtre des ressources, vous pouvez insérer l'effet dans la portion de la
ligne non occupée par l'opération d'ajustement.  Les effets en temps réel sont
organisés en lignes sous la piste.  Chaque ligne pouvant comporter plusieurs
effets.

Dans certains cas, vous désirerez que l'opération d'ajustement ne change qu'une
seule ligne d'effets.  Ceci peut être obtenu en plaçant d'abord le point
d'insertion au début ou à la fin de l'effet.  Pressez ensuite la touche
@key{MAJ} en commençant l'opération d'ajustement.  Ceci permet à l'opération de
ne modifier qu'une seule ligne d'effets.

En plus de l'ajustement, vous pouvez déplacer un effet vers le haut ou vers le
bas.  Chaque piste possède, à sa partie inférieure, une pile contenant les
effets.  En déplaçant les effets vers le haut ou vers le bas, vous modifiez
l'ordre dans lequel ils sont traités sur la pile.  Allez sur l'un des effets et
faites un clic droit pour afficher le menu de l'effet.  Les options @b{Déplacer
vers le haut} et @b{Déplacer vers le bas} déplacent les effets dans la
direction souhaitée.

@cindex Effets partagés
@cindex Partagés, Les effets
Lorsque vous déplacez des effets vers le haut ou vers le bas, prêtez attention
au fait que s'ils sont partagés en tant qu'@b{effets partagés}, toutes les
références pointeront alors vers un effet différent après l'opération de
déplacement.

Enfin, il y a les glisser d'effets.  Glisser des effets fonctionne exactement
comme glisser des plans.  Vous devez sélectionner la
@image{manual_images_intl/arrow,2.67mm} flèche pour passer dans le mode
glisser-déposer avant de pouvoir glisser des effets.  Les effets se collent aux
limites des médias, aux limites des effets et des pistes.  Faites attention si
vous glissez la référence d'un effet partagé, après cela, la référence pointera
habituellement vers le mauvais effet.

Faites un clic droit sur un effet pour afficher le menu de l'effet.  Choisissez
@b{Remplacer...} pour remplacer l'effet ou pour modifier la référence si c'est
un effet partagé.

@c cincvdoc_node_number_139
@node Les effets audio en temps réel
@section Les effets audio en temps réel
@cindex Les effets audio en temps réel

@menu
* Compresseur::	        Comment réduire la dynamique de l'audio.
* Audio en direct::    	Passer l'audio directement de la carte son à la timeline.
* Décalage de hauteur::
* Audio arrière::	Comment lire des régions à l'envers.
* Retard audio::
* Supprimer le bruit::
* Supprimer le bruit FFT::
* Déparasiter::
* Egaliseur paramétrique::
* Freeverb::
* Gain::
* Heroine College::
* Interpoler::
* Audio inversée::
* Boucle audio::
* Overlay::
* Niveau audio::
* Spectrogramme::
* Synthétiseur::
* Etirement du temps::
@end menu

@c cincvdoc_node_number_140
@node Compresseur
@subsection Compresseur
@cindex Compresseur

@image{manual_images_intl/compressor,12.5mm}

Au contraire de ce qu'on fait avec les ordinateurs, le compresseur audio ne
réduit pas la quantité de données nécessaires pour enregistrer de l'audio sur
disque.  Le compresseur audio diminue la plage dynamique de l'audio.  Dans le
cas de Cinelerra, le compresseur remplit à la fois le rôle d'un expanseur et
d'un compresseur.

Le compresseur fonctionne en calculant le niveau sonore maximum à l'intérieur
d'une certaine période de temps autour de la position actuelle.  Le niveau
sonore maximum est pris comme niveau sonore d'entrée.  Pour chaque niveau
sonore d'entrée, il y a un niveau sonore de sortie indiqué par l'utilisateur.
Le gain à la position actuelle est ajusté de façon à ce que le niveau sonore
maximum dans la plage de temps ait la valeur indiquée par l'utilisateur.

Le compresseur possède une représentation graphique indiquant la corrélation
entre la niveau sonore d'entrée et le niveau sonore de sortie.  L'axe
horizontal est le niveau d'entrée en dB@.  L'axe vertical représente le niveau
de sortie en dB@.  L'utilisateur indique les niveaux sonores en sortie en créant
des points sur le graphique.  Cliquez sur le graphique pour créer un point.  Si
deux points existent, glissez l'un des points sur le second pour l'effacer.  La
valeur du point le plus récent est affichée dans des boîtes de texte pour
permettre un ajustement plus précis.

Pour que le compresseur réduise la dynamique de l'audio, il faut que les
valeurs en sortie soient plus grandes que les valeurs en entrée sauf pour 0
dB@.  Pour que la plage dynamique soit étendue, il faut que toutes les valeurs
de sortie, à l'exception du point 0 dB, soient plus faibles que les valeurs
d'entrée.  L'algorithme limite tous les niveaux sonores au-dessus de 0 dB à 0
dB@.  Donc, pour à obtenir un effet de saturation, appliquez un effet de gain
avant le compresseur pour réduire tous les niveaux et faites-le suivre avec un
autre effet de gain qui amplifie tous les niveaux au-dessus de 0 dB@.

@b{Temps de réaction :} ceci détermine la position à laquelle est prise la
valeur maximale par rapport à la position actuelle et la vitesse à laquelle le
gain est ajusté pour atteindre cette crête.  Il est noté en secondes.  S'il est
négatif, le compresseur va lire en avant de la position actuelle pour obtenir
les crêtes futures.  Le gain est affecté d'une rampe vers le maximum de cette
durée.  Ceci lui permet d'atteindre le niveau désiré en sortie exactement quand
la crête d'entrée se produit à la position actuelle.

Si le temps de réaction est positif, le compresseur ne balaie que la position
actuelle pour le gain et le gain est affecté d'une rampe de cette durée pour
attendre le niveau de sortie désiré.  Il atteint le niveau de sortie désiré au
moment exact de la détection de la crête en entrée, auquel se rajoute le temps
de réaction.

@b{Temps de décroissance :} si la crête est plus élevée que le niveau actuel,
le compresseur affecte le gain d'une rampe vers la valeur crête.  Ensuite, si
une crête future est inférieure à la crête actuelle, le gain est affecté d'une
rampe décroissante.  Le temps pris par la rampe pour atteindre le gain en
descendant peut être supérieur au temps pris par la rampe croissante.  Il
s'agit de ce temps de décroissance de la rampe en secondes.

@b{Type de déclenchement :} le compresseur est un effet multicanal.  Plusieurs
pistes se partagent le même compresseur.  La manière dont le signal en
provenance de plusieurs pistes est interprété dépend du type de déclenchement.

Le @b{Type de déclenchement} utilise la valeur fournie dans la boîte de texte
@b{Déclencheur} comme numéro de la piste à utiliser en entrée pour le
compresseur.  Ceci permet à une piste qu'on n'entend pas de déterminer le
volume sonore des autres pistes.

Un déclenchement sur le @b{Maximum} prend la piste qui donne le niveau sonore
le plus élevé et l'utilise en entrée du compresseur.

Un déclenchement sur le @b{Total} ajoutera les signaux de toutes les piste et
utilisera ce total comme entrée pour le compresseur.  C'est la compression qui
donne le rendu le plus naturel et c'est l'idéal lorsque l'on fait la moyenne de
plusieurs pistes vers un seul haut-parleur.

@b{Déclencheur :} le compresseur est un effet multicanal.  Plusieurs pistes
peuvent partager un même compresseur.  Normalement, une seule piste est
parcourue à la recherche de la valeur crête.  Cette piste est appelée le
@b{Déclencheur}.  En partageant plusieurs pistes et en jouant sur la valeur du
déclencheur, vous pouvez faire suivre une onde sinusoïdale sur une piste par un
bruit de batterie sur une autre, par exemple.

@b{Lisser seulement :} pour afficher ce que fait le compresseur dans les
indicateurs de niveau, cette option permet de remplacer l'onde sonore par
uniquement la valeur crête actuelle.  Il est alors très facile de voir l'action
du @b{temps de réaction} sur la détection des valeurs de crête.

@c cincvdoc_node_number_141
@node Retard audio
@subsection Retard audio
@cindex Retard audio

@image{manual_images_intl/delayaudio,12.5mm}

Indiquez simplement de combien de secondes vous désirez que la piste audio soit
retardée.

@c cincvdoc_node_number_142
@node Supprimer le bruit
@subsection Supprimer le bruit
@cindex Supprimer le bruit

@image{manual_images_intl/denoise,13mm}

FIXME

@c cincvdoc_node_number_143
@node Supprimer le bruit FFT
@subsection Supprimer le bruit FFT
@cindex Supprimer le bruit FFT

@image{manual_images_intl/denoisefft,13mm}

FIXME

@c cincvdoc_node_number_144
@node Déparasiter
@subsection Déparasiter
@cindex Déparasiter

@image{manual_images_intl/despike,12.5mm}

FIXME

@c cincvdoc_node_number_145
@node Egaliseur paramétrique
@subsection Egaliseur paramétrique
@cindex Egaliseur paramétrique

@image{manual_images_intl/parametric,12.5mm}

FIXME

@c cincvdoc_node_number_146
@node Freeverb
@subsection Freeverb
@cindex Freeverb

@image{manual_images_intl/freeverb,12.5mm}

FIXME

@c cincvdoc_node_number_147
@node Gain
@subsection Gain
@cindex Gain

@image{manual_images_intl/gain,12.5mm}

FIXME

@c cincvdoc_node_number_148
@node Heroine College
@subsection Heroine College
@cindex Heroine College

@image{manual_images_intl/reverb,12.5mm}

FIXME

@c cincvdoc_node_number_150
@node Interpoler
@subsection Interpoler
@cindex Interpoler

@image{manual_images_intl/interpolateaudio,13.25mm}

FIXME

@c cincvdoc_node_number_151
@node Audio inversée
@subsection Audio inversée
@cindex Audio inversée

@image{manual_images_intl/invertaudio,12.5mm}

FIXME

@c cincvdoc_node_number_152
@node Audio en direct
@subsection Audio en direct
@cindex Effet audio en direct

@image{manual_images_intl/liveaudio,12.5mm}

Cet effet lit directement l'audio depuis l'entrée de la carte son.  Il remplace
toute l'audio de la piste il est donc en général appliqué sur une piste vide.

Afin d'utiliser @b{audio en direct}, mettez en surbrillance une zone
horizontale d'une piste audio ou placez les points d'entrée et de sortie.
Déposez-y ensuite l'effet d'audio en direct.  Créez des pistes supplémentaires
et attachez à ces autres pistes des copies partagées du premier effet d'audio
en direct afin d'enregistrer des canaux supplémentaires.

L'audio en direct utilise le pilote audio sélectionné dans
@b{Configuration->Préférences->Lecture->Sortie audio} pour enregistrer, mais au
contraire le l'acquisition il utilise la @b{taille de tampon en lecture} comme
tampon d'enregistrement et le @b{taux d'échantillonage du projet} comme taux
d'échantillonnage.

Ces paramètres sont critiques car certaines cartes son ne peuvent pas
enregistrer dans un tampon dimensionné de la même manière que celui dans lequel
elle effectuent la restitution.  L'audio en direct est plus fiable lorsque le
pilote d'enregistrement est ALSA et que la taille de fragment de lecture est de
2048.

Déposez les autres effets après l'effet audio en direct afin de traiter
l'entrée de la carte son en temps réel.

Aux mauvaises nouvelles maintenant.  Avec l'audio en direct, il n'y a pas
d'anticipation, donc des effets tels que le compresseur auront un retard si
l'anticipation est activée ou il manquera des données lors de la lecture.

Un autre problème provient du fait que l'horloge de la carte son est parfois
légèrement plus lente que l'horloge de la lecture.  L'enregistrement sera alors
en avance et le son reproduit sera saccadé.

Enfin, l'audio en direct ne fonctionne pas en inverse.

@c cincvdoc_node_number_153
@node Boucle audio
@subsection Boucle audio
@cindex Boucle audio

@image{manual_images_intl/loopaudio,12.5mm}

FIXME

@c cincvdoc_node_number_154
@node Overlay
@subsection Overlay
@cindex Overlay

@image{manual_images_intl/overlay,13.25mm}

FIXME

@c cincvdoc_node_number_155
@node Décalage de hauteur
@subsection Décalage de hauteur
@cindex Décalage de hauteur
@cindex Audio, décalage de hauteur

@image{manual_images_intl/pitch,12.5mm}

Comme pour les méthodes d'étirement du temps, il y a trois méthodes de décalage
de hauteur : @b{Décalage de hauteur}, @b{Rééchantillonner}, et le @b{Dialogue
des informations de l'objet}.  Le décalage de hauteur est un effet temps-réel
qui peut être glissé et collé sur une piste audio enregistrable.  Le décalage
de hauteur utilise une transformation rapide de Fourier afin d'essayer de
modifier la hauteur sans toucher à la durée, mais ceci introduit des "artefacts
de fenêtre".

Parce que les artefacts de fenêtre sont moins obstrusive #FIXME# quand l'audio
est décalée en hauteur de manière évidente, le décalage de hauteur est surtout
utilisé pour des modifications de hauteur extrêmes.  Pour des modifications de
hauteur moyennes, utiliser le @b{rééchantillonnage} depuis l'interface
@b{Audio->Rendu d'effet}.  Le rééchantillonnage peut modifier la hauteur dans
les limites de 5% sans modification notable de la durée.

Une autre manière de modifier légèrement la hauteur est d'aller dans la fenêtre
des @b{Resources}, de mettre en surbrillance le dossier @b{media}, de faire un
clic droit sur un fichier audio, puis de cliquer sur @b{Info}.  Ajustez le taux
d'échantillonnage dans le dialogue @b{Info} pour ajuster la hauteur.  Cette
méthode demande aussi d'effectuer un clic gauche sur la limite droite des
pistes audio et de glisser cette limite vers la gauche ou vers la droite afin
de déterminer la durée de la modification.

@c cincvdoc_node_number_156
@node Audio arrière
@subsection Audio arrière
@cindex Effet d'audio arrière

@image{manual_images_intl/reverseaudio,12.5mm}

Appliquer @b{audio arrière} à une piste audio et lisez-la en sens inverse.  Le
son sera reproduit normalement.

Soyez conscient, en inversant l'audio, que la forme d'onde sur la timeline ne
reflète pas la sortie inversée.

@c cincvdoc_node_number_157
@node Niveau audio
@subsection Niveau audio
@cindex Niveau audio

@image{manual_images_intl/level,12.5mm}

FIXME

@c cincvdoc_node_number_158
@node Spectrogramme
@subsection Spectrogramme
@cindex Spectrogramme

@image{manual_images_intl/spectrogram,12.5mm}

FIXME

@c cincvdoc_node_number_159
@node Synthétiseur
@subsection Synthétiseur
@cindex Synthétiseur

@image{manual_images_intl/synthesizer,12.5mm}

FIXME

@c cincvdoc_node_number_160
@node Etirement du temps
@subsection Etirement du temps
@cindex Etirement du temps

@image{manual_images_intl/timestretch,12.5mm}

FIXME

@c cincvdoc_node_number_161
@node Les effets vidéo en temps réel
@section Les effets vidéo en temps réel
@cindex Les effets vidéo en temps réel

@menu
* 1080 vers 540::       	Comment convertir de la HDTV en SD.
* Vieillissement TV::		Comment obtenir un aspect de vieux film.
* Flou::
* Luminosité/contraste::	Comment ajuster la luminosité et le contraste.
* Brûlage TV::			Comment "brûler" votre vidéo.
* Clé chromatique::		Créer de la transparence en se basant du des similitudes de couleurs.
* Clé chromatique (TSV)::
* Balance des couleurs::
* Retard vidéo::
* Supprimer le bruit de la vidéo::
* Supprimer le bruit de la vidéo 2::
* Décimer::          		Comment réduire la fréquence des images en éliminant les images semblables.
* Désentrelacer::       	Comment convertir de la vidéo entrelacée en vidéo progressive.
* Clé de différence::    	Créer de la transparence en se basant sur des différences de couleurs.
* DotTV::             		Comment donner un effet "DotTV" à votre vidéo.
* Sous-échantillonner::        	Comment réduire la taille d'une image en éliminant des données.
* Champs vers images::  	Comment récupérer l'entrelacement depuis de la vidéo bobbed.
* Retourner::              	Comment retourner une piste vidéo
* Images vers champs::
* Figer l'image::
* Gamma::
* Dégradé::
* Histogramme::			Comment modifier la cartographie de différentes valeurs de luminosité.
* TV holographique::
* Teinte/Saturation::    	Comment ajuster la teinte et la saturation.
* Interpoler la vidéo::
* Interpoler les pixels::	Comment créer l'illusion de fréquence d'images plus élevées.
* Télécinéma inverse::  	Comment convertir des images pulled down en images progressives
* Inverser la vidéo::
* Flou linéaire::
* Vidéo en direct::        	Passer la vidéo directement depuis la carte d'acquisition à la timeline.
* Boucle vidéo::        	Comment reboucler des régions de la timeline.
* Suivi de mouvement::          L'art du suivi de mouvement.
* Flou de mouvement::
* Peinture à l'huile::      	Comment faire ressembler vos vidéos à de la peinture à l'huile.
* Overlay video::
* Perspective::       		Comment modifier la perspective d'uen piste vidéo.
* Polaire::             	Comment plier et enrouler votre vidéo.
* RVB-601::
* Flou radial::
* ReframeRT::         		Modifier le nombre d'images d'une séquence.
* Vidéo en arrière::     	Comment reproduire en arrière des régions.
* Rotation::            	Comment effectuer une rotation de votre vidéo.
* SVG via Inkscape::
* Redimensionner::
* Moyenne temporelle sélective::
* Netteté::
* Décalage d'interlacement::
* Permuter les canaux::
* Seuil::         		Comment obtenir une sortie monochrome à partir d'une région de l'image.
* Moyenne temporelle::      	Comment ajouter des motifs de traînée afin d'améliorer la qualité des images fixes.
* Front temporel::
* Titreur::			Comment ajouter un titre
* Translation::
* Défocaliser::           	Comment rendre moins nette votre vidéo.
* Vidéoscope::			Comment afficher la plage dynamique de l'intensité et de la teinte.
* Vagues::
* Tourbillon::
* YUV::
* Flou de zoom::
@end menu

@c cincvdoc_node_number_162
@node 1080 vers 540
@subsection 1080 vers 540
@cindex Effet 1080 vers 540

@image{manual_images_intl/1080to540,12.5mm}

La plupart des émissions de télévision sont reçues avec une résolution de
1920x1080 mais sont issue d'une source 720x480 au studio.  C'est du gaspillage
de place que de compresser l'ensemble du 1920x1080 si les détails visibles sont
en 720x480.  Malheureusement, la retranscription de 1920x1080 vers 720x480 ne
se borne pas à une simple réduction.

A la station de télévision, le métrage d'origine en 720x480 est d'abord
converti en champs de 720x240.  Chaque champ et alors "gonflé" à
1920x540.  Les deux champs de 1920x540 sont enfin combinés par entrelacement
pour former une image de 1920x1080.  Cette technique permet à un téléviseur
grand public d'afficher l'image rééchantillonnée sans nécessiter de circuits
supplémentaires pour gérer l'entrelacement 720x480 dans une image 1920x1080.

Si vous vous contentez de désentrelacer les images 1920x1080, vous obtiendrez à
la fin un niveau de détail correspondant à une résolution de 720x240.  L'effet
@b{1080 vers 540} extrait correctement de l'image les deux champs d'une taille
de 1920x540, les redimensionne séparément et les recombine pour restaurer
l'original de 720x480.  L'effet @b{Redimensionner} doit alors être appliqué
afin de réduire la taille d'origine à 960 ou 720 selon le rapport d'aspect
d'origine.

Les pistes auxquelles @b{1080 vers 540} est appliqué doivent se trouver dans
une résolution de 1920x1080.  Les paramètres du projet dans @b{Configuration-->
format...} doivent avoir une résolution d'au moins 720x480.

Cet effet ne sait pas si la première ligne de l'image 1920x1080 correspond à la
première ligne dans l'original de 720x480.  Vous devez indiquer quelle est la
première ligne dans la configuration de l'effet.

La sortie de cet effet est une petite image au centre de l'image originale en
1920x1080.  Utilisez le projecteur pour centrer l'image de sortie lors de la
lecture.

Enfin, une fois que vous avez obtenu la vidéo entrelacée en 720x480, vous
pouvez soit appliquer un effet de @b{trames vers champs} ou @b{Télécinéma
inverse} pour récupérer encore davantage les images progressives d'origine.

@c cincvdoc_node_number_163
@node Vieillissement TV
@subsection Vieillissement TV
@cindex Vieillissement TV

@image{manual_images_intl/aging,17mm}

Cet effet est celui à utiliser si vous désirez obtenir un aspect de "vieux
film" ou d'émission de télévision.  Il va ajouter des lignes ondulantes en
haut et en bas du film ainsi que de la "neige" sur la vidéo.  Utilisez-le
conjointement avec Luminosité/Contraste et Equilibre des couleurs afin de faire
ressembler votre film à un très vieux film en noir et blanc.

@c cincvdoc_node_number_164
@node Flou
@subsection Flou
@cindex Flou

@image{manual_images_intl/blur,12.5mm}

Cet effet rend floue une piste vidéo.  Ses paramètres sont :
@itemize @bullet
@item @b{Horizontal et vertical}@*
Ces paramètres sont utilisés pour indiquer lequel des champs sera affecté par
le flou.  Il peut s'agir des deux champs.
@item @b{Rayon}@*
Utiliser ce curseur pour définir le niveau de flou à appliquer.
@item @b{Flou alpha, rouge, vert, bleu}@*
Indique les canaux de couleurs qui devront être rendus flous.
@end itemize

@c cincvdoc_node_number_165
@node Luminosité/contraste
@subsection Luminosité/contraste
@cindex Luminosité/contraste
@cindex Contraste

@image{manual_images_intl/brightness,12.5mm}

Si vous désirez éclaircir une prise de vue sombre, ou ajouter de la lumière,
cet effet est fait pour vous.  N'utilisez pas trop cet effet ou bien vous
risquez de dégrader la qualité de votre vidéo.  Utilisez-le avec les images-clé afin
d'éclaircir une longue prise de vue qui est trop sombre au début mais claire à
la fin.  Généralement, vous devrez modifier la luminosité et le contraste dans
des proportions équivalentes (par exemple, luminosité 28 contraste 26) de
manière à ce que vos couleurs d'origine demeurent intactes.

@c cincvdoc_node_number_166
@node Brûlage TV
@subsection Brûlage TV
@cindex Brûlage TV
@cindex Brûlage vidéo

@image{manual_images_intl/burn,16mm}

L'effet de brûlage vidéo fait "brûler" votre vidéo lorsqu'il y a de petits
éléments lumineux et colorés dans la vidéo, sur les bords d'un T-shirt par
exemple.  Ce peut être un très bon élément dans une vidéo musicale ou juste un
bon moyen de libérer votre imagination.

@c cincvdoc_node_number_167
@node Clé chromatique
@subsection Clé chromatique
@cindex Effet de clé chromatique

@image{manual_images_intl/chromakey,12.5mm}

Cet effet efface tous les pixels qui correspondent à une certaine couleur.  Ils
sont remplacés par du noir s'il n'y a pas de canal alpha et par de la
transparence s'il y a un canal alpha.  Le choix du modèle colorimétrique est
important pour en déterminer le comportement.

@cindex Pipette à couleurs
La clé chromatique utilise soit la luminosité soit la teinte pour définir ce
qui sera effacé.  @b{Utiliser la valeur} permet de n'utiliser que la valeur pour
déterminer la transparence.  Choisissez la couleur centrale à effacer en
utilisant le bouton @b{Couleur}.  Vous pouvez aussi sélectionner directement
une couleur dans l'image depuis la fenêtre de composition à l'aide de la
@b{Pipette à couleurs} et en cliquant le bouton @b{Utiliser la pipette à
couleur}.  Ceci permet d'utiliser la couleur actuelle de la pipelle à couleurs
comme couleur à utiliser pour la clé chromatique.

Soyez conscient que la sortie de la clé chromatique est ensuite réinjectée dans
le compositeur, si vous choisissez donc de nouveau une couleur depuis le
compositeur, la sortie de l'effet clé chromatique sera utilisée.  L'effet clé
chromatique doit être désactivée lorsque vous choisissez une couleur à l'aide
de la pipette.

Si la luminosité ou la teinte se trouvent à l'intérieur d'un certain seuil,
elle est effacée.  L'augmentation du seuil détermine la plage de couleurs à
effacer.  Ce n'est cependant pas pas un simple commutateur marche/arrêt.
Lorsque la couleur s'approche de la limite du seuil, elle est graduellement
effacée si la pente est forte et rapidement effacée si la pente est faible.  La
pente définie ici est le nombre de valeurs supplémentaires, de part et d'autre
du seuil, nécessaires pour passer de l'opacité à la transparence.

Normalement le seuil est très faible lorsqu'on utilise une pente élevée.  Ces
deux paramètres tendent à être mutuellement exclusifs parce que la pente
remplit le seuil supplémentaire.

La pente permet d'adoucir les bords de la clé chromatique mais cela ne
fonctionne pas très bien sur des sources compressées.  Une technique courante
pour adoucir ces bords est d'utiliser une pente maximale et d'enchaîner sous la
clé chromatique, un effet de flou afin de ne rendre flou que le canal alpha.

@c cincvdoc_node_number_168
@node Clé chromatique (TSV)
@subsection Clé chromatique (TSV)
@cindex Effet de clé chromatique (TSV)

@image{manual_images_intl/chromakeyhsv,12.5mm}

FIXME

@c cincvdoc_node_number_169
@node Balance des couleurs
@subsection Balance des couleurs
@cindex Balance des couleurs

@image{manual_images_intl/colorbalance,12.5mm}

La balance des couleurs est l'effet adéquat à utiliser conjointement à
Luminosité/contraste et Teinte/Saturation, afin de compenser les erreurs
possibles lors du tournage (faible éclairement, etc.).  Il ne peut cependant
pas faire tout ça sans dégrader la qualité de la vidéo.  C'est exactement comme
l'effet de "balance des blancs" dans un programme de retouche d'images,
tel que GIMP@.  Avec cet effet, vous pouvez modifier les couleurs qui seront
envoyées vers une sortie CMJ (Cyan, Magenta, Jaune) ou RVB (Rouge, Vert, Bleu).

@c cincvdoc_node_number_170
@node Décimer
@subsection Décimer
@cindex Effet de décimation

@image{manual_images_intl/decimate,13.25mm}

Cet effet abandonne les images d'une piste qui sont les plus semblables de
manière à diminuer la fréquence des images.  C'est habituellement appliqué à un
DVD pour convertir la vidéo de 29,97 i/s à la fréquence d'un film de 23,97 i/s
mais cet effet de décimation peut prendre n'importe quelle fréquence en entrée
et la convertir pour obtenir une fréquence de sortie plus faible.

La fréquence de sortie de l'effet de @b{décimation} est la fréquence du projet.
La fréquence d'entrée est définie par l'interface utilisateur de configuration
de l'effet.  Pour effectuer la conversion d'une vidéo progressive de 29,97 i/s
en une fréquence de film de 23,97 i/s film, appliquer l'effet de décimation à
la piste, définissez la fréquence d'entrée de l'effet à 29,97 et la fréquence
du projet à 23,97.

Soyez attentif au fait que chaque effet empilé avant l'effet de décimation
effectuera le traitement de la vidéo à la fréquence d'entrée et que chaque
effet se trouvant après l'effet de décimation effectuera le traitement de la
vidéo à la fréquence du projet.  Les effets qui demandent beaucoup de
ressources de calcul devraient se trouver en-dessous de l'effet de décimation.

@c cincvdoc_node_number_171
@node Désentrelacer
@subsection Désentrelacer
@cindex Effet de désentrelacement

@image{manual_images_intl/deinterlace,12.5mm}

L'effet de désentrelacement a évolué au cours des années vers le
désentrelacement et bien plus encore.  En fait, deux des méthodes de
désentrelacement, le @b{Télécinéma inverse} et @b{Images vers Champs}, sont des
effets différents.  L'effet de désentrelacement met à disposition plusieurs
variantes de réplication des lignes pour éliminer l'artefact en peigne de la
vidéo entrelacée.  Il dispose aussi d'outils de permutation des lignes pour
corriger de la vidéo qui aurait été capturée de manière incorrecte ou pour
remettre dans le bon ordre l'affichage des champs d'un effet inversé.

@c cincvdoc_node_number_172
@node Retard vidéo
@subsection Retard vidéo
@cindex Retard vidéo

@image{manual_images_intl/delayvideo,12.5mm}

FIXME

@c cincvdoc_node_number_173
@node Supprimer le bruit de la vidéo
@subsection Supprimer le bruit de la vidéo
@cindex Supprimer le bruit de la vidéo

@image{manual_images_intl/denoisevideo,12.5mm}

FIXME

@c cincvdoc_node_number_174
@node Supprimer le bruit de la vidéo 2
@subsection Supprimer le bruit de la vidéo 2
@cindex Supprimer le bruit de la vidéo

@image{manual_images_intl/denoisemjpeg,12.5mm}

FIXME

@c cincvdoc_node_number_175
@node Clé de différence
@subsection Clé de différence
@cindex Effet de clé de différence

@image{manual_images_intl/diffkey,12.5mm}

La clé de différence crée de la transparence dans les zones qui sont similaires
entre deux images.  L'effet de clé de différence doit être appliqué à deux
pistes.  Une piste comporte l'action qui se déroule devant un fond uniforme et
l'autre piste comporte un fond sans premier plan.  Appliquez l'effet de clé de
différence à la piste qui comporte l'action et appliquez-en une copie partagée
à la piste comportant le fond.  La piste avec le fond doit être rendue muette
et se trouver sous la piste avec l'action.  Le modèle colorimétrique doit avoir
un canal alpha.

Les pixels qui sont différents sur la piste comportant l'arrière-plan et la
piste comportant l'action seront considérés comme étant opaques.  Les pixels
qui sont similaires sont considérés comme étant transparents.  Une modification
du @b{seuil} dans la fenêtre de clé de différence permettra de rendre
transparent davantage de pixels alors qu'ils ne sont pas de la même couleur.
Modifiez la @b{pente} pour modifier la vitesse avec laquelle la transparence
diminue lorsque les pixels deviennent plus transparents.

La pente telle que définie ici est le nombre de valeurs supplémentaires, de
part et d'autre du seuil, nécessaires pour aller d'opaque vers transparent.
Une pente élevée est plus utile avec un seuil faible parce que la pente remplit
le seuil supplémentaire.

L'@b{utilisation de la valeur} permet d'effectuer une comparaison sur
l'intensité des pixels et non la couleur.

L'application de flou à la piste du dessus, en ne rendant flou que le canal
alpha, peut permettre d'adoucir les limites de la transparence.

@b{Note :} actuellement cet effet provoque des plantages lorsqu'il est utilisé
dans les modes YUV.

@c cincvdoc_node_number_176
@node DotTV
@subsection DotTV
@cindex DotTV

@image{manual_images_intl/dot,16.5mm}

Un autre effet de Kentaro (effectTV).

@c cincvdoc_node_number_177
@node Sous-échantillonner
@subsection Sous-échantillonner
@cindex Sous-échantillonner

@image{manual_images_intl/downsample,12.5mm}

Le sous-échantillonnage est le processus qui réduit la taille d'une image en
supprimant des données par une réduction de l'échantillonnage.

Les paramètres de cet effet @w{sont :}@*
Horizontal@*
Décalage horizontal@*
Vertical@*
Décalage vertical@*
Canaux

@c cincvdoc_node_number_178
@node Champs vers images
@subsection Champs vers images
@cindex Effet champs vers images

@image{manual_images_intl/fieldframe,12.5mm}

Cet effet lit les images à deux fois la fréquence des images du projet,
combinant 2 images en entrée en une seule image interlacée.  Les effets qui
précèdent @b{champs vers images} traitent les images à deux fois la fréquence
des images du projet.  Chaque image en entrée est appelée un champ.

@b{Champs vers images} a besoin de connaître à quelles lignes correspond quel
champ dans l'image en sortie.  La manière la plus simple est d'essayer les deux
options qui se trouvent dans la fenêtre.  Si les champs en entrée proviennent
d'un traitement de duplication des lignes comme avec @b{images vers champs}, le
mauvais choix pour le paramètre donnera une image floue en sortie.  Si les
champs en entrée proviennent d'une conversion entre normes telle que @b{1080
vers 540}, une mauvaise valeur de paramètre ne fera pas de différence.

Le debobber qui convertit un format 720x480 entrelacé en 1920x1080 entrelacé ou
en 1280x720 progressif semble dégrader la résolution verticale au point qu'elle
ne puisse pas être récupérée.

@c cincvdoc_node_number_179
@node Retourner
@subsection Retourner
@cindex Retourner

@image{manual_images_intl/flip,12.5mm}

Cet effet permet de retourner une piste vidéo (ou une portion de piste vidéo)
de la gauche sur la droite, du haut sur le bas ou du bas vers le haut.

La fenêtre de dialogue est simple, puisque seuls les paramètres horizontal et
vertical sont nécessaires.

@c cincvdoc_node_number_180
@node Images vers champs
@subsection Images vers champs
@cindex Images vers champs

@image{manual_images_intl/framefield,13.25mm}

FIXME

@c cincvdoc_node_number_181
@node Figer l'image
@subsection Figer l'image
@cindex Effet figer l'image

@image{manual_images_intl/freezeframe,12.5mm}

Dans sa forme la plus simple, mettez en surbrillance une région de la piste à
figer, déposez l'effet figer l'image sur la région en surbrillance, et la
première image de la région affectée sera jouée pendant toute la durée de la
région.

Figer l'image possède une option @b{Activé} qui peut être associée à une
image-clé.  Les régions où un effet @b{figer l'image} est activé répéteront la
première image située après la dernière image-clé.  Ceci permet des
possibilités uniques.

@itemize @bullet
@item Si un effet @b{figer l'image} possède une image-clé en son milieu,
configurez-le sur @b{Activé}, l'image du milieu est répétée pour toute la durée
de l'effet.
@item Si un effet de @b{figer l'image} possède plusieurs images-clés, toutes
étant @b{Actives}, chaque fois qu'une image-clé est rencontrée, l'image qui se
trouve à cet emplacement se fige.
@item Si un effet de @b{figer l'image} est alternativement @b{Activé} et
@b{Désactivé}, chaque fois qu'une image-clé @b{Active} est rencontrée, l'image
qui s'y trouve est répliquée jusqu'à l'image-clé @b{Désactivée} suivante.  Les
régions désactivées se déroulent normalement.
@end itemize

@c cincvdoc_node_number_182
@node Gamma
@subsection Gamma
@cindex Effet gamma
@cindex Images brutes d'appareils numériques

@image{manual_images_intl/gamma,12.5mm}

Les images brutes (format RAW) des appareils numériques enregistrent les images
avec une échelle logarithmique.  Les noirs de ces images se trouvent proches de
0 et les blancs sont supposés à l'infini.  Les cartes graphiques et la plupart
des codecs vidéo enregistrent les couleurs selon une échelle linéaire mais
Cinelerra conserve aux images brutes leur échelle logarithmique d'origine
lorsqu'il en effectue le rendu.  Ceci est nécessaire car l'analyseur d'images
brutes ne peut pas toujours décoder la valeur correcte du gamma des images.  Il
effectue aussi son traitement sous 16 bits, ce qui fait perdre beaucoup
d'informations.

L'effet gamma convertit les couleurs logarithmique en couleurs linéaires à
l'aide d'une valeur de gamma et d'une valeur maximum.  La valeur de gamma
détermine la raideur de la courbe de sortie, et la valeur maximale est
l'endroit où la valeur 1.0 en sortie correspond au maximum de luminosité en
entrée.

L'effet gamma possède deux autres paramètres qui permettent de simplifier la
correction de gamma.  L'option @b{Automatique} détermine la valeur @b{max} à
partir de l'histogramme de l'image.  Utilisez-la lorsque vous effectuez la
prévisualisation d'une longue liste d'images puisqu'elle change pour chaque
image.

L'option @b{Utiliser la pipette à couleurs} utilise la valeur qui se trouve
actuellement dans la pipette à couleurs pour définir la valeur @b{max}.  Notez
que chaque fois que vous prenez une couleur dans la fenêtre de composition,
vous devrez cliquer @b{Utiliser la pipette à couleurs} afin d'utiliser la
nouvelle valeur.

@c cincvdoc_node_number_183
@node Dégradé
@subsection Dégradé
@cindex Dégradé

@image{manual_images_intl/gradient,12.5mm}

FIXME

@c cincvdoc_node_number_184
@node Histogramme
@subsection Histogramme
@cindex Effet histogramme

@image{manual_images_intl/histogram,12.5mm}

Il permet d'afficher le nombre d'occurrences de chaque couleur sur un graphique
d'histogramme.

Le calcul est toujours effectué en RVB virgule flottante indépendamment de
l'espace colorimétrique du projet.  L'histogramme comporte deux jeux de
paramètres de @w{transfert :} le transfert en entrée et le transfert en sortie.

4 histogrammes sont possibles dans le visualisateur d'histogramme.  Les
histogrammes rouge, vert et bleu affichent les histogrammes en entrée pour les
canaux rouge, vert et bleu en les multipliant par une fonction de transfert
d'entrée afin d'obtenir les sorties rouge, verte et bleue.  Les valeurs bleue,
verte et rouge mises à l'échelle sont convertie en une valeur qui est affichée
sur l'histogramme des valeurs.  L'histogramme des valeurs est alors modifié en
fonction des paramètres du rouge, du vert et du bleu.  Les transferts de
valeurs sont appliqués uniformément à R, V et B après que les transferts de
couleurs aient été appliqués.

Sélectionnez quel transfert afficher en sélectionnant l'un des canaux en haut
de l'histogramme.

Le transfert d'entrée est défini par un graphique superposé à l'histogramme.
L'axe horizontale correspond à toutes les valeurs possible de la couleur
d'entrée.  L'axe vertical correspond aux couleurs de sorties de chaque couleur
d'entrée.  La vidéo qui entre dans l'histogramme est d'abord affichée sur
l'histogramme, et ensuite elle est transformée de manière à ce que les valeurs
des couleurs de sortie soient égales aux valeurs de sortie correspondant à
chaque valeur sur le graphique d'entrée.

Le graphique d'entrée est édité en ajoutant et en supprimant un nombre
quelconque de points.  Cliquez et glissez n'importe où dans le graphique pour
créer un point et le déplacer.  Cliquez sur un point existant pour le rendre
actif et le déplacer.  Le point actif est toujours marqué par son remplissage.
Les couleurs d'entrée et de sortie du point actif sont indiquées dans des
boîtes de texte en haut de la fenêtre.  Les couleurs d'entrée et de sortie du
point peuvent être modifiées à l'aide de ces boîtes de texte.

Les points peuvent être supprimés en sélectionnant d'abord un point et en le
glissant de l'autre côté d'un point adjacent.  Ils peuvent aussi être supprimés
en les sélectionnant et en pressant @b{Suppr}.

Après le transfert d'entrée, l'image est traitée par le transfert de sortie.
Le transfert de sortie est simplement un minimum et un maximum pour mettre à
l'échelle correspondante les couleurs d'entrée.  Les valeurs d'entrée de 0%
sont remontées à la valeur du minimum en sortie.

Les valeurs en entrée en-dessous de 0 sont toujours alignées à 0 et les valeurs
au-dessus de 100% sont toujours alignées à 100%.  Cliquez et glissez les
triangles des dégradés de sortie afin de les modifier.  Les boîtes de texte
permettent aussi d'entrer directement des valeurs.

Cochez la case @b{Automatique} afin que l'histogramme calcule un transfert
automatique pour le rouge, le vert et le bleu mais pas la valeur.  Il fait une
mise à l'échelle pour que les 99% de pixels du milieu occupent 100% de la
largeur de l'histogramme.  Le nombre de pixels autorisés à passer au travers de
l'effet filtre est défini par la boîte de texte @b{Seuil}.  Un seuil de 0.99
redimensionne l'entrée de manière à ce que 99% des pixels passent au travers.
Des seuils plus faibles permettent à moins de pixels de passer au travers et
rendent la sortie plus contrastée.  Le transfert automatique d'entrée est
calculé pour les canaux R, V et B mais pas pour la valeur.@*
@b{Afficher l'histogramme}@*
@b{Diviser la sortie}

@c cincvdoc_node_number_185
@node TV holographique
@subsection TV holographique
@cindex TV holographique

@image{manual_images_intl/holo,16.25mm}

De Kentarou effectTV

@c cincvdoc_node_number_186
@node Teinte/Saturation
@subsection Teinte/Saturation
@cindex Teinte/Saturation
@cindex Saturation

@image{manual_images_intl/huesaturation,12.5mm}

Avec cet effet, vous pouvez modifier la teinte, la saturation et la valeur.
Les paramètres sont modifiés en utilisant 3 simples curseurs.

@c cincvdoc_node_number_187
@node Interpoler la vidéo
@subsection Interpoler la vidéo
@cindex Interpoler la vidéo

@image{manual_images_intl/interpolatevideo,13.25mm}

FIXME

@c cincvdoc_node_number_188
@node Interpoler les pixels
@subsection Interpoler les pixels
@cindex Interpoler les pixels

@image{manual_images_intl/interpolate,12.5mm}

L'effet d'interpolation des pixels essaie de créer l'illusion d'une fréquence
d'images plus élevée depuis un métrage ayant une fréquence d'images très
faible, en effectuant la moyenne au cours du temps.  Pour chaque image de
sortie, il effectue la moyenne entre deux images en entrée.  Les images en
entrée sont prises à des instants différents ce qui provoque un fondu pour
chacune des images de sortie se trouvant entre deux images en entrée.  Il y a
deux manières d'indiquer les images en entrée.  Vous pouvez indiquer une
fréquence d'images d'entrée qui soit plus faible que celle du projet.  Ceci
permet de prendre les images en entrée à des intervalles réguliers.  Vous
pouvez indiquer une fréquence d'images en entrée qui soit inférieure à la
fréquence des images du projet.  Ceci permettra de prendre les images en entrée
à intervalle régulier.

Vous pouvez aussi indiquer des emplacements d'images-clés comme positions des
images d'entrée.  Dans ce mode, la fréquence des images en sortie est utilisée
comme fréquence d'entrée et vous n'avez qu'à créer des images-clés aux
emplacements où vous désirez indiquer une image d'entrée.

@c cincvdoc_node_number_189
@node Télécinéma inverse
@subsection Télécinéma inverse
@cindex Effet de télécinéma inverse

@image{manual_images_intl/ivtc,12.5mm}

C'est l'outil de désentrelacement le plus efficace lorsque le métrage est un
transfert vidéo de film.  Dans ce cas, le film a été converti de 24 im/s vers
60 trames/s (pour la norme NTSC, en PAL, il s'agit de 50 trames/s).  Ensuite
les 60 trames/s (respectivement 50) sont rééchantillonnées vers 30 im/s
(respectivement 25) en extrayant les lignes paires et impaires, et en
entrelaçant les lignes.  L'effet IVTC (Téléciméma inverse) est d'abord un moyen
de convertir de la vidéo entrelacée en vidéo progressive.  Il défait trois
motifs d'entrelacement.@*
@code{A AB BC CD D}@*
@code{AB CD CD DE EF}@*
@code{Automatique}

Les deux premières options sont des motifs fixes et sont affectées par les
paramètres de @b{décalage de motif} et de @b{champs impairs d'abord}.  Cette
dernière option crée plusieurs combinaisons de lignes pour chaque trame et
prend la combinaison la plus progressive.  C'est un algorithme de force brute.

Cette technique ne repose pas sur un motif comme pour les autres techniques et
elle est moins destructive mais le déroulement du temps peut être un peu
saccadé en raison de l'absence de réduction de la fréquence des images.  Pour
lisser le déroulement dans le temps, il faut faire suivre l'effet de télécinéma
inverse d'un effet de décimation.

@c cincvdoc_node_number_190
@node Inverser la vidéo
@subsection Inverser la vidéo
@cindex Inverser la vidéo

@image{manual_images_intl/invertvideo,12.5mm}

Appelé aussi vidéo inverse, c'est une méthode pour inverser les couleurs d'une
piste vidéo.

Les quatre paramètres sont les canaux (Rouge, Bleu, Vert, Alpha)

@c cincvdoc_node_number_191
@node Flou linéaire
@subsection Flou linéaire
@cindex Flou linéaire

@image{manual_images_intl/linearblur,12.5mm}

Le flou possède trois @w{styles :} Linéaire, Radial et Zoom

Les paramètres sont :
@itemize @bullet
@item @b{Distance}@*
Distance entre l'image d'origine et l'étape finale du flou.
@item @b{Angle}@*
Angle de déplacement, pour le flou linéaire
@item @b{Pas}@*
Nombre de niveaux de flou
@item @b{Canaux}@*
Canaux à rendre flous.
@end itemize

@node Vidéo en direct
@subsection Vidéo en direct
@cindex Effet de vidéo en direct

@image{manual_images_intl/livevideo,12.5mm}

Cet effet lit directement la vidéo depuis la carte d'acquisition.  Il remplace
toute la vidéo de la piste, et est donc normalement appliqué sur une piste
vierge.  La configuration de la carte d'acquisition est prise depuis les
préférences de l'acquisition.  Allez à
@b{Configuration->Préférences->Acquisition} pour configurer votre carte
d'acquisition.

Allez à la section @b{Entrée vidéo} où l'on trouve le @b{Pilote
d'enregistrement}.  Il doit être défini soit à @b{Video4Linux2}, soit à @b{IEC
61883}.  Les autres pilotes vidéo n'ont pas été testés avec la vidéo en direct
et ne fonctionneront probablement pas.

Pour la vidéo en direct, le @b{Format de fichier} et la @b{Vidéo} doivent avoir
des valeurs que la timeline peut utiliser.  Le format de fichier doit être
@b{Quicktime pour Linux} et l'enregistrement vidéo doit être activé pour ce
format.  Cliquez sur la @image{manual_images_intl/wrench,4.33mm} clé afin de
déterminer la compression vidéo.

La compression vidéo dépend du pilote d'enregistrement.  Pour le pilote
d'enregistrement @b{Video4Linux2}, La compression doit être @b{JPEG animé A}.
Pour le pilote @b{IEC 61883}, la compression doit être @b{DV}.  Le pilote va
générer une sortie dans un modèle colorimétrique que la timeline peut utiliser.

Certaines cartes autorisent le paramétrage de la couleur et des canaux.  La
vidéo en direct prend les paramètres de couleur depuis les valeurs définies
dans la fenêtre @b{Entrée vidéo}.  Allez à @b{Fichier->Acquisition} afin
d'afficher l'interface d'enregistrement et la fenêtre d'@b{Entrée vidéo}.  Les
valeurs définies dans la fenêtre @b{Entrée vidéo} sont utilisées par @b{Vidéo
en direct}.  Tous les canaux que gère la carte d'acquisition doivent être
configurés dans l'interface @b{Entrée vidéo} car ces mêmes canaux sont utilisés
par l'effet @b{Vidéo en direct}.

Lorsque l'acquisition vidéo est configurée, mettez en surbrillance une région
de la piste vidéo ou définissez les points d'entrée et de sortie.  Déposez-y
alors l'effet de vidéo en direct.  Déposez les autres effets après l'effet
vidéo en direct de façon à ce que ce dernier soit traité en temps réel.  Afin
d'obtenir les meilleurs résultats, vous devriez utiliser OpenGL et une carte
vidéo qui permet la gestion du langage d'ombrage GL@.  Allez à
@b{Configuration->Préférences->Lecture->Sortie vidéo} pour activer le pilote
OpenGL.

Un seul effet @b{Vidéo en direct} peut exister à un moment donné sur la
timeline.  Il ne peut pas être partagé avec plus d'une piste.

@c cincvdoc_node_number_193
@node Boucle vidéo
@subsection Boucle vidéo
@cindex Effet de boucle vidéo

@image{manual_images_intl/loopvideo,12.5mm}

Des sections de vidéo peuvent être bouclées en y déposant l'effet de @b{boucle}
Au contraire de l'option @b{Configuration->Jouer en boucle}, l'effet de boucle
peut être rendu alors que l'option @b{Configuration->Jouer en boucle} ne le
peut pas.  L'effet de boucle est pratique pour de courtes régions.

L'effet de boucle comporte une @w{option :} le nombre d'@b{images} ou
d'@b{échantillons} à reboucler.  Ceci permet d'indiquer la durée de la région à
boucler en partant soit du début de l'effet, soit de la dernière image-clé.  La
région est répliquée pour la durée complète de l'effet.

Chaque fois qu'une image-clé est placée dans un effet de boucle, l'image-clé
devient le début de la région à boucler.  Placer plusieurs images-clés
successivement provoque le rebouclage de plusieurs régions.  Placer une seule
image-clé fait reboucler la région située après l'image-clé pour la durée de
l'effet, indépendamment de l'emplacement de l'image-clé.  La fin de l'effet
peut être rebouclée depuis le début en plaçant une image-clé près de la fin.

@c cincvdoc_node_number_194
@node Suivi de mouvement
@subsection Suivi de mouvement
@cindex Effet de suivi de mouvement

@image{manual_images_intl/motion,12.5mm}

Le suivi de mouvement est presque une application à lui tout seul.  Le suivi de
mouvement permet de suivre deux types de @w{mouvements :} la translation et la
rotation.  Ils peuvent être suivis tous deux simultanément ou bien uniquement
l'un d'entre-eux.  Il peut faire du suivi par 1/4 de pixel ou par pixel.  Il
peut stabiliser le mouvement ou faire qu'une piste suive le mouvement d'une
autre.

Bien que le suivi de mouvement soit appliqué comme un effet en temps réel, il
doit habituellement être rendu pour se rendre compte des résultats.  Cet effet
prend beaucoup de temps pour détecter précisément le mouvement.

Le moteur de suivi de mouvement fonctionne en utilisant une région de l'image
comme région à suivre.  Il compare cette région entre deux images pour en
calculer le déplacement.  Cette région peut être définie n'importe où sur
l'écran.  Une fois que le mouvement entre deux images a été calculé, un certain
nombre de choses peut être effectuées avec ce vecteur de mouvement.  Il peut
être mis à l'échelle en utilisant une valeur définie par l'utilisateur et
tronqué à une valeur maximale.  Il peut être ignoré ou accumulé avec tous les
vecteurs de mouvement qui le précèdent jusqu'à la position actuelle.

Pour gagner du temps, le résultat du suivi de mouvement peut être enregistré
pour être réutilisé plus tard, rappelé d'un précédent calcul ou bien détruit.

Le moteur de suivi de mouvement possède la notion de deux pistes, le niveau
maître et la piste de destination.  Le niveau maître est l'endroit où se fait
la comparaison entre deux images.  La piste de destination est l'endroit où le
mouvement est appliqué soit pour suivre, soit pour compenser les mouvements du
niveau maître.

La complexité du suivi de mouvements est suffisante pour faire vivre des
sociétés entières et pour y construire sa carrière.  Le suivi de mouvement de
Cinelerra n'est pas aussi sophistiqué que certains logiciels de suivi de
mouvement de renommée mondiale, mais il est suffisant pour améliorer certaines
prises de vue au caméscope.

Voici une brève description des paramètre du suivi de @w{mouvement :}

@itemize @bullet

@item @b{Suivre la translation}@*
Active les opérations relatives aux mouvements de translation.  Le moteur
de suivi recherche les mouvements selon les axes X et Y du niveau maître et
ajuste le mouvement selon les axe X et Y dans le niveau de destination.

@cindex Effet de suivi de mouvement, bloc de translation
@cindex Bloc de translation
@item @b{Taille du bloc de translation}@*
Pour les opérations de translation, un bloc est comparé à un certain nombre de
blocs voisins pour rechercher celui qui comporte le moins de différences.  La
taille de bloc à rechercher est donnée par ce paramètre.

@item @b{Rayon de recherche pour la translation}@*
C'est la taille de la zone à examiner pour le bloc de translation.

@item @b{Nombre de pas de recherche pour la translation}@*
Idéalement, les opérations de recherche devraient comparer le bloc de
translation avec chaque autre pixel se trouvant dans le rayon de recherche.
Pour accélérer les opérations, la recherche est faite dans un sous-ensemble des
positions possibles.  Ensuite, la zone de recherche est réduite et analysée de
nouveau avec le même nombre de pas jusqu'à ce que le déplacement soit connu
avec une précision de 1/4 pixel.

@item @b{X, Y du bloc}@*
Ces coordonnées définissent le centre du bloc de translation basé sur des
pourcentages de la largeur et de la hauteur de l'image.  Le centre du bloc
devrait être compris dans une partie de l'image qui est toujours visible.

@item @b{Décalage maximum absolu}@*
La valeur du mouvement détecté par le moteur de suivi de mouvement est
illimitée si cette valeur est de 100.  Si elle est inférieure à 100, la valeur
de mouvement est limitée par ce pourcentage des dimensions de l'image.

@item @b{Vitesse d'établissement}@*
Le mouvement détecté entre chaque image peut être accumulé sous forme d'un
vecteur de mouvement absolu.  Si la vitesse d'établissement est de 100, le
vecteur absolu est ajouté à l'image suivante.  Si la vitesse d'établissement
est inférieure à 100, le vecteur absolu est réduit par cette valeur avant
d'être ajouté à l'image suivante.

@item @b{Suivre la rotation}@*
Activer les opérations relatives aux mouvements rotation.  Le moteur de suivi
recherche la rotation dans le niveau maître et ajuste la rotation dans la
piste cible.

@item @b{Taille de bloc pour la rotation}@*
Pour les opérations de rotation, un seul bloc est comparé à des blocs de même
dimension, chacun étant pivoté d'une valeur différente.  Ceci est la taille des
blocs de rotation.

@item @b{Rayon de recherche pour la rotation}@*
C'est l'angle de rotation maximum à partir de l'image de départ que le moteur
d'analyse peut détecter.  L'analyse en rotation commence à cet angle dans le
sens anti-horaire jusqu'à cet angle dans le sens horaire.  Le rayon de
recherche indiqué ici est donc la moitié de la plage totale qui sera analysée.

@item @b{Nombre de pas de recherche pour la rotation}@*
Idéalement, tous les angles possibles devraient être testés pour obtenir la
rotation.  Pour accélérer la recherche de la rotation, le rayon pour la
recherche de la rotation est divisé en un nombre fini d'angles et seuls ces
angles seront comparés avec l'image de départ.  Ensuite, le rayon de recherche
sera diminué et un même nombre d'angles sera comparé avec le plus petit rayon
jusqu'à ce que la plus grande précision possible soit atteinte.@*
Normalement, vous avez besoin d'un pas de recherche pour chaque degré parcouru.
Comme le moteur de recherche de la rotation parcourt le rayon de recherche dans
les deux sens, pour pouvoir d'effectuer la recherche sur toute la plage vous
avez besoin de deux pas pour chaque degré de rayon de recherche.

@item @b{Dessiner les vecteurs}@*
Lorsque la translation est activée, 2 boîtes sont dessinées sur l'image.  Une
des boîtes représente le bloc de translation, l'autre boîte, en-dehors du bloc
de translation, représente l'étendue du rayon de recherche en translation.  Au
centre de ces boîtes figure une flèche indiquant la translation entre les deux
images principales.@*
Lorsque la rotation est activée, une seule boîte de la taille du bloc de
rotation est dessinée, pivotée de la valeur de la rotation détectée.

@item @b{Suivre une seule image}@*
Lorsque cette option est utilisée, le déplacement entre une seule image de
départ et l'image actuellement sous le point d'insertion est calculée.  L'image
de départ est précisée dans l'emplacement @b{numéro d'image}.  Le mouvement
calculé de cette manière est pris comme vecteur de mouvement absolu.  Le
vecteur de mouvement absolu de chacune des images remplace le vecteur de
mouvement absolu de l'image précédente.  La vitesse d'établissement n'a pas
d'action sur lui car il ne comporte aucun vecteur de déplacement précédent.  La
lecture peut commencer n'importe où sur la timeline puisqu'il n'y a aucune
dépendance avec des résultats antérieurs.

@item @b{Suivre l'image précédente}@*
Le calcul du mouvement ne sera effectué qu'entre l'image précédente et l'image
en cours.  Ceci est ajouté à un vecteur de mouvement absolu de façon à obtenir
le nouveau mouvement depuis le début de la séquence jusqu'à la position
actuelle.  Après le traitement de chaque image, la position du bloc est décalée
de façon à toujours couvrir la même région de l'image.  La lecture doit être
faite depuis le début de l'effet de mouvement de façon à accumuler tous les
vecteurs de mouvement nécessaires.

@item @b{Image précédente du même bloc}@*
Ceci est utile pour stabiliser la vidéo issue d'un camescope non stabilisé.
Dans ce mode, le mouvement entre l'image en cours et l'image précédente est
calculé.  Au lieu d'ajuster la position du bloc pour refléter la nouvelle
position de l'image, comme le fait @b{Suivre l'image précédente}, la position
du bloc reste inchangée entre les deux images.  Donc une nouvelle région est
comparée pour chaque image.

@item @b{Niveau maître}@*
Ceci détermine la piste qui procure l'image de départ et l'image finale pour
les calculs de mouvement.  S'il est positionné à @b{Bas}, la piste la plus
basse de toutes celles qui partagent cet effet sera le niveau maître, la piste
qui se trouve au-dessus des autres sera le niveau cible.  S'il est positionné à
@b{Haut}, la piste la plus haute de toutes celles qui partagent cet effet sera
le niveau maître, la piste qui se trouve au-dessous des autres sera le niveau
cible.

@item @b{Calcul}@*
Ceci détermine s'il faut calculer le déplacement et sous quelle forme
l'enregistrer sur le disque.  S'il est positionné à @b{Ne pas calculer}, le
calcul de déplacement est omis.  S'il est positionné à @b{Recalculer}, le
calcul de mouvement est effectué chaque fois qu'une image est calculée.  S'il
est positionné à @b{Enregistrer}, le calcul du déplacement est toujours
effectué et, en plus, une copie en est aussi enregistrée.  S'il est positionné
à @b{Charger}, le calcul du mouvement est chargé depuis le résultat d'un calcul
précédemment enregistré.  S'il n'y a pas de résultat précédent sur le disque,
un nouveau calcul est effectué.

@item @b{Action}@*
Une fois que le vecteur de mouvement est connu, l'action détermine s'il faut déplacer
la piste de destination dans la direction opposée au mouvement ou s'il faut suivre
le vecteur de mouvement.  Si c'est @b{Ne rien faire}, la piste de destination est
laissé inchangée.  Si c'est @b{Piste...}, la piste de destination est déplacée de la
même valeur que le niveau principal.  C'est utile pour faire correspondre des titres
à des objets sur l'image.  Si c'est @b{Stabiliser...}, le niveau de destination est
déplacé dans la direction opposée au vecteur de mouvement.  C'est utile pour stabiliser
un objet dans l'image.  Les opérations de mouvement peuvent être précises au pixel
ou au sous-pixel près en modifiant les paramètres de l'action.
@end itemize

@menu
* Les secrets du suivi de mouvement::
* Suivi de mouvement en deux passes::
* Utiliser le flou pour améliorer le suivi de mouvement::
* Utiliser l'histogramme pour améliorer le suivi de mouvement::
* Le suivi de mouvement en action::
* La stabilisation en action::
@end menu

@c cincvdoc_node_number_195
@node Les secrets du suivi de mouvement
@subsubsection Les secrets du suivi de mouvement
@cindex Les secrets du suivi de mouvement
@cindex Suivi de mouvement, les secrets du

Comme c'est un effet très long à calculer, il y a une méthode pour appliquer le
suivi de mouvement de façon à en obtenir le maximum.  Désactivez tout d'abord
la lecture pour la piste sur laquelle vous voulez utiliser le suivi de
mouvement.  Déposez ensuite l'effet sur une région de la vidéo où se trouve un
certain mouvement à suivre.  Replacez ensuite le point d'insertion au début de
cette région.  Configurez @b{Action->Ne rien faire}.  Configurez @b{Calcul->Ne
pas calculer}.  Activez @b{Dessiner les vecteurs}.  Activez ensuite la lecture
de la piste pour voir les zones de suivi de mouvement.

Activez le type de vecteur de mouvement que vous désirez suivre, soit le
@b{mouvement de translation}, soit le @b{mouvement de rotation}.  En visionnant
la fenêtre de composition et en ajustant les paramètres @b{x, y du bloc},
centrez le bloc sur la partie de l'image que vous désirez suivre.  Ensuite,
configurez le rayon de recherche, la taille du bloc et les coordonnées du bloc
pour la translation et la rotation.

Une fois tout ceci configuré, configurez le calcul à @b{Enregistrer les
coordonnées} et faites des passes de tests sur la séquence pour voir si le
suivi de mouvement fonctionne et pour enregistrer les vecteurs de mouvement.
Une fois ceci effectué, désactivez la lecture de la piste, désactivez
@b{Dessiner les vecteurs}, configurez l'action désirée concernant le mouvement
sur la piste de destination et changez le calcul en @b{Charger les
coordonnées}.  Enfin, activez la lecture de la piste.

Lorsque vous utilisez une seule image pour calculer le mouvement d'une
séquence, l'image de départ devrait être une image unique présentant le moins
de mouvement qu'une quelconque des autres images.  C'est rarement le cas de
l'image 0.  Habituellement, il faut prendre une image vers le milieu de la
séquence.  De cette manière le rayon de recherche n'a besoin que de couvrir la
moitié de l'ensemble du mouvement de la séquence.

Si le suivi de mouvement est utilisé avec une grappe de calcul, @b{Enregistrer
les coordonnées} et @b{Image précédente} ne fonctionnera pas.  Les résultats de
l'opération d'enregistrement des coordonnées sont enregistrés sur les disques
des noeuds de rendu, et non pas sur le noeud principal.  Les opérations de
rendu ultérieures effectuées sur ces noeuds traiteront des images différentes
et liront les mauvaises coordonnées depuis le système de fichiers du noeud.  Le
fait que les noeuds de rendu ne visualisent qu'une portion de la timeline
empêche aussi l'@b{image précédente} de fonctionner car elle dépend du calcul
d'un vecteur de mouvement absolu ayant l'image 0 comme point de départ.

@c cincvdoc_node_number_196
@node Suivi de mouvement en deux passes
@subsubsection Suivi de mouvement en deux passes
@cindex Suivi de mouvement en deux passes
@cindex Suivi de mouvement, deux passes

La méthode ci-dessus décrit le processus de suivi de mouvement en deux passes.
Une passe est utilisée pour calculer les vecteurs de mouvement.  Une seconde
passe est utilisée pour appliquer les vecteurs de mouvement à la vidéo.  C'est
plus rapide qu'une unique passe car les erreurs de calculs des vecteurs de
mouvement peuvent être rapidement découvertes.

Ceci permet aussi au suivi de mouvement d'utiliser un modèle colorimétrique
moins exigeant comme RVB888 dans la phase d'examen, et un modèle colorimétrique
plus exigeant comme RVB flottant dans la phase d'action.  La phase d'examen
prend beaucoup plus de temps que la phase d'action.

Cette méthode a le désavantage de ne pas être pratique pour de très longues
séquences, où il est acceptable d'avoir un certain niveau d'erreur, et que la
qualité de l'image est faible au départ comme c'est le cas pour la
stabilisation d'images issues d'un caméscope.

La méthode la plus lente est de calculer les vecteurs de mouvement et de les
appliquer simultanément.  Cette méthode peut utiliser une piste comme piste de
calcul des vecteurs de mouvement et une autre piste comme piste de destination
pour les actions des vecteurs de mouvement.  C'est utile pour de longues
séquences ou il est acceptable d'avoir un certain niveau d'erreur.

@c cincvdoc_node_number_197
@node Utiliser le flou pour améliorer le suivi de mouvement
@subsubsection Utiliser le flou pour améliorer le suivi de mouvement
@cindex Flou, suivi de mouvement
@cindex Suivi de mouvement, amélioration par utilisation du flou

Pour les vidéos très bruités ou entrelacés, l'application d'un effet de flou
avant le suivi de mouvement peut en améliorer la précision.  Vous pouvez soit
enregistrer les vecteurs de mouvement dans une @b{passe de suivi} et désactiver
le flou dans la @b{passe d'action}, soit n'appliquer le flou qu'au @b{calque
maître}.

@c cincvdoc_node_number_198
@node Utiliser l'histogramme pour améliorer le suivi de mouvement
@subsubsection Utiliser l'histogramme pour améliorer le suivi de mouvement
@cindex Suivi de mouvement, utilisation de l'histogramme
Un histogramme est presque toujours appliqué avant le suivi de mouvement pour
atténuer le bruit généré par les pixels les plus sombres.  Vous pouvez soit
enregistrer les vecteurs de mouvement dans une @b{passe de suivi} et désactiver
histogramme pour la @b{passe d'action}, soit n'appliquer l'histogramme qu'au
@b{calque maître}.

@c cincvdoc_node_number_199
@node Le suivi de mouvement en action
@subsubsection Le suivi de mouvement en action
@cindex Le suivi de mouvement en action

Ajouter d'abord un effet de suivi de mouvement à la piste.  Glissez-le depuis
la fenêtre des ressources et déposez-le directement sur la vidéo dans la
fenêtre principale de Cinelerra.  Vous devriez voir quelque chose de semblable
à @w{ceci :}

@center @image{manual_images_intl/cin_timeline_eff_clip,90mm}

Faites ensuite un clic droit sur le marqueur de l'effet de suivi de mouvement
sur la timeline et sélectionnez @b{Afficher les options} afin d'afficher le
dialogue du suivi de @w{mouvement :}

@center @image{manual_images_intl/cin_motion_win,90mm}

Commencez par regarder dans votre compositeur.  Vous verrez quelques nouvelles
boîtes dessinée par dessus la vidéo.  Elles sont importantes pour contrôler le
suivi de mouvement.  Voici un bref aperçu de ce que l'on peut voir lors du
@w{fonctionnement :}

@center @image{manual_images_intl/cin_comp_action_small,90mm}

L'image çi-dessus montre le suivi de mouvement ayant perdu l'objet suivi car la
fenêtre de recherche est trop petite.  Nous reviendrons sur cet aspect plus
tard, mais @w{rapidement :}@*
@itemize @bullet
@item La petite boîte du milieu est la cible du moteur de suivi.
@item La boîte plus grosse au milieu est la plage de recherche du moteur de
suivi.  Elle devrait contenir l'ensemble de la plage de mouvement de la cible
de recherche.
@item Dans cet exemple, nous essayons de suivre les poignées de maintien.  Nous
avons échoué dans cette image vidéo, parce que les poignées se trouvent trop
loin du centre de l'image.
@item Le vecteur dirigé vers la gauche indique que le moteur de suivi tente de
rechercher la cible.  Nous en dirons davantage sur ce point plus tard.
@end itemize

Déplacez-vous au début de votre clip vidéo

Assurez-vous que le dialogue du suivi de mouvement est ouvert

Regardez dans le compositeur

Commencez à ajuster ces quatre @w{boutons :}

@center @image{manual_images_intl/cin_motion_track,90mm}

Cochez le suivi en translation

Décochez le suivi de rotation

Commencez avec le deuxième bouton - Taille de bloc pour la translation - et
tournez-le pour avoir une idée de ce qui change.  Remarquez que les deux boîtes
sont redimensionnées.  Regardez ce qui se trouve à l'intérieur de la petite
boîte (l'objet que vous désirez suivre).  Ne vous inquiétez pas si elle ne
recouvre pas encore l'objet.

Passez aux boutons trois et quatre : X et Y du bloc.  Utilisez-les pour placer
le désignateur de la cible sur la cible elle-même.

Enfin, utilisez le bouton du haut : Rayon de recherche en translation.
Agrandissez ce rayon de manière à ce qu'il recouvre la plage entière de
déplacement que vous attendez de la cible.  Si vous regardez de nouveau la
première vue de l'action, le rayon de recherche était trop faible et la cible
s'est déplacée en dehors de la plage.  Vous pouvez le tester en effectuant une
lecture de la timeline et en regardant les résultats (en temps réel si votre
machine est assez rapide) ou en effectuant le rendu et en visionnant votre
poignée stabilisée sur la sortie.

Faites le nécessaire pour que la première image de la vidéo ressemble à @w{ceci
:}

@center @image{manual_images_intl/cin_comp_first_setup_small,90mm}

Cette image montre beaucoup de détails.  Remarquez que le petit cadre est
centré sur la poignée et dimensionné de manière à juste l'inclure.  Ces
paramètres sont contrôlés par les boutons deux à quatre.  Enfin, le cadre
extérieur doit être plus grand que les mouvement en avant et arrière de la
poignée sur la durée complète du clip vidéo.

Enfin, voici les autres paramètres nécessaires pour voir @w{l'effet :}

@center @image{manual_images_intl/cin_motion_set_output1,90mm}

@itemize @bullet
@item @b{Dessiner les vecteurs} Décochez cette option afin d'éviter le rendu
des boîtes cibles et des vecteurs de mouvement dans votre vidéo finale.  Si
cette case est cochée, les vecteurs et les boîtes seront rendus dans la vidéo
en sortie.
@item @b{Suivre une seule image} Dans cet exemple, il est positionné au numéro
d'image 0 (première image)
@item @b{Calque maître} Si l'effet est partagé entre deux pistes, il indique
laquelle de ces pistes sera celle pour laquelle le mouvement sera suivi (piste
maître) et quel piste sera affectée par la translation résultante (piste
cible).  S'il n'y a pas de seconde piste partageant le mouvement, alors
Maître=Cible.
@item @b{Action} Sélectionnez les options de stabilisation pour que votre vidéo
suive les mouvements de la cible.  Sélectionnez une option de suivi qui
permette le suivi de mouvement sans ajuster la vidéo.
@item @b{Calcul}
@itemize @bullet
@item @b{Ne pas calculer} Sélectionnez cette option pour désactiver
l'ajustement de la vidéo.
@item @b{Recalculer} Effectuer le suivi de mouvement et mettre à jour la vidéo
en fonction des paramètres d'action.
@item @b{Enregistrer et charger} Enregistre/Charge les vecteurs de
translation/rotation (absolus ou relatifs) de/vers des fichiers.  Chaque image
crée un fichier séparé contenant son vecteur dans le répertoire @file{/tmp}.

@end itemize
@end itemize

@c cincvdoc_node_number_200
@node La stabilisation en action
@subsubsection La stabilisation en action
@cindex La stabilisation en action

Dans cette section, nous expliquerons comment stabiliser une vidéo.  On peut
avoir ce besoin lorsque la vidéo est prise depuis un véhicule par exemple.

Sélectionnez d'abord sur la timeline la partie de la vidéo que vous désirez
stabiliser en utilisant les points d'entrée et de sortie.  Appliquez ensuite
l'effet de stabilisation de mouvement sur cette partie de la vidéo.

Sélectionnez l'option @b{image précédente du même bloc}.  Cette option est
recommandée pour stabiliser un vidéo tremblotante issue d'un caméscope.  Son
but n'est pas de "suivre" un objet.  Le bloc reste exactement à la même
place durant toute la durée de l'effet.

Agrandissez le bloc et sélectionnez à peu près la moitié des dimensions de la
vidéo.  Sélectionnez l'option @w{@b{Stabiliser les sous-pixels} :} elle donnera
une stabilisation plus précise.  Réduisez la valeur du @b{décalage absolu
maximum} pour limiter l'amplitude de la stabilisation.  Vous préférerez
probablement avoir une stabilisation imparfaite à certains moments de la vidéo
plutôt que d'avoir de grandes bordures noires sur les côtés de l'image lors des
secousses importantes.  Configurez le @b{Nombre de pas de recherche en
translation} à 128.  Augmenter cette valeur ne donnera pas un meilleur
résultat, mais augmentera de manière considérable le temps de rendu.
Assurez-vous que l'option @b{Dessiner les vecteurs} est sélectionnée, et
effectuez le rendu de la partie de la vidéo où l'effet de suivi de mouvement a
été appliqué.

Si le résultat est bon, désactivez l'option @b{Dessiner les vecteurs}.  Les
blocs et les vecteurs ne seront plus affichés sur la vidéo.  Effectuez alors le
rendu de la vidéo vers un fichier @file{.dv}, et importez-le dans votre projet.

Vous remarquerez que la vidéo est stabilisée mais qu'il y a des bordures noires
qui apparaissent sur les côtés des images.  Afin de supprimer ces bordures
noires, vous devrez effectuer un zoom et définir des images-clés de projecteur
pour déplacer celui-çi sur l'image.  Plus votre vidéo est sautillante, plus
vous devrez zoomer pour supprimer les bordures noires.  C'est pourquoi le
résultat est meilleur avec une vidéo HDV qu'avec une vidéo DV@.

@c cincvdoc_node_number_201
@node Flou de mouvement
@subsection Flou de mouvement
@cindex Flou de mouvement

@image{manual_images_intl/motionblur,12.5mm}

FIXME

@c cincvdoc_node_number_202
@node Peinture à l'huile
@subsection Peinture à l'huile
@cindex Peinture à l'huile
@cindex Peiture, huile

@image{manual_images_intl/oilpainting,12.5mm}

Cet effet donne à vos pistes vidéos un aspect de peinture à l'huile.  Il est
contrôlé par le curseur de rayon.  Les couleurs peuvent être choisies en
option.

@c cincvdoc_node_number_203
@node Overlay video
@subsection Overlay video
@cindex Overlay video

@image{manual_images_intl/overlay,13.25mm}

FIXME

@c cincvdoc_node_number_204
@node Perspective
@subsection Perspective
@cindex Perspective

@image{manual_images_intl/perspective,12.5mm}

L'effet de perspective vous permet de modifier la perspective d'un objet, il
est parfait pour donner un effet de distance aux objets.

@c cincvdoc_node_number_205
@node Polaire
@subsection Polaire
@cindex Polaire

@image{manual_images_intl/polar,12.5mm}

L'effet polaire courbe et enroule votre vidéo de manière étrange.
Mathématiquement, il convertit votre vidéo de coordonnées polaires en
coordonnées rectangulaires ou inversement.

@c cincvdoc_node_number_206
@node RVB-601
@subsection RVB-601
@cindex RVB-601

FIXME

@image{manual_images_intl/rgb601,12.5mm}

@c cincvdoc_node_number_207
@node Flou radial
@subsection Flou radial
@cindex Flou radial

@image{manual_images_intl/radialblur,12.5mm}

Il crée un flou en tourbillon qui simule une caméra faisant des tourbillons.
Vous pouvez modifier l'emplacement, le type et la qualité du flou.

@c cincvdoc_node_number_208
@node ReframeRT
@subsection ReframeRT
@cindex Effet vidéo ReframeRT

@image{manual_images_intl/reframert,12.5mm}

ReframeRT modifie le nombre d'images dans une séquence vidéo directement depuis
la timeline.  Il fonctionne selon deux modes qui peuvent être activés depuis
l'interface graphique à l'aide de deux cases à cocher.@*

Le mode @b{Etirer} multiplie le numéro de l'image en cours sur sa sortie par un
facteur d'échelle pour obtenir le numéro d'image à lire sur son entrée.  Si la
sortie actuelle est l'image n° 55 et que le facteur d'échelle est de 2, l'image
n° 110 est lue depuis l'entrée.  Le mode @b{Etirer} a pour effet de modifier la
durée de la sortie vidéo par l'inverse du facteur d'échelle.  Si le facteur
d'échelle est plus grand que 1, la sortie se terminera avant la fin de la
séquence qui se trouve sur la timeline.  S'il est inférieur à 1, la sorti se
terminera après la fin de la séquence sur la timeline.  L'effet ReframeRT doit
être allongé jusqu'à la durée nécessaire pour obtenir le facteur d'échelle.  On
modifie la durée de l'effet en cliquant sur l'endroit où se termine l'effet et
en le glissant.

Bien que que l'effet d'étirement modifie le numéro de l'image lue sur son
entrée, il ne modifie pas la fréquence des images en entrée.  Les effets qui se
trouvent avant ReframeRT ont la même fréquence d'images que ReframeRT@.

@cindex Effet d'accéléré
L'effet ReframeRT en mode @b{Etirer} peut être utilisé afin de créer un
@b{effet d'accéléré}.  Sélectionnez le mode @b{Etirer} et entrez une valeur
supérieure à 1 afin d'obtenir une lecture en accéléré

@cindex Effet de ralenti
Pour un @b{effet de ralenti}, utilisez un effet ReframeRT en mode @b{Etirer}
avec une valeur inférieure à 1.  @w{@b{Example} :} vous avez un clip que vous
désirez passer en ralenti.  Le clip débute à 33.792 secondes et se termine à
39.765.  Le clip dure 5.973 secondes.  Vous désirez le reproduire à 4/10ème de
sa vitesse normale.  Vous divisez la durée du clip par la vitesse de lecture
(5.973/.4) pour obtenir une durée finale de clip de 14.9325 secondes.  Vous
créez un point d'entrée au début de votre @w{clip :} 33.792 secondes.  Vous
placez un point de sortie 14.9325 secondes plus tard, à 48.7245 secondes
(33.792 + 14.9325).  Attachez un effet ReframeRT, configurez-le à .4 en mode
@b{Etirer}.  Modifiez le point de sortie à 48.7245 en point d'entrée.  Vous
débuterez votre clip suivant après l'effet de ralenti au point de sortie de
48.7245.

Vous pouvez aussi modifier la fréquence des images du clip en faisant un clic
droit dans le @b{visualisateur de média} et en allant dans @b{Info}.  Si vous
ne cliquez pas le menu, vous pouvez aussi entrer au clavier la fréquence des
images désirée.  Cinelerra prendra les bonnes images depuis la fréquence des
images du projet, en faisant en même temps une modification de la vitesse de
lecture.

Le mode @b{Sous-échantillonner} ne modifie pas la durée de la séquence de
sortie.  Il multiplie la fréquence des images de la sortie par un facteur
d'échelle de façon à obtenir une fréquence d'image à lire en entrée.  Ceci a
pour effet de répliquer les images en entrée de façon à ce qu'elles ne changent
qu'à la fréquence d'images après mise à l'échelle lorsqu'elles sont envoyées
vers la sortie.  Cela ne modifie pas la durée de la séquence de sortie.  Si le
facteur d'échelle est de 0,5 et que la fréquence des images en sortie est de 30
i/s, seules 15 images seront affichées chaque seconde et les données d'entrée
seront lues à 15 i/s.  Sous-échantillonner n'est utile que pour les facteurs
d'échelle inférieurs à 1, d'où le terme "sous-échantillonner".

Le mode Sous-échantillonner modifie la fréquence des images de l'entrée ainsi
que le numéro de l'image à lire, la fréquence des images des effets qui se
trouvent avant ReframeRT sera donc la fréquence d'images multipliée par le
facteur d'échelle.  Si le facteur d'échelle est 2 et que la fréquence des
images en sortie est de 30, la fréquence des images en entrée sera de 60 et le
numéro de l'image en entrée sera doublé.  Ceci n'a normalement pas de
conséquence mais certains effets d'entrée peuvent se comporter différemment à
des fréquences d'images élevées.

@c cincvdoc_node_number_209
@node Vidéo en arrière
@subsection Vidéo en arrière
@cindex Effet de vidéo en arrière

@image{manual_images_intl/reversevideo,12.5mm}

Le média peut être inversé sur la timeline en temps réel.  Il ne faut pas le
confondre avec la lecture arrière des commandes de transport.  L'effet de vidéo
en arrière inverse la région couverte par l'effet indépendemment du sens de
lecture.

La région à inverser est d'abord déterminée par la partie de la piste sur
laquelle l'effet a été placé, et ensuite par l'emplacement des images-clés dans
l'effet.  L'effet inversé possède une option @b{Activé} qui vous permet de
définir des images-clés.  Ceci permet de nombreuses possibilités.

Chaque image-clé @b{Activée} est traité comme le point de départ d'une nouvelle
région inversée et la fin d'une région inversée précédente.  Plusieurs
images-clés @b{Activées} de suite conduiront à des régions inversées
indépendemment l'une de l'autre.  Une image-clé @b{Activée} suivie d'une
image-clé @b{désactivée} donnera une région inversée suivie d'une région
normale.

@c cincvdoc_node_number_210
@node Rotation
@subsection Rotation
@cindex Rotation

@image{manual_images_intl/rotate,13.25mm}

Le filtre rotation fait pivoter la vidéo par incréments de 90°, inverser et
retourner la vidéo.

@c cincvdoc_node_number_211
@node SVG via Inkscape
@subsection SVG via Inkscape
@cindex SVG via Inkscape

@image{manual_images_intl/svg,12.5mm}

FIXME

@c cincvdoc_node_number_212
@node Redimensionner
@subsection Redimensionner
@cindex Redimensionner

@image{manual_images_intl/scale,12.5mm}

FIXME

@c cincvdoc_node_number_213
@node Moyenne temporelle sélective
@subsection Moyenne temporelle sélective
@cindex Moyenne temporelle sélective

@image{manual_images_intl/timeavg,12.5mm}

Ce greffon est conçu pour lisser les régions fixes d'un clip vidéo.  Le lissage
est effectué en faisant la moyenne de la composante de couleur pour chacun des
pixel sur un certain nombre d'images.  La valeur lissée est utilisée si à la
fois l'écart-type, et la différence entre la valeur actuelle de la composante
et la moyenne de la composante se trouve en-dessous d'un certain seuil.

La moyenne et l'écart-type sont calculés pour chaque composante de la vidéo.
La moyenne est calculée sur des composantes dont le type dépend du modèle
colorimétrique du projet.  La moyenne et l'écart-type des images peuvent être
examinés en sélectionnant le bouton radio correspondant dans la fenêtre des
options du greffon.

La région pour laquelle la moyenne des images est effectuée est déterminée soit
par un décalage fixe, soit par un système de marqueur de redémarrage.  Dans un
système de marqueur de redémarrage, certaines images-clés sont marquées comme
étant le début des sections.  Ensuite, pour chaque section, les images qui
entourent l'image en cours sont utilisées comme images pour lesquelles la
moyenne doit être effectuée à l'exception des zones proches du début et de la
fin d'une section, où la moyenne est effectuée en prenant les @i{N} images du
début ou de la fin respectivement.

@b{Utilisation habituelle :}

Si vous avez sélectionné un certain nombre d'images dont vous désirez effectuer
la moyenne.

@enumerate 1
@item Entrez un nombre raisonnable d'images dont vous désirez effectuer la
moyenne (par exemple 10).
@item Sélectionnez la méthode @b{Moyenne temporelle sélective} et entrez 1 et
10 pour @b{Seuil moy} et @b{Seuil sigma} respectivement.  Ceci fera que tous
les pixels utiliseront la valeur moyenne.
@item Activez le masque pour une première composante.  Il devrait rendre
l'image entière uniformément de la couleur unie de cette composante.
@item Réduisez lentement la valeur de @b{Seuil sigma}.  Ceci faisant, vous
constaterez que les régions nettement différentes de la moyenne auront un état
de masque inversé.  Continuez à réduire le seuil jusqu'à ce que vous atteignez
le point où les zones de la vidéo qui ne se déplacent pas ont un état de masque
inversé.  Cette valeur est connue sous le nom de @b{plancher de bruit} et c'est
le niveau du bruit naturel généré par le capteur CCD de la caméra.
@item Répétez la même procédure pour le @b{Seuil moy}
@item Désactivez le masque
@item Répétez ceci pour tous les canaux
@end enumerate

@c cincvdoc_node_number_214
@node Netteté
@subsection Netteté
@cindex Netteté

@image{manual_images_intl/sharpen,12.5mm}

FIXME

@c cincvdoc_node_number_215
@node Décalage d'interlacement
@subsection Décalage d'interlacement
@cindex Décalage d'interlacement

@image{manual_images_intl/shiftinterlace,12.5mm}

FIXME

@c cincvdoc_node_number_216
@node Permuter les canaux
@subsection Permuter les canaux
@cindex Permuter les canaux

@image{manual_images_intl/swapchannels,12.5mm}

FIXME

@c cincvdoc_node_number_217
@node Seuil
@subsection Seuil
@cindex Effet vidéo de seuil
@cindex Luminance

@image{manual_images_intl/threshold,12.5mm}

L'effet de seuil converti une image en luminance pure.  Les valeurs de
luminance en-dessous de la plage du seuil seront converties en noir et les
valeurs de luminance dans la plage du seuil seront convertie en blanc.  La
fenêtre de seuil affiche un histogramme des valeurs de luminance pour l'image
en cours.  Cliquer et glisser dans l'histogramme crée une plage à convertir en
blanc.  @b{MAJ-clic} étend l'une des limites de cette plage.  Les valeurs de la
plage de seuil peuvent aussi être indiquées à l'aides des boîtes de texte.

Cet effet est une clé de luminance basique.  Une seconde piste au-dessus de la
piste avec l'effet de seuil peut être multipliée, ce qui fera que seules seront
affichées les parties de la seconde piste qui se trouvent à l'intérieur du
seuil.

@c cincvdoc_node_number_218
@node Moyenne temporelle
@subsection Moyenne temporelle
@cindex Effet vidéo de temporelle

@image{manual_images_intl/timeavg,12.5mm}

La moyenne temporelle est un effet qui a de nombreuses applications qui vont
au-delà de la création de traînées d'objets en mouvement.  Sa principale
utilisation est de réduire le bruit des images fixes.  Pointez simplement une
caméra vidéo en direction d'un sujet fixe pour une durée de 30 images, faites
l'acquisition des images, et faites-en la moyenne en utilisant @b{Moyenne
temporelle} et vous obtiendrez une image de très grande qualité.  Dans les
modèles colorimétriques en virgule flottante, la moyenne temporelle peut
améliorer la plage dynamique des caméra de bas de gamme.

L'effet de moyenne temporelle comporte un tampon d'accumulation et un diviseur.
Un certain nombre d'images sont accumulées dans le tampon d'accumulation et
divisées par le diviseur afin d'obtenir la moyenne.

Parce que la moyenne temporelle demande une quantité énorme de mémoire, il est
préférable de l'appliquer en désactivant d'abord la lecture de la piste, en y
déposant l'effet de moyenne temporelle, en le configurant pour le nombre
d'images voulu, et en réactivant la lecture de la piste.

@itemize @bullet
@item @b{Nombre d'images à utiliser pour la moyenne}@*
Ceci détermine le nombre d'images qui seront accumulées dans le tampon
d'accumulation.  Pour des intégrations très importantes, il est plus facile
d'éditer l'EDL dans un éditeur de texte et d'y indiquer le nombre d'images.

@item @b{Accumuler}@*
Ceci dirige vers la sortie le tampon d'accumulation sans en effectuer la
division.

@item @b{Moyenne}@*
Ceci provoque la division du tampon d'accumulation avant de le diriger vers la
sortie.  Le résultat en est la moyenne de toutes les images.

@item @b{OU inclusif}@*
Ceci remplacera le tampon d'accumulation par tous les pixels qui ne sont pas
transparents.  En combinaison avec le suivi de mouvement, ceci permet à des
séquences entières d'être combinées sous forme de panoramas.

@item @b{Traiter de nouveau les images}@*
Si un effet placé avant la moyenne temporelle est ajusté, la moyenne temporelle
ne relit normalement pas le tampon d'accumulation pour en obtenir les
modifications.  Ceci le force à relire le tampon d'accumulation lorsque l'autre
effet change.

@item @b{Désactiver la soustraction}@*
Afin de représenter uniquement l'accumulation du nombre d'images indiquées, la
moyenne temporelle conserve toutes les images précédentes en mémoire et les
soustrait lors de la lecture.  Il n'y aurait pas assez de mémoire si il devait
accumuler des milliers d'images.  En désactivant la soustraction, les images
précédentes ne sont pas stockées en mémoire et seule la fonction de moyenne est
affectée par le nombre d'images.
@end itemize

@c cincvdoc_node_number_219
@node Front temporel
@subsection Front temporel
@cindex Front temporel

@image{manual_images_intl/timefront,12.5mm}

C'est un greffon basé sur cet @w{article :}@*
@uref{http://www.vision.huji.ac.il/videowarping/HUJI-CSE-LTR-2005-10_etf-tr.pdf}

@c cincvdoc_node_number_220
@node Titreur
@subsection Titreur
@cindex Titreur
@cindex Gimp

@image{manual_images_intl/titler,12.5mm}

Bien qu'il soit possible d'ajouter du texte aux images en important des images
fixes depuis Gimp et en les composant, le titreur vous permet d'ajouter du
texte directement depuis Cinelerra.

Le titreur possède des options standard pour @b{police, taille, et style}.  La
meilleure police est une police générique telle qu'Arial dans une grande
taille.

Le titreur possède aussi des options que vous ne trouvez qu'avec des images
animées.  L'opération @b{Justifier} justifie le texte par rapport à l'image
entière.  Une fois justifié, les décalages @b{X et Y} sont appliqués.  Ceci
permet au texte de rester justifié pendant que vous le poussez à l'intérieur
des zones sûres.

Le @b{type de mouvement} fait défiler le texte dans l'une des quatre
directions.  Lorsque vous utilisez cette fonction, le texte peut disparaître.
Déplacez le point d'insertion le long de la timeline jusqu'à ce que le texte se
soit suffisamment déplacé dans l'animation pour réapparaître.  Le texte défile
pour apparaître ou disparaître.

En activant la @b{boucle}, le texte se déroulera complètement et recommencera.
Sans la @b{boucle} le texte défile jusqu'à disparaître et réapparaît.

La vitesse de l'animation est déterminée par @b{vitesse}.  Indiquez une vitesse
plus importante pour accélérer l'animation.

@b{Ombre portée} dessine une copie noire du texte en bas et à droite du texte
d'origine.  Ceci est utile lorsque le texte est placé sur une vidéo qui change
car il permet de conserver la bordure toujours visible.

En plus du défilement, les @b{Fonfu entrant / Fondu sortant} sont un second
type d'animation.  Si la durée de fondu est de 0 secondes, il n'y aura pas de
fondu.

@b{Couleur} permet de récupérer la couleur avec laquelle tracer le texte.  En
pratique, la seule couleur utile est habituellement le blanc.

@b{Horodater avec le code temporel} remplace le texte par la position en cours
sur la timeline en secondes et images.

Le titreur supporte les images-clés.  Pour ajouter des sous-titres à votre
film, vous devez utiliser un effet titreur et définir des images-clés.  Si vous
activez le mode des images-clés automatiques
@image{manual_images_intl/autokeyframe}, une nouvelle image-clé est créée chaque
fois que vous éditez le texte.  Dans la boîte de saisie du texte, vous verrez
le sous-titre apparaissant sous le point d'insertion.

@b{Note:} Pour ajouter des sous-titres, vous devriez probablement utiliser un
éditeur de sous-titres.  @xref{Ajouter des sous-titres}, pour plus
d'information.

@menu
* Ajouter des polices au titreur:: 	Comment ajouter des polices au titreur
* La zone sûre du titre::  		Comment conserver le texte visible sur la sortie
@end menu

@c cincvdoc_node_number_221
@node Ajouter des polices au titreur
@subsubsection Ajouter des polices au titreur

@cindex Polices , ajouter au titreur
@cindex Polices TTF
Le système X Window ne possède pas, à l'origine, de fonction de rendu des
police adapté à la vidéo.  Il est restreint en matière de profondeur de bits.
Il ne permet pas de savoir simplement quelles sont les polices qui fonctionnent
avec le système de rendu et avec la profondeur de bits désirée.  La manière la
plus simple que nous avons trouvé pour gérer les polices dans le titreur est
d'avoir un répertoire pour @w{celles-ci :} @file{/usr/lib/cinelerra/fonts}.

Le titreur gère principalement les police true type @b{TTF}.  Il permet aussi
d'utiliser d'autres types mais les polices TTF sont plus fiables.  Pour ajouter
des polices true type, copiez les fichier@file{.TTF} dans le répertoire
@file{/usr/lib/cinelerra/fonts}.  Depuis ce répertoire, lancez la commande
@command{ttmkfdir && mv fonts.scale fonts.dir} et redémarrez Cinelerra.  Les
nouvelles polices devraient être disponibles.  La syntaxe de ttmkfdir est
souvent modifiée, cette technique peut donc ne pas fonctionner.

@c cincvdoc_node_number_222
@node La zone sûre du titre
@subsubsection La zone sûre du titre
@cindex La zone sûre du titre
@cindex Affichage TV

Si la vidéo est affichée sur un téléviseur grand public, les bords extérieurs
seront coupés d'environ 5% de chaque côté.  De plus, le texte ondule s'il se
trouve trop près des bords.  Assurez-vous, lorsque vous ajoutez des titres, que
@image{manual_images_intl/titlesafe} l'outil @b{zone sûre du titre} est actif
dans le @b{compositeur}.  Le texte ne doit jamais sortir du rectangle
intérieur.

@c cincvdoc_node_number_223
@node Translation
@subsection Translation
@cindex Translation

@image{manual_images_intl/translate,12.5mm}

FIXME

@c cincvdoc_node_number_224
@node Défocaliser
@subsection Défocaliser
@cindex Défocaliser

@image{manual_images_intl/unsharp,12.5mm}

Cet effet défocalise la vidéo.  Ses paramètres sont :
@itemize @bullet
@item @b{Valeur}@*
Déplacer le curseur vers la droite rend les zones sombres plus sombres et les
zones claires plus claires.

@item @b{Rayon}@*
Ce curseur contrôle le niveau de flou à utiliser dans l'étape de recherche de
contour.  L'effet concret de ceci est d'indiquer de quelle taille une zone doit
être assombrie ou éclaircie.

@item @b{Seuil}@*
Ce curseur permet de contrôler quelle doit être la différence de taille entre
un pixel dans la copie floue de l'original et l'original avant qu'un
assombrissement ou un éclaircissement soit appliqué.
@end itemize

@c cincvdoc_node_number_225
@node Vidéoscope
@subsection Vidéoscope
@cindex Vidéoscope

@menu
* Le visualisateur de forme d'onde::
* Le vectorscope::
@end menu

@image{manual_images_intl/videoscope,12.5mm}

Le vidéoscope est un outil qui représente de manière numérique les niveaux de
lumière et de couleur sur un écran calibré.  Il est utile parce que l'oeil
humain n'est pas adapté à associer précisément des niveaux de luminosité ou des
couleurs entre eux, mais plutôt à détecter les différences entre la lumière et
la couleur.

Le vidéoscope peut être utilisé en conjonction avec d'autres greffons de
Cinelerra, tels que YUV, Teinte, Luminosité, Histogramme afin de corriger de
manière précise le contraste, la luminosité, la conformité (rendre homogènes
différentes prises de vue vidéo en des conditions d'éclairement variables), ou
dans des buts cimématiques.

Quelques réflexions ont été menées pour savoir s'il fallait un vidéoscope pour
l'enregistrement.  Malheureusement, ceci demanderait beaucoup d'adaptations du
vidéoscope pour chaque pilote vidéo.

Le vidéoscope comporte deux @w{affichages :} le @b{scope de forme d'onde} et le
@b{vectorscope}

@c cincvdoc_node_number_226
@node Le visualisateur de forme d'onde
@subsubsection Le visualisateur de forme d'onde
@cindex Forme d'onde, visualisateur

L'écran est gradué verticalement du bas vers le haut.  Le bas, ou 0%, est le
noir maximum, et le haut ou 100% est le blanc maximum.  La source vidéo est
divisée en colonnes verticales de pixels, ensuite chaque pixel de la colonne
est mesuré et placé sur la verticale correspondante du visualisateur de forme
d'onde en fonction de sa valeur d'intensité lumineuse.

Un pixel en bas de l'affichage indique du noir complet, un pixel en haut (100%)
de l'affichage est du blanc pur.

L'image affiche un ensemble de lignes en escalier sur l'affichage, en indiquant
les niveaux de luminance correspondants de la mire de barres correspondante.
Plusieurs niveaux sur la même colonne sont représentés par plusieurs lignes sur
le visualisateur.

Le visualisateur de forme d'onde aide à corriger les niveaux de luminosité de
l'image pour la plage de contraste ou pour homogénéiser les niveaux de
luminosité de différentes scènes prises sous des éclairages différents.

Ajustement des niveaux de luminosité (ajustement de la luminance) *Insérez
l'effet vidéo xxx sur votre piste, faites un clic droit, Afficher, Insérez
l'effet vidéscope sur la piste (assurez-vous qu'il soit placé sous l'effet xx,
de manière à ce qu'il puisse voir le résultat de l'effet xxx.  Si ce n'est pas
le cas, faites un clic droit et déplacez-le vers le bas pour qu'il le soit).
Clic droit, afficher.

En regardant les niveaux de luminance affichés sur la forme d'onde, ajustez le
contrôle xxx afin de faire correspondre le niveau de luminosité désiré pour
votre image.

Si vous désirez obtenir la meilleure plage de contraste, ajustez le niveau xxx
du greffon pour aligner le point le plus sombre du visualisateur sur le 0% de
l'échelle et la partie la claire qui vous intéresse avec le 100%.  Tout ce qui
se trouve au-dessus de 100% est sursaturé.

@c cincvdoc_node_number_227
@node Le vectorscope
@subsubsection Le vectorscope
@cindex Vectorscope

Le vectorscope est utilisé pour contrôler la couleur.  L'écran représente un
cercle de couleurs où la valeur de la couleur des pixels est tracée sur le
rayon d'une ligne partant du centre ; la plus petite valeur du rayon représente
le blanc pur et les cercles extérieurs indiquent les valeurs les plus élevées
de l'intensité.

La teinte de la couleur est aussi affichée, elle est représentée par l'angle en
degrés sur le cercle des couleurs.

Le vectorscope peut aussi être utilisé avec d'autres greffons pour corriger la
couleur, ajuster la teinte de l'image et appliquer d'autre effets pour des
effets cinématiques, la correction d'image ou pour homogénéiser des écrans
différents afin qu'ils se présentent de manière identique.

Le vectorscope peut aussi être utilisé pour contrôler que la sortie vidéo
puisse être correctement affichée sur différents moniteurs.  Tous les points
qui se trouvent près du rayon le plus à l'intérieur seront affichés en blanc
pur et tous les points au dessus du rayon de 100%, ne seront probablement pas
correctement affichés sur l'écran.

@c cincvdoc_node_number_228
@node Vagues
@subsection Vagues
@cindex Vagues

@image{manual_images_intl/wave,12.5mm}

L'effet de vague ajoute des vagues dans l'image.

@center @image{manual_images_fr/effect_wave_before_after,120mm}

Vous pouvez ajuster les paramètres suivants :

@center @image{manual_images_intl/effect_wave_window,60mm}

@c cincvdoc_node_number_229
@node Tourbillon
@subsection Tourbillon
@cindex Tourbillon

@image{manual_images_intl/whirl,12.5mm}

FIXME

@c cincvdoc_node_number_230
@node YUV
@subsection YUV
@cindex YUV

@image{manual_images_intl/yuv,12.5mm}

FIXME

@c cincvdoc_node_number_231
@node Flou de zoom
@subsection Flou de zoom
@cindex Flou de zoom

@image{manual_images_intl/zoomblur,12.5mm}

FIXME

@c cincvdoc_node_number_232
@node Les effets rendus
@chapter Les effets rendus
@cindex Les effets rendus
@cindex Effets, rendus
Un autre type d'effet est réalisé sur une portion de la piste et le résultat
est enregistré quelque part avant d'être joué.  Le résultat est collé sur la
piste en remplacement des données d'origine.

Les effets rendus ne sont pas listés dans la fenêtre des ressources mais sont
accessibles depuis les options @b{Audio->Rendu d'effet...} et @b{Vidéo->Rendu
d'effet...}.  Chacune de ces options de menu affiche un dialogue pour le rendu
de l'effet.  S'il n'y a pas de piste du type correspondant, une fenêtre
d'erreur apparaît.

La région de la timeline sur laquelle appliquer l'effet doit être préalablement
définie avant de choisir @b{Rendu d'effet...}.  S'il n'y a pas de points
d'entrée/sortie ni de zone en surbrillance, la région toute entière située
après le point d'insertion sera traitée comme étant la région affectée.  Sinon,
la région affectée sera soit la région se trouvant entre les points
d'entrée/sortie, soit la région en surbrillance.

Ensuite, les piste auxquelles appliquer le rendu d'effet doivent être
@b{armées}.  Toutes les autres pistes sont ignorées.

Enfin, le rendu d'effet affecte le traitement de certains attributs de piste
lorsqu'il lit ses données d'entrées mais pas d'autres.  Les transitions de la
piste affectée sont appliquées.  Le décalage ne l'est pas et les effets ne le
sont pas non plus.  Ceci permet aux nouvelles données d'être collées à
l'emplacement existant sans modifier la valeur de décalage.

Dans le dialogue de rendu d'effets, il y a une liste de tous les effets en
temps réel et de tous les effets rendus.  La différence ici est que les effets
en temps réel sont rendus vers le disque dur et ne sont pas appliqués sous la
piste.  Mettez un effet en surbrillance pour le désigner comme celui qui doit
être exécuté.

Définissez un fichier vers lequel effectuer le rendu de l'effet dans la boîte
de dialogue @b{Choisir un fichier de destination pour le rendu :}.  La
@image{manual_images_intl/magnify,7mm} loupe permet de choisir le fichier dans
une liste.

Choisissez un format de fichier qui permet de gérer le type de piste.  La
@image{manual_images_intl/wrench,4.33mm} clé permet une configuration compatible
avec le format de fichier indiqué.

Il existe aussi une option pour @b{Créer un nouveau fichier à chaque marque}.
Si vous avez un CD rippé sur la timeline et que vous voulez le diviser en
fichiers séparés, les marques deviennent les points de séparation entre les
fichiers si cette option a été choisie.  Lorsque la timeline est divisée à
l'aide des marques, l'effet est réinitialisé à chacune des marques.  Les
opérations de normalisation prennent la valeur crête du fichier en cours et non
la timeline toute entière.

Enfin, il y a une @b{stratégie d'insertion} comme dans le dialogue de rendu.
Il faut noter que même si l'effet ne s'applique qu'à de l'audio ou qu'à de la
vidéo, la stratégie d'insertion s'applique à toutes les pistes exactement comme
pour une opération avec le presse-papiers.

Lorsque vous cliquez sur @b{Accepter (OK)} dans le dialogue de l'effet,
l'interface utilisateur graphique de l'effet est appelée.  Si l'effet est aussi
un effet en temps réel, une seconde interface graphique est affichée pour
demander si vous acceptez ou rejetez les paramètres actuels.  Une fois les
paramètres acceptés, l'effet est traité.

@menu
* Les effets audio rendus::     Effets audio rendus
* Les effets vidéo rendus::     Effets vidéo rendus
@end menu

@c cincvdoc_node_number_233
@node Les effets audio rendus
@section Les effets audio rendus
@cindex Les effets audio rendus

@menu
* Rééchantillonner::        Comment réduire la plage dynamique de l'audio.
@end menu

@c cincvdoc_node_number_234
@node Rééchantillonner
@subsection Réchantillonner
@cindex Effet de rééchantillonnage

Ceci multiplie le numéro de chaque échantillon de sortie par un facteur
d'échelle pour arriver au numéro de l'échantillon en entrée.  Le taux
d'échantillonnage du fichier de sortie est positionné au taux d'échantillonnage
du projet mais sa durée est modifiée pour refléter la renumérotation des
échantillons.  Il filtre aussi l'audio afin de supprimer le repliement de
spectre.

Si le facteur d'échelle est de 2, tous les deux échantillons en entrée, on aura
un échantillon en sortie et le fichier de sortie aura moitié moins
d'échantillons que la séquence d'entrée.  S'il est de 0.5, tous les 0,5
échantillons en entrée seront étirés de manière à ce que le fichier de sortie
ait deux fois plus d'échantillons que la séquence en entrée.

@c cincvdoc_node_number_235
@node Les effets vidéo rendus
@section Les effets vidéo rendus
@cindex Les effets vidéo rendus

@menu
* Reframe::        Reframe
@end menu

@c cincvdoc_node_number_236
@node Reframe
@subsection Reframe
@cindex Reframe video effect

Il réalise exactement la même chose que @b{ReframeRT} en mode @b{Etirer}.  Il
multiplie le numéro de l'image en sortie par un facteur d'échelle pour obtenir
le numéro de l'image en entrée et il modifie la durée de la séquence.
Contrairement à ReframeRT, il doit être lancé depuis le menu @b{Vidéo} et sa
sortie doit être rendue.

Soyez conscient du fait que @b{Reframe} n'écrit pas la fréquence des images
avec la fréquence des images du fichier rendu.  Il produit un fichier dont la
durée est modifiée dans la fréquence des images du projet.  La nouvelle durée
est affectée d'un coefficient de 1/facteur d'échelle par rapport à la séquence
d'origine.

@b{Pour créer un effet de ralenti ou d'accéléré :}
@enumerate 1
@item Sélectionnez le clip vidéo dont vous désirez modifier la fréquence des
images et mettez-le sur une piste vidéo
@item Sélectionnez la zone dont vous désirez modifier la fréquence des images
@item Depuis le menu Vidéo, sélectionnez l'option @b{Rendu d'effet}
@item Depuis la liste des effets, sélectionnez Reframe
@item Entrez le format de sortie et la stratégie d'insertion pour le nouveau
clip à créer
@item Pressez OK
@item Sur le fenêtre des options de l'effet, entrez un facteur d'échelle de 2
pour avoir un déroulement deux fois plus rapide et de 0,5 pour avoir un
déroulement deux fois plus lent
@end enumerate

@c cincvdoc_node_number_237
@node Les effets Ladspa
@chapter Les effets Ladspa
@cindex Effets Ladspa

Les effets audios LADSPA sont supportés en temps réel et en mode rendu.  Les
greffons LADSPA que vous pourrez obtenir depuis internet sont de qualités
variables.  La plupart ne peuvent pas être ajustés facilement pour fonctionner
en temps réel en raison d'un manque de réentrance.  Bien que Cinelerra
implémente une interface LADSPA de la manière la plus rigoureuse possible,
gérer plusieurs pistes en temps réel et effectuer du traitement simultané sont
au-delà des possibilités de la majorités des utilisateurs de LADSPA@.  Les
effets LADSPA apparaissent dans le dossier audio sous forme du marteau et du
tournevis, afin de signifier que ce sont des greffons destinés à des
développeurs Audio sous GNU/Linux.

@center @image{manual_images_intl/ladspa_effects,80mm}
@center @b{Effets audio Ladspa dans le répertoire audio}

Les effets LADSPA sont simplement activés en définissant la variable
d'environnement @env{LADSPA_PATH} à la valeur de l'emplacement de vos greffons
@w{LADSPA :}
@verbatim
export LADSPA_PATH=/usr/lib/ladspa
@end verbatim
ou bien en les mettant dans le répertoire @file{/usr/lib/cinelerra}.@*

Si vous utilisez Debian, vous pouvez obtenir un grand nombre de greffons en
utilisant @w{apt :}@*
@command{apt-cache search ladspa}@*
@command{apt-get install jack-rack cmt blop swh-plugins}

@c cincvdoc_node_number_238
@node Les transitions
@chapter Les transitions
@cindex Transitions

@menu
* Utiliser les transitions::
* Fondu enchaîné vidéo::
@end menu

@c cincvdoc_node_number_239
@node Utiliser les transitions
@section Utiliser les transitions
@cindex Utiliser les transitions

Lorsqu'un plan se termine et qu'un autre commence, le comportement par défaut
est d'avoir la sortie du premier plan remplacée immédiatement par la sortie du
second lorsqu'il sont joués.  Les transitions sont un moyen pour la sortie du
deuxième plan de remplacer celle du premier avec différentes variations.

Cinelerra peut gérer des transitions audio et vidéo, elles sont toutes listées
dans la fenêtre des ressources.

@center @image{manual_images_intl/resources_video_transitions,70mm}
@center @b{Transitions vidéo dans la fenêtre des ressources}

Les transitions ne s'appliquent qu'aux pistes de même type.  Les transitions
qui se trouvent dans la rubrique des transitions audio (@b{Audio transitions}
ne peuvent s'appliquer qu'aux pistes audio.  Les transitions qu'on trouve dans
la rubrique des transitions vidéo @b{Video transitions} ne s'appliquent qu'aux
pistes vidéo.

@center @image{manual_images_intl/drop_transition}
@center @b{Glissé d'une transition de fondu enchaîné sur la timeline}

Chargez un fichier vidéo et coupez-en une section près du centre de façon à ce
que le point de coupe soit visible sur la timeline.  Allez dans la fenêtre des
ressources et cliquez sur le dossier @b{Video transition}.  Glissez une
transition depuis la liste des transitions sur le deuxième plan de vidéo
présent sur la timeline.  Une boîte en surbrillance entoure l'endroit où
apparaîtra la transition.  Si vous la déposez sur le deuxième plan, elle
s'appliquera entre le premier et le deuxième plan.

Vous pouvez vous déplacer le long de la transition avec les commandes de
déplacement et visionner la sortie dans la @b{fenêtre de composition}.  Les
déplacements du point d'insertion ne permettent en général pas de voir les
transitions car elles sont habituellement de trop courte durée.

@cindex Détacher les transitions
@cindex Editer les Transitions
Une fois la transition en place, elle peut être modifiée de la même manière
qu'un effet.  Survolez la transition avec le pointeur de la souris et faites un
clic droit pour afficher le menu de la transition.  L'option @b{Afficher les
options} permet d'afficher les paramètres propres à la transition en question,
s'il y en a.  L'option de @b{Durée} permet d'en ajuster la durée en secondes.
Une fois ces deux paramètres définis, ils seront appliqués aux futures
transitions jusqu'à ce qu'ils soient de nouveau modifiés.  Enfin, l'option
@b{Détacher} permet de supprimer la transition de la timeline.

Glisser et déposer des transitions depuis la fenêtre des ressources vers la
fenêtre de programme peut être long et fastidieux.  Heureusement, une fois que
vous avez glissé une transition depuis la fenêtre des ressources, les touches
@b{U} et @b{u} permettent de coller une transition identique.  La touche @b{U}
colle la dernière transition vidéo et la touche @b{u} permet de coller la
dernière transition audio sur toutes les pistes enregistrables.  Si le point
d'insertion ou le point d'entrée se trouve sur un plan, le début de ce plan
sera couvert par la transition.

Il faut noter que lorsque l'on rejoue des transitions depuis la timeline vers
un périphérique vidéo bénéficiant d'une accélération matérielle, l'accélération
matérielle sera momentanément désactivée pendant la durée de la transition et
réactivée après la transition de façon à ce que le rendu puisse se faire.
L'utilisation d'un périphérique sans accélération pour l'ensemble de la
timeline supprime cet inconvénient.

@b{Important :} L'instant exact où la transition prend effet n'est pas évident.
Elle commence lorsque le second plan débute et se termine un certain temps
après, à l'intérieur du second plan.  Il faut donc que le premier objet
contienne suffisamment de données après le point de coupe pour remplir la
transition à l'intérieur du second plan.

Par exemple, la transition de fondu enchaîné commence à l'emplacement exact où
elle est placée sur la timeline.  Si vous définissez une durée d'une seconde
pour cette transition, elle ne démarrera @b{pas} 0,5 secondes avant la
transition pour se poursuivre 0,5 secondes après ce point.  En fait, elle
commencera exactement au point où elle est située sur la timeline, et elle
durera 1 seconde à partir de cet emplacement.

Un erreur courante est de mettre une transition de fondu enchaîné juste après
la dernière image d'un objet.  Imaginons que la transition de fondu enchaîné
soit placée entre l'objet A et l'objet B, juste après la dernière image de
l'objet A@.

Comme l'effet de fondu enchaîné démarre exactement à l'endroit où il est placé,
il n'y a plus d'images de l'objet A à afficher lorsque la transition de fondu
enchaîné démarre.  Il n'y a donc pas d'autre choix pour Cinelerra que de figer
la dernière image de l'objet A et de la fondre avec l'objet B@.

Vous devez donc vous assurer qu'il y a suffisamment d'images de l'objet A
susceptibles d'être affichées lorsque la transition de fondu enchaîné démarre.
La durée de ces images devant être supérieure ou égale à la durée de la
transition.

@c cincvdoc_node_number_240
@node Fondu enchaîné vidéo
@section Fondu enchaîné vidéo
@cindex Fondu enchaîné vidéo

@image{manual_images_intl/video_disolve_icon}

C'est une transition de fondu entre deux segments de vidéo, que nous
appellerons les segments d'entrée et de sortie.  Le segment s'entrée devient
progressivement transparent alors que le segment de sortie apparaît
progressivement.  La durée complète de l'effet peut être contrôlée par "Durée
de la transition".

@b{Commandes disponibles :}@*
En effectuant un clic droit sur l'icône de la transition sur la timeline, vous
obtiendrez un menu avec les commandes suivantes
@itemize @bullet
@item @b{Afficher les options :} permet d'afficher le menu spécifique à la
transition (il n'y en a pas pour cette transition particulière)
@item @b{Actif :} active ou désactive l'action de la transition
@item @b{Durée de la transition :} définit la durée de la transition, en
secondes
@item @b{Détacher :} supprime la transition de la timeline
@end itemize

@c cincvdoc_node_number_241
@node Les images-clés
@chapter Les images-clés
@cindex Images-clés

Lorsque vous modifiez le réglage de volume, la caméra, le projecteur ou
d'autres paramètres d'une piste, ils restent en général identiques pour toute
la durée de la timeline.  Utiliser des paramètres statiques n'est parfois pas
très utile.  Généralement, vous désirez modifier la positon de la caméra au
cours du temps ou modifier les positions des masques.  Les masques doivent
suivre les objets.  On crée donc des modifications dynamiques en définissant
des images-clés.  Une image-clé est un certain instant où les paramètres
changent pour une certaine opération.  Dans Cinelerra, il y a des images-clés
pour presque chaque paramètre de composition et d'effet.

@cindex Image-clé par défaut
@cindex Image-clé, défaut
Lorsque vous ajustez un paramètre quelconque, sa valeur est enregistrée dans
une image-clé.  Si la valeur est enregistrée dans une image-clé, pourquoi ne
change-t-elle pas en permanence ? L'image-clé dans laquelle elle est enregistré
par défaut est appelé l'image-clé par défaut.  L'image-clé par défaut
s'applique à toute la durée du projet s'il n'y a aucune autre image-clé.
L'image-clé par défaut n'est jamais représentée car elle existe toujours.  La
seule manière pour qu'une modification apparaisse au cours du temps est de
créer d'autres images-clés que l'image-clé par défaut.

On peut afficher les images-clés pour un paramètre donné en utilisant le menu
@b{Afficher}.  Une méthode plus rapide pour activer ou désactiver plusieurs
images-clés est d'utiliser le menu @b{Fenêtre->Overlays}.  Cette fenêtre permet
d'activer et de désactiver tous les paramètres présents dans le menu Afficher.
Lorsque des images-clés sont sélectionnées, elles sont dessinées sur la
timeline sur les pistes auxquelles elles s'appliquent.

Les images-clés existent sous différentes @w{formes :} courbes, commutateurs,
modes et ainsi de suite.  La manière de gérer les différents types
d'images-clés est décrite çi-dessous.

@menu
* Les images-clés de type courbe::
* Les images-clés de type commutateur::
* Les images-clés automatiques::
* Les images-clés du compositeur::
* Editer les images-clés::
@end menu

@c cincvdoc_node_number_242
@node Les images-clés de type courbe
@section Les images-clés de type courbe
@cindex Images-clés de type courbe
@cindex Images-clés, courbe

De nombreux paramètres sont enregistrés dans des courbes de Bezier.  Allez à
@b{Afficher->Fondu} ou @b{Afficher->Zoom} pour afficher sur la timeline les
courbes correspondant à ces paramètres.  Dans les deux modes d'édition "flèche"
ou "i-beam", déplacez le curseur sur la courbe jusqu'à ce qu'il change de
forme.  Vous pouvez ensuite créer une image-clé à cette position simplement par
un cliquer-glisser sur la courbe.

Une fois l'image-clé créée, un cliquer-glisser sur celle-ci permet de la
repositionner.  Lorsque vous cliquez-glissez une seconde image-clé sur la
courbe, cela crée une courbe en pente douce.  @b{Ctrl-glisser} sur une image-clé
modifie la valeur soit du contrôle d'entrée, soit du contrôle de sortie.  Ceci
permet de modifier la raideur de la pente de la courbe.  Bien que que le
contrôle d'entrée et le contrôle de sortie puissent être déplacés aussi bien
horizontalement que verticalement, le mouvement horizontal n'est là que pour
des raisons de lisibilité et n'est pas utilisé dans la valeur de la courbe.

Vous pouvez vous souvenir que Gimp et les masques de composition utilisent la
touche @key{MAJ} pour sélectionner des points de contrôle, alors pourquoi
est-ce que la timeline utilise @key{CTRL} ? Lorsque vous utilisez @b{MAJ-clic}
sur une courbe de la timeline, l'image-clé se colle soit à l'image-clé qui la
suit, soit à celle qui la précède en fonction de celle qui existe.  Ceci vous
permet de mettre en place une courbe constante sans avoir à copier l'image-clé
suivante ou précédente.

@menu
* Naviguer dans les courbes des images-clés::
@end menu

@c cincvdoc_node_number_243
@node Naviguer dans les courbes des images-clés
@subsection Naviguer dans les courbes des images-clés
@cindex Naviguer dans les courbes des images-clés

Il n'y a pas beaucoup de place sur la timeline pour une grande quantité de
valeurs de courbes.  Il vous faut donc zoomer verticalement sur les courbes
pour permettre leur modification.  Ceci peut être effectué à l'aide de deux
@w{outils :} le bouton d'adaptation automatique et le menu de zoom automatique
@image{manual_images_intl/autozoom}.

Le bouton d'adaptation automatique redimensionne et décale la plage verticale
de façon à ce que la courbe choisie apparaisse sur la timeline.  Si une région
de la timeline a été mise en surbrillance par le curseur, seule cette région
est mise à l'échelle.  Les points d'entrée/sortie n'affectent pas la région
zoomée.  @kbd{ALT-f} permet d'effectuer la mise à l'échelle automatique.

L'entrée de menu zoom automatique modifie manuellement l'échelle verticale des
courbes par multiples de 2.  Cliquez sur le bouton pour faire défiler les
valeurs de zoom.  @kbd{ALT-haut} et @kbd{ALT-bas} permettent de modifier le zoom
automatique à l'aide du clavier.

@c cincvdoc_node_number_244
@node Les images-clés de type commutateur
@section Les images-clés de type commutateur
@cindex Les images-clés de type commutateur
@cindex Images-clés, commutateur

La sourdine est la seule image-clé de type commutateur.  Les images-clés de
sourdine déterminent où la piste est traitée mais non rendue dans la sortie.
Un clic droit sur ces courbes permet de créer une image-clé.  A l'inverse des
courbes, l'image-clé de type commutateur n'a que deux @w{valeurs :} active ou
inactive.  @key{CTRL} et @key{MAJ} n'a aucun effet sur les images-clés de type
commutateur.

@c cincvdoc_node_number_245
@node Les images-clés automatiques
@section Les images-clés automatiques
@cindex Images-clés automatiques
@cindex Images-clés, automatiques

Vous avez peut-être remarqué que lorsque des courbes de réglage de niveau sont
configurées, le déplacement du point d'insertion le long de ces courbes les
fait bouger de façon à ce qu'ils indiquent la valeur qui se trouve sous le
point d'insertion.  Ce n'est pas uniquement pour la beauté de la chose.  Les
boutons de réglage de niveau peuvent eux-même créer des images-clés dans le
mode-clés automatiques.  Le mode images-clés automatiques est en général plus
utile que de glisser les courbes.

Activez ce mode en activant le bouton des images-clés automatiques
@image{manual_images_intl/autokeyframe}.  Dans le mode des images-clés
automatiques, chaque fois que vous ajustez un paramètre susceptible d'être mis
sous forme d'image-clé, une image-clé est créée sur la timeline.  Comme les
images-clés automatiques affectent de nombreux paramètres, il est préférable de
les activer juste avant d'avoir besoin d'une image-clé et de les désactiver
immédiatement après.

Il est utile d'aller dans le menu @b{Afficher} et de rendre le paramètre en
question visible avant d'effectuer une modification.  L'emplacement où une
image-clé automatique est créée se trouve sous le point d'insertion.  Si la
timeline est jouée alors qu'on ajuste le paramètre, plusieurs images-clés
automatiques seront créées alors que vous modifiez ce paramètre.

Lorsque le mode des images-clés automatiques est désactivé, une chose étrange
du même genre se produit.  L'ajustement d'un paramètre ajuste l'image-clé qui
précède immédiatement le point d'insertion.  S'il existe deux images-clés et
que le point d'insertion se trouve entre les deux, une modification d'un
réglage de niveau va modifier la première image-clé.

Il y a de nombreux paramètres qui ne peuvent être mis sous forme d'images-clés
que dans le mode des images-clés automatiques.  Ce sont les paramètres pour
lesquels les courbes prendraient trop de place sur la piste ou qui ne peuvent
pas être aisément représentés sous forme de courbe.

Les effets ne peuvent pas être mis sous forme d'images-clés en raison du grand
nombre de paramètres possibles pour chacun des effets.

La translation de la caméra et du projecteur ne peut être mise sous forme
d'images-clés que dans le mode des images-clés automatiques alors que le zoom
de la caméra et du projecteur peuvent être mis sous forme d'images-clés à
l'aide de courbes.  C'est ici que nous terminons la discussion concernant la
composition, car celle-çi dépend grandement des possibilités de modifications
au cours du temps.

@c cincvdoc_node_number_246
@node Les images-clés du compositeur
@section Les images-clés du compositeur
@cindex Les images-clés du compositeur
@cindex Images-clés, compositeur

La translation de la caméra et du projecteur est représentée par deux
paramètres : les coordonnées x et y.  C'est donc fastidieux de les ajuster à
l'aide des courbes.  Cinelerra permet de résoudre ce problème via les
images-clés automatiques.  Avec une piste vidéo chargée, déplacez le point
d'insertion au début de la piste et activez le mode des images-clés
automatiques.

Déplacez légèrement le projecteur dans la fenêtre de composition pour créer une
image-clé.  Déplacez-vous alors vers l'avant de quelques secondes.  Déplacez le
projecteur sur une assez longue distance pour créer une autre image-clé et
amplifier le mouvement.  Ceci crée une seconde boîte de projecteur dans le
compositeur avec une ligne joignant les deux boîtes.  Cette ligne est le chemin
de déplacement.  Si vous créez d'autres images-clés, d'autres boîtes seront
créées.  Une fois que toutes les images-clés voulues sont créées, désactivez le
mode des images-clés automatiques.

Maintenant, lorsque vous déplacez le curseur dans la fenêtre de composition, la
projection vidéo se déplace au cours du temps.  A n'importe quel endroit entre
deux images-clés, le chemin du déplacement est rouge pour tous les instants
précédant le point d'insertion et vert pour tous les instants qui le suivent.
On peut se demander si cette fonction est très utile mais elle vous permet de
vous rendre compte qu'une image-clé va être affectée par les prochains réglages
du projecteur.

Un cliquer-glisser alors que les images-clés automatiques ne sont pas actives
permet d'ajuster l'image-clé précédente.  Si vous vous trouvez à mi-chemin
entre deux images-clés, la première boîte de projecteur est ajustée alors que
la seconde n'est pas modifiée.  De plus, la vidéo ne semble pas se déplacer en
phase avec la première image-clé.  Ceci est dû au fait qu'à mi-chemin entre deux
images-clés, la translation du projecteur est interpolée.  Pour pouvoir définir
la seconde image-clé, vous devrez vous déplacer après la seconde image-clé.

Par défaut, le trajet de déplacement est une ligne droite, mais il peut être
incurvé à l'aide de points de contrôle.  Un @b{CTRL-glisser} permet de placer
le point de contrôle d'entrée ou de sortie de l'image-clé précédente.  Une fois
encore, nous nous éloignons du comportement de Gimp car la touche @key{MAJ} est
déjà utilisée pour le zoom.  Ensuite, les points d'entrée/sortie sont
extrapolés à partir de l'image-clé, un @b{CTRL-glisser} n'importe où sur la vidéo
permet d'ajuster le point de contrôle le plus proche.  Un point de contrôle
peut être entièrement hors de vue tout en restant contrôlable.

Lorsque vous éditez la translation de la caméra, le comportement des boîtes de
caméra est légèrement différent.  La caméra est généralement utilisée pour
effectuer des panoramiques sur des images fixes.  La boîte de caméra en cours
ne se déplace pas durant un glisser, mais si plusieurs images-clés sont
définies, chaque boîte de caméra, excepté l'image-clé en cours semblent se
déplacer.  Ceci est dû au fait que l'affichage de la caméra affiche toutes les
autres positions de caméras par rapport à celle en cours.

La situation devient plus intuitive si vous courbez le chemin de déplacement
entre deux images-clés et que vous vous déplacez entre ceux-ci.  La limite
entre le rouge et le vert, qui est la position actuelle des images-clés, est
toujours centrée alors que les boîtes de caméra se déplacent.

@c cincvdoc_node_number_247
@node Editer les images-clés
@section Editer les images-clés
@cindex Editer les images-clés
@cindex Images-clés, éditer

@b{IMPORTANT :} lorsque vous copiez et collez des images-clés, assurez-vous
@b{qu'il n'y a pas de point d'ENTREE ou de point de SORTIE sur la timeline}.

Les images-clés peuvent être déplacées le long de la timeline et déplacées
entre pistes en utilisant des opérations de couper-coller semblables à celles
utilisée pour le montage de média.  Cependant, seules les images-clés
sélectionnées dans le menu @b{Afficher} seront affectées par les opérations
d'édition.

L'opération d'édition des images-clés la plus populaire est la réplication
d'une courbe d'une piste à l'autre pour créer une paire stéréo.  La première
étape est d'isoler le @image{manual_images_intl/recordpatch_up} bouton
d'enregistrement de la piste source à l'aide de @b{MAJ-clic}.  Ensuite, placez
les points d'entrée/sortie ou mettez en surbrillance la zone des images-clés
désirée.  Utilisez @b{Images-clés->Copier les Images-clés} pour copier les
images-clés dans le presse-papiers.  Isolez le
@image{manual_images_intl/recordpatch_up} bouton d'enregistrement de la piste de
destination par @b{MAJ-clic} et utilisez @b{Images-clés->Coller les
images-clés} pour coller le contenu du presse-papiers.

Les commandes d'édition de média sont liées aux commandes d'édition des
images-clés en utilisant la touche @key{MAJ} à la place du raccourci clavier
seul.

Ceci introduit la partie la plus compliquée de l'édition des images-clés,
l'images-clé par défaut.  Souvenez-vous que même si aucune image-clé n'a été
définie, il y a quand même une image-clé par défaut qui contient un paramètre
global pour toute la durée.  L'image-clé par défaut n'est pas dessinée car elle
existe toujours.  Que se passe-t-il si l'image-clé par défaut contient une
valeur intéressante que vous voulez transposer vers d'autres images-clés qui ne
sont pas celles par défaut ? Les fonctions @b{Images-clés->Copier l'image-clé
par défaut} et @b{Images-clés->Coller l'image-clé par défaut} permettent de
convertir l'image-clé par défaut en une image-clé qui ne soit pas celle par
défaut.

Si vous avez copié une image-clé qui n'est pas celle par défaut, elle peut être
enregistrée comme image-clé par défaut en utilisant @b{Images-clés->Coller
l'image-clé par défaut}.  Après avoir utilisé cette fonction pour convertir une
image-clé qui n'est pas celle par défaut en image-clé par défaut, vous ne
verrez pas la valeur de l'image-clé par défaut avant que toutes les images-clés
autres que celles par défaut aient été supprimées.

Il y a enfin une manière pratique d'effacer les images-clés en sélectionnant
une zone et en utilisant @b{Images-clés->Effacer les images-clés}.  Faites
simplement un cliquer-glisser d'une image-clé avant l'image-clé qui la précède
ou après l'image-clé qui la suit sur la piste.

@c cincvdoc_node_number_248
@node Faire l'acquisition de média
@chapter Faire l'acquisition de média
@cindex Faire l'acquisition de média
@cindex Média, acquisition

@menu
* Acquisition en utilisant Cinelerra::
* Acquisition en utilisant dvgrab::
@end menu

@c cincvdoc_node_number_249
@node Acquisition en utilisant Cinelerra
@section Acquisition en utilisant Cinelerra
@cindex Acquisition en utilisant Cinelerra

@menu
* Fonctions d'enregistrement de Cinelerra::
* Enregistrement par lots::
* Editer les informations du tuner::
@end menu

@c cincvdoc_node_number_250
@node Fonctions d'enregistrement de Cinelerra
@subsection Fonctions d'enregistrement de Cinelerra
@cindex Fonctions d'enregistrement de Cinelerra

Idéalement, tous les médias sont enregistrés sur disque-dur, CD-ROM, flash ou
DVD et le chargement dans Cinelerra ne consiste qu'à charger un fichier.  En
réalité, il n'y a que très peu de sources de médias qui puissent être accédées
comme un système de fichiers ; ils utilisent plutôt des mécanismes de transport
et des mécanismes d'E/S basiques pour transférer les données vers les
ordinateurs.  Ces types de média sont importés dans Cinelerra par
l'intermédiaire du dialogue d'enregistrement.

La première étape lors de l'enregistrement est de configurer le périphérique
d'entrée.  Dans @b{Configuration->Préférence} se trouvent de nombreux
paramètres d'enregistrement décrits dans la configuration @xref{Acquisition}.
Ces paramètres s'appliquent à l'enregistrement quelque soient les paramètres du
projet, car les paramètres d'enregistrement utilisent habituellement les
pleines capacités du matériel d'enregistrement alors que les paramètres du
projet peuvent varier.

Allez dans le menu @b{Fichier->Enregistrer} pour effectuer l'enregistrement
depuis une source externe.  Un format de sortie vous sera demandé comme pour le
rendu.  Ensuite, la fenêtre d'enregistrement et le moniteur d'enregistrement
vont s'afficher.

La fenêtre d'enregistrement comporte un certain nombre de sections.  Alors que
de nombreux paramètres changent selon que le fichier contienne de l'audio ou de
la vidéo, les sections elles-mêmes restent toujours les mêmes.

@itemize @bullet
@item La zone de @b{format de sortie} décrit le format du fichier de sortie et
la position en cours dans ce fichier.
@item La zone @b{éditer le lot} vous permet de modifier les paramètres du lot
en cours.
@item Les commandes de transport permettent de démarrer et d'arrêter
l'enregistrement de différentes manières.
@item La @b{liste des lots} affiche les lots ayant été définis.
@item La zone de @b{confirmation} vous permet de déterminer comment les
fichiers de sortie seront importés sur la timeline et de quitter.
@end itemize

@center @image{manual_images_fr/recording,140mm}
@center @b{Zones de la fenêtre d'enregistrement}

L'enregistrement dans Cinelerra est organisé par lots.  Un lot définit
essentiellement un fichier de sortie distinct pour l'enregistrement.  Pour
l'instant, vous pouvez ignorer complètement le concept de lot et effectuer
l'enregistrement simplement en cliquant le @image{manual_images_intl/record}
bouton d'enregistrement.

Le bouton d'enregistrement ouvre le fichier de sortie en cours s'il n'est pas
déjà ouvert et y écrit les données capturées.  Le bouton arrêt permet d'arrêter
l'enregistrement.  L'enregistrement peut être repris à ce point avec le bouton
d'enregistrement, sans effacer le fichier.  Dans le cas d'un fichier vidéo, il
y a un bouton d'enregistrement d'une seule image
@image{manual_images_intl/singleframe} qui permet de n'enregistrer qu'une seule
image.

Lorsque vous avez enregistré suffisamment de données, choisissez la méthode
d'insertion dans le menu @b{stratégie d'insertion} et cliquez sur le bouton de
fermeture.

@c cincvdoc_node_number_251
@node Enregistrement par lots
@subsection Enregistrement par lots
@cindex Enregistrement par lots

Nous arrivons maintenant au concept de lots.  Les lots permettent d'essayer de
rendre le comportement d'entrées/sorties simples plus proche de celui d'un
système de fichiers.  Les lots sont traditionnellement utilisés pour diviser
une bande en différents programmes et enregistrer différents programmes sous
forme de fichiers séparés plutôt que d'enregistrer la bande sous la forme d'un
fichier d'un seul tenant.  En raison du coût élevé de développement d'un
mécanisme de contrôle de banc de montage précis à l'image près, la seule
utilisation actuelle des lots est l'enregistrement de différents programmes à
différentes heures de la journée.  C'est aussi utile pour enregistrer des
émissions de télévision ou des films en différé comme le savent bien tous ceux
qui n'ont pas les moyens d'acquérir les appareils adéquats.

La fenêtre d'enregistrement gère une liste de lots et deux modes
d'enregistrement : le mode interactif et le mode par lots.  Le mode interactif
est utilisé lorsque le bouton d'enregistrement est pressé.  L'enregistrement
interactif démarre immédiatement et utilise le lot en cours pour tout
déterminer sauf l'instant de départ.  Par défaut, le lot en cours est configuré
pour se comporter comme une bande magnétique.

L'enregistrement par lots se produit lorsque le bouton @b{Démarrer} est pressé.
Dans l'enregistrement par lots, l'instant de départ est le moment où le lot
commence à s'enregistrer.

Il vous faudra d'abord créer un certain nombre de lots.  A chaque lot
s'appliquent certains paramètres et certaines méthodes d'ajustement.

@itemize @bullet

@item @b{Activer}@*
Indique que le lot doit faire partie d'une opération d'enregistrement.  Un clic
sur la ligne de la liste sous @b{Activer} active ou désactive le lot.

@item @b{Chemin}@*
C'est le chemin vers le fichier que vous allez enregistrer.  Le nom de fichier
indiqué dans le dialogue d'enregistrement est le nom du premier lot, pour
simplifier l'enregistrement interactif, mais le nom de fichier peut être
modifié dans la fenêtre d'enregistrement pour chaque lot dans la zone
d'@b{édition du lot}.

@item @b{Nouveau}@*
Indique si le fichier existe ou pas.  Comme il n'y a pas de dialogue de
confirmation si le fichier existe déjà, c'est un attribut très important.  La
première fois que vous pressez Enregistrer, le fichier est ouvert.  Si à ce
moment, le fichier existe déjà, il est supprimé.  Ce champs aura la valeur
@b{fichier existant} s'il existe et @b{Ok} s'il n'existe pas.  Chaque fois que
vous reprenez un enregistrement dans le même lot, @b{Ouvert} devrait être
indiqué, signifiant que le fichier est déjà ouvert et qu'il ne sera pas effacé
la prochaine fois que vous presserez le bouton d'enregistrement.@*
Si vous modifiez la sortie du lot en cours après l'enregistrement, le fichier
est fermé.  La prochaine fois que vous modifierez le lot, le fichier sera
effacé.

@item @b{Instant de départ}@*
C'est l'heure du jour, en format 24 heures, à laquelle l'enregistrement en mode
par lots doit commencer.  L'instant de départ peut devenir un instant sur bande
et un numéro de bobine si un contrôle de banc est implémenté mais pour
l'instant, il ne s'agit que de l'heure du jour.

@item @b{Durée}@*
Ceci est la durée du lot.  Il n'a de signification que si le @b{mode} du lot
est @b{temporisé}.  Une fois que la longueur de l'enregistrement a atteint
@b{durée}, l'enregistrement s'arrête, que ce soit en mode interactif ou en mode
par lots.

@item @b{Source}@*
Ceci n'a de signification que lorsque la matériel effectuant l'acquisition
possède plusieurs sources.  Habituellement, la source est le canal ou l'entrée
d'un tuner.  Lorsque le lot en cours se termine et que le lot suivant commence
son enregistrement, la source est modifiée en fonction de ce qui est indiqué
pour le lot suivant.  De cette manière, de nombreuses chaînes de télévision
peuvent être enregistrées à des moments différents.
@end itemize

La fenêtre d'enregistrement comporte la notion de @b{lot en cours}.  Le lot en
cours n'est pas le même que le lot en surbrillance dans la liste des lots.  Le
lot en cours est de couleur rouge dans la liste des lots.  Le lot en
surbrillance est simplement affiché dans la section d'édition du lot pour
pouvoir être édité.

En mettant en rouge le lot en cours, chaque lot peut être édité en le mettant
en surbrillance, sans pour autant modifier le lot qui doit être enregistré.

Toutes les opérations d'enregistrement sont effectuées dans le lot en cours.
S'il y a plusieurs lots, mettez le lot désiré en surbrillance et cliquez
@b{Activer} afin qu'il devienne le lot en cours.  Si le bouton @b{Démarrer} est
pressé, le lot en cours clignote pour indiquer qu'il est en attente de
l'instant de départ en mode de traitement par lots.  Si le bouton
@b{Enregistrer} est pressé, le lot en cours est enregistré immédiatement en
mode interactif.

Dans les modes d'enregistrement par lot ou interactif, lorsque le lot en cours
se termine, le lot suivant est activé et exécuté.  Tous les enregistrements
suivants sont effectués en mode de traitement par lots.  Lorsque le premier lot
se termine, le lot suivant clignote jusqu'à ce que l'instant de départ soit
atteint.

Le bouton @b{Arrêter} permet d'arrêter le lot ou l'opération interactive en
cours.

Enfin, il y a le bouton @image{manual_images_intl/rewind} de retour arrière.
Dans les modes d'enregistrement par lots ou interactif, le bouton de retour
arrière permet de fermer le fichier du lot en cours.  L'opération
d'enregistrement suivante du lot en cours effacera le fichier.

@c cincvdoc_node_number_252
@node Editer les informations du tuner
@subsection Editer les informations du tuner
@cindex Editer les informations du tuner
@cindex Tuner, éditer les informations

Vous aurez parfois besoin, dans le processus d'enregistrement et dans le
processus de configuration, de définir et de sélectionner des canaux du tuner
soit pour l'enregistrement, soit pour la lecture.  Dans le cas de
l'enregistrement avec les pilotes d'enregistrement Video4Linux et Buz, les
canaux du tuner définissent la source.  Lorsque le pilote Buz est aussi utilisé
pour la lecture, les canaux du tuner définissent la destination.

La définition des canaux du tuner est obtenue en pressant le bouton de canal
@image{manual_images_intl/channel}.  Ceci permet d'afficher la fenêtre d'édition
des canaux.  Dans cette fenêtre, vous pouvez ajouter, modifier et classer les
canaux.  Avec certains pilotes vidéo, vous pouvez aussi ajuster la qualité de
l'image.

L'opération d'@b{ajout} provoque l'affichage d'une boîte d'édition du canal.
Le titre du canal apparaît dans la liste des canaux.  La source du canal est
l'entrée physique dans la table de fréquences du tuner correspondant au titre.

L'ajustement fin dans le dialogue d'édition ajuste légèrement la fréquence si
le pilote le gère.  La norme et la table de fréquences définissent ensemble la
table de fréquences qui sera choisie pour définir les sources.  Si le
périphérique peut gérer plusieurs entrées, le menu d'entrée permet de la
sélectionner.

Pour trier les canaux, mettez le canal en surbrillance et pressez @b{déplacer
vers le haut} ou @b{déplacer vers le bas} afin de le déplacer.

Une fois les canaux définis, l'entrée @b{source} dans la fenêtre
d'enregistrement peut être utilisée pour choisir les canaux vers lesquels sera
effectué l'enregistrement.  Une possibilité identique existe aussi dans la
fenêtre d'enregistrement.  Notez que les sélections de canaux dans la fenêtre
d'enregistrement et dans la fenêtre du moniteur sont enregistrées dans le lot
en cours.

Avec certains pilotes, une option permettant de @b{permuter les champs} est
affichée.  Ces pilotes ne permettent pas d'avoir les champs dans le bon ordre
sans une intervention humaine.  Cochez cette option pour avoir les lignes
paires et impaires enregistrées dans l'ordre correct.

@c cincvdoc_node_number_253
@node Acquisition en utilisant dvgrab
@section Acquisition en utilisant dvgrab
@cindex Acquisition en utilisant dvgrab

Dvgrab est un très bon outil en ligne de commande simple à utiliser pour faire
de l'acquisition vidéo depuis un caméscope DV@.  Lorsqu'il est appelé, il va
automatiquement mettre votre caméscope en mode lecture, et commencer à
enregistrer les vidéo sur votre disque dur.  Les fichiers vidéos seront
numérotés séquentiellement comme @w{ceci :} @file{001.avi}, @file{002.avi} et
ainsi de suite.

Pour installer dvgrab, utilisez le mécanisme d'installation de votre
distribution préférée (apt, rpm, deb, etc.) ou référez-vous à la page Web de
dvgrab.

Faire l'acquisition vidéo en quatre étapes simples :
@enumerate 1
@item Créer un répertoire où vous désirez enregistrer les vidéos
@item @command{cd} dans ce répertoire
@item @w{Entrez :} @command{dvgrab --buffers 500} et @kbd{Entrée}
@item Pressez @kbd{CTRL-C} pour interrompre l'acquisition vidéo
@end enumerate

L'option @option{--autosplit} est très utile.  Elle découpe les scènes en
fonction du code temporel.  Cependant, ceci ne fonctionne que lors de
l'acquisition depuis un caméscope DV@.  Ceci ne fonctionnera pas depuis un
convertisseur analogique/numérique tel qu'un Canopus ADVC110.

Lisez le manuel de dvgrab afin d'obtenir davantage d'informations concernant
ses fonctionnalités.

@c cincvdoc_node_number_254
@node Le rendu de fichiers
@chapter Le rendu de fichiers
@cindex Rendu de fichiers
@cindex Fichiers, rendu

Le rendu prend une section de la timeline, réalise tout le montage, applique
les effets et la composition et effectue l'enregistrement dans un fichier de
sortie.  Vous pouvez alors supprimer tous les objets source, lire le fichier
issu du rendu dans un lecteur ou le réimporter dans Cinelerra pour y poursuivre
le montage.  Il est cependant très difficile de retoucher les décisions de
montage lorsque le fichier est rendu, c'est pourquoi il vous est conseillé de
conserver les objets d'origine et le fichier XML de montage pendant quelques
jours après que vous en ayez effectué le rendu.

Toutes les opérations de rendu sont basées sur une région de la timeline.  Vous
devez définir cette région sur la timeline.  La section sur la navigation
décrit des méthodes pour définir des régions.  @xref{La barre temporelle}.  Les
fonctions de rendu définissent la région en se basant sur un jeu de règles.
Lorsqu'une région est en surbrillance ou lorsque les points d'entrée/sortie
sont placés, le rendu de la région affectée est effectué.  Lorsqu'il n'y a pas
de région en surbrillance, tout ce qui se trouve après le point d'insertion est
rendu.  En plaçant simplement le point d'insertion au début d'une piste et en
désélectionnant les points d'entrée/sortie, la piste toute entière est rendue.

@menu
* Rendu d'un seul fichier::	Effectuer le rendu d'un fichier unique
* Rendu dans des fichiers séparés::
* Stratégie d'insertion des fichiers rendus::
* Rendu par lots::            	Rendu sans intervention de l'utilisateur
* La grappe de rendu::		Rendu en utilisant de nombreux ordinateurs
* Rendu en ligne de commandes:: Effectuer le rendu de plusieurs fichiers sans interface graphique
* Rendu de vidéos pour internet::
* Charte de compatibilité de Quicktime pour GNU/Linux::
* Faire un DVD::
* Utiliser le rendu en tâche de fond::
@end menu

@c cincvdoc_node_number_255
@node Rendu d'un seul fichier
@section Rendu d'un seul fichier
@cindex Rendu, d'un seul fichier

La manière la plus rapide de finaliser votre vidéo sur le disque est d'utiliser
la fonction de rendu d'un seul fichier.

Allez dans @b{Afficher->Rendu} ou pressez @kbd{MAJ-R} pour afficher le dialogue
de rendu.  Choisissez la loupe @image{manual_images_intl/magnify,7mm} pour
afficher un dialogue de sélection de fichier.  Ceci permet de définir le nom du
fichier vers lequel il faudra écrire les données issues du rendu et de définir
les paramètres d'encodage.

@center @image{manual_images_intl/render_window,80mm}
@center @b{La fenêtre de rendu}

Dans le dialogue de rendu, choisissez un @b{Format de fichier}.  Le format du
fichier détermine si vous pouvez effectuer le rendu d'audio, de vidéo ou des
deux à la fois.  Cochez la case @b{Rendu des pistes audio} pour créer des
pistes audio et @b{Rendu des pistes vidéo} pour créer des pistes vidéo.

Sélectionnez la clé @image{manual_images_intl/wrench,4.33mm} qui se trouve près
de chacune des cases afin de déterminer les paramètres de compression.  Si le
format du fichier ne permet pas d'enregistrer de l'audio ou de la vidéo les
paramètres de compression seront vierges.  Si vous avez choisi @b{Rendu des
pistes audio} ou @b{Rendu des pistes vidéo} et que le format du fichier ne le
gère pas, une fenêtre d'erreur sera affichée.

@c cincvdoc_node_number_256
@node Rendu dans des fichiers séparés
@section Rendu dans des fichiers séparés
@cindex Rendu dans des fichiers séparés

La case à cocher @b{Créer un nouveau fichier à chaque marque} provoquera la
création d'un nouveau fichier chaque fois qu'une marque sera rencontrée sur la
timeline.  Ceci est utile pour séparer de longs enregistrements audio en des
fichiers séparés.  Lorsque vous utilisez la grappe de calcul, @b{Créer un
nouveau fichier à chaque marque} entraînera la création d'une nouvelle tâche à
chaque marque plutôt que de d'utiliser l'algorithme interne d'équilibrage de la
charge pour espacer les tâches.

Lorsque @b{Créer un nouveau fichier à chaque marque} est sélectionné, un
nouveau nom de fichier est créé pour chaque fichier de sortie.  Si le nom de
fichier donné dans le dialogue de rendu contient un nombre sur deux chiffres,
ce nombre sera réécrit avec un nombre différent qui sera incrémenté pour chacun
des fichiers de sortie.  Si deux chiffres ne sont pas renseignés, Cinelerra
concaténera automatiquement, pour chacun des fichiers de sortie, un nombre à la
fin du nom de fichier indiqué.

Dans le nom de fichier @file{/hmov/track01.wav}, le @samp{01} sera réécrit pour
chaque fichier de sortie.  Cependant, le nom de fichier @file{/hmov/track.wav},
deviendra @file{/hmov/track.wav001} et ainsi de suite.  La modification des
noms de fichiers n'est utilisée que lorsque la grappe de calcul est active ou
lorsque l'option @b{Créer un nouveau fichier à chaque marque} a été
sélectionnée.

@c cincvdoc_node_number_257
@node Stratégie d'insertion des fichiers rendus
@section Stratégie d'insertion des fichiers rendus
@cindex Stratégie d'insertion des fichiers rendus

Enfin, le dialogue de sortie vous permet de choisir le mode d'insertion.  Les
modes d'insertion sont identiques à ceux du chargement de fichiers.  Dans ce
cas, si vous choisissez de @b{ne rien insérer}, le fichier sera écrit sur le
disque sans modifier le projet actuel.  Pour les autres stratégies d'insertion,
assurez-vous d'avoir préparé la timeline afin que la sortie soit insérée au bon
endroit avant que l'opération de rendu ne soit effectuée.  @xref{Le montage}.
Le @b{montage} décrit comment faire pour que la sortie soit insérée au bon
endroit.

Il faut noter que même si vous ne voulez effectuer le rendu que de l'audio ou
que de la vidéo, une stratégie d'insertion de type @b{coller} se comportera
comme une opération de coller normale, toute région de la timeline sélectionnée
sera effacée et seules les données rendues seront collées.  Si vous ne rendez
que de l'audio et que vous avez des pistes vidéo armées, les pistes vidéo
seront tronquées lorsque l'audio sera collé sur les pistes audio.

@c cincvdoc_node_number_258
@node Rendu par lots
@section Rendu par lots
@cindex Rendu par lots

Si vous voulez effectuer le rendu de nombreux projets vers des fichiers de
média sans avoir à utiliser de manière répétitive le dialogue de @b{rendu}, le
@b{rendu par lots} est la fonction à utiliser.  Dans cette fonction, vous
indiquerez toutes les EDL dont il faut effectuer le rendu avec les fichiers de
sortie correspondant.  Cinelerra va alors charger chaque fichier EDL et
effectuer le rendu automatiquement, sans intervention de l'utilisateur.  Chaque
EDL et sa sortie associée est appelé @b{lot}.  Ceci permet de traiter un très
gros volume de média et améliore beaucoup la rentabilité d'un ordinateur
coûteux.

La première chose à faire lors de la préparation d'un rendu par lots est de
définir les projets dont il faut effectuer le rendu.  Définissez un projet et
indiquez la région devant être rendue soit en la mettant en surbrillance, soit
en l'encadrant par les points d'entrée/sortie ou la faisant précéder du point
d'insertion.  Enregistrez alors le projet sous forme d'EDL@.  Définissez de
cette manière autant de projets que nécessaire.  Le rendu par lots récupère la
région active du fichier EDL pour le rendu.

Lorsque tous les fichiers EDL sont prêts avec leur région active, sélectionnez
l'entrée de menu @b{Fichier->Rendu par lots}.  Le dialogue de rendu par lots
s'affichera alors.  L'interface pour le rendu par lots est un peu plus
compliquée que pour le rendu d'un seul fichier.

Il faut, avant de lancer une opération de rendu par lots, créer une liste des
lots.  La table des lots qui apparaît en bas du dialogue de rendu par lots est
appelé @b{Lots dont il faut effectuer le rendu}.  Au-dessus de ce tableau
figurent les paramètres de configuration pour un lot.

Définissez le @b{chemin de sortie}, le @b{format de fichier}, l'@b{Audio}, la
@b{Vidéo} et le paramètre @b{Créer un nouveau fichier à chaque marque} comme
s'il s'agissait d'un seul fichier.  Ces paramètres ne s'appliquent qu'à un seul
lot.  En plus des paramètres de rendu habituels, vous devez indiquer le fichier
EDL source à utiliser pour le lot.  Faites-le en indiquant le @b{chemin vers
l'EDL}.

Si la liste des @b{lots dont il faut effectuer le rendu} est vide ou si rien
n'est en surbrillance, cliquez sur @b{Nouveau} pour créer un nouveau lot.  Le
nouveau lot se verra affecter tous les paramètres que vous venez juste de
définir.

En pressant plusieurs fois le bouton @b{Nouveau}, vous allez créer d'autres
lots avec les mêmes paramètres.  Mettez en surbrillance un lot pour pouvoir
modifier sa configuration depuis la partie supérieure de la fenêtre de rendu
par lots.  Les informations affichées correspondent toujours au lot en
surbrillance.

Il suffit de cliquer-glisser les lots pour modifier l'ordre avec lequel le
rendu sera effectué.  Cliquez sur @b{Supprimer} pour supprimer définitivement
le lot en surbrillance.

Il y a dans la liste une colonne qui permet d'activer ou de désactiver un lot.
De cette manière, des lots peuvent être sautés lors du rendu sans être
supprimés.  Cliquez sur la case @b{Activé} dans la liste pour activer ou
désactiver un lot.  Si elle est cochée, le lot sera rendu.  Si elle est vide,
le lot sera sauté.

Les autres colonnes de la liste des lots ne sont là que pour donner des
informations.
@itemize @bullet
@item @b{Sortie} chemin vers la sortie du lot.
@cindex EDL
@item @b{EDL} EDL source du lot.
@item @b{Temps écoulé} temps ayant été nécessaire pour effectuer le rendu du
lot s'il est terminé.
@end itemize

Pour lancer le rendu en commençant par le premier lot, cliquez sur
@b{Démarrer}.

Lorsque le rendu est en cours, la fenêtre principale affiche l'avancement du
lot.  Une fois le lot terminé, la colonne @b{Temps écoulé} dans la liste des
lots est mise à jour et le lot suivant est rendu jusqu'à ce que tous les lots
activés soient rendus.  Le lot en cours de rendu est affiché en rouge.

Pour arrêter le rendu avant que les lots ne soient terminés sans fermer le
dialogue de rendu par lots, cliquez @b{Arrêter}.

Pour arrêter le rendu avant que les lots ne soient terminés en fermant le
dialogue de rendu, cliquez sur @b{Abandonner}.

Pour quitter le dialogue de rendu qu'il y ait ou non un rendu en cours, cliquez
sur @b{Abandonner}.

@c cincvdoc_node_number_259
@node La grappe de rendu
@section La grappe de rendu
@cindex Rendu, grappe de

Lorsqu'une interpolation bicubique avec de la HDTV a été réalisée pour la
première fois dans Cinelerra, le temps nécessaire pour produire la moindre
sortie devint inacceptable, même sur la machine la plus rapide disponible
alors, un double Xeon 1,7 GHz.  La grappe de calcul, même dans sa forme la plus
simple, permit de mettre la HDTV au même niveau que la SD tout en rendant la SD
plus rapide que le temps réel.

Bien que l'interface de la grappe de calcul ne soit pas spectaculaire, il est
suffisamment simple à utiliser depuis une suite de montage avec moins d'une
douzaine de noeuds sans avoir les complications de que vous auriez à configurer
une grappe de calcul de plusieurs centaines de noeuds.  La grappe de calcul est
appelée de manière transparente pour toutes les opérations de rendu effectuées
depuis @b{Fichier->Rendu} une fois qu'elle a été activée dans les préférences.

Cinelerra divise la région choisie de la timeline en un certain nombre de
tâches qui sont ensuite réparties entre les différents noeuds en fonction de
l'équilibre de la charge.  Les noeuds traitent les tâches et écrivent leur
sortie vers des fichiers séparés du système de fichiers.  Les fichiers de
sortie ne sont pas concaténés.  Il est important que tous les noeuds aient
accès aux objets sur le même système de fichiers associé au même point de
montage.

Si un noeud ne peut pas avoir accès à un objet d'entrée, il affichera un
message d'erreur sur sa console mais ne plantera probablement pas.  S'il ne
peut pas avoir accès aux objets en sortie, cela arrêtera le rendu.

Il faut noter que, dans le dialogue de rendu, l'option @b{Créer un nouveau
fichier à chaque marque} créera une nouvelle tâche pour la grappe de calcul à
chaque marque plutôt que de les voir crées par le système d'équilibrage de
charge.  Si cette option est sélectionnée alors qu'il n'existe aucune marque,
une seule tâche sera créée.

Une grappe de calcul de Cinelerra est organisée avec un noeud principal et un
nombre quelconque de noeuds secondaires.  Le noeud principal est l'ordinateur
sur lequel tourne l'interface graphique.  Les noeuds secondaires se trouvent
n'importe où sur le réseau et sont lancés en ligne de commande.  On lance un
noeud secondaire avec la commande @command{cinelerra -d}

C'est la configuration la plus simple.  Entrez @command{cinelerra -h} pour
obtenir l'ensemble des options disponibles.  Le numéro de port par défaut peut
être modifié en passant en paramètre un numéro de port après @option{-d}.

La plupart du temps, vous désirerez aller dans la sortie rendue et ajuster les
temps sur la timeline.  Mais certains formats de fichiers comme MPEG ne peuvent
pas être copiés directement.  C'est pour cette raison que les fichiers sont
laissés sous forme de fichiers séparés.

Vous pouvez les charger en créant de nouvelles pistes et en indiquant
@b{Ajouter aux pistes existantes} dans le dialogue de chargement.  Les fichiers
qui autorisent la copie directe peuvent être concaténés dans un fichier unique
en effectuant le rendu dans le même format de fichier, la grappe de calcul
étant désactivée.  Pour pouvoir effectuer une copie directe, la taille de la
piste, les dimensions en sortie et les dimensions des objets doivent aussi être
identiques.

Les fichiers MPEG ou les fichiers qui ne permettent pas la copie directe
doivent être concaténés avec un utilitaire en ligne de commande.  Les fichiers
MPEG peuvent être concaténés avec la commande @b{cat}.

La configuration de la grappe de calcul est décrite dans le chapitre sur la
configuration.  @xref{La grappe de calcul}.  Traditionnellement, les noeuds
secondaires lisent et écrivent les données vers un système de fichiers par
l'intermédiaire du réseau et ils n'ont donc pas besoin de disque dur.

Idéalement, tous les noeuds d'une grappe de calculs devraient avoir les mêmes
caractéristiques de CPU@.  Cinelerra effectue l'équilibrage de la charge sur la
base du premier arrivé, premier servi.  Si le dernier segment est affecté au
noeud le plus lent, tous les noeuds plus rapides attendront que le noeud le
plus lent ait terminé alors qu'ils auraient pu en effectuer le rendu plus
rapidement.

@c cincvdoc_node_number_260
@node Rendu en ligne de commandes
@section Rendu en ligne de commandes
@cindex Rendu en ligne de commandes
@cindex Rendu, ligne de commandes

Le rendu en ligne de commandes est une manière de charger le jeu actuel de
tâches de rendu par lots et de les traiter sans interface graphique.  C'est
utile si vous avez un système X qui plante souvent ou si vous désirez effectuer
le rendu par l'intermédiaire d'une liaison réseau à faible débit.  Vous pouvez
avoir accès à un supercalculateur en Inde mais être coincé en Amérique,
peut-être exilé.  Une interface en ligne de commande est idéale pour
solutionner ce problème.

Pour effectuer le rendu depuis la ligne de commandes, lancez d'abord Cinelerra
en mode graphique.  Allez dans le menu @b{ Fichier->Rendu par lots}.  Créez les
lots dont vous désirez effectuer le rendu dans la fenêtre de rendu par lot et
fermez la fenêtre.  Ceci enregistre les lots dans un fichier.  Configurez les
attributs voulus pour la grappe de calcul dans @b{Configuration->Préférences}
et quittez Cinelerra.  Ces paramètres sont utilisés lorsque le rendu en ligne
de commandes est utilisé par la suite.

Sur la ligne de commandes, @w{entrez :} @command{cinelerra -r}

pour traiter le lot de travaux en cours sans interface graphique.  La
configuration de tous les paramètres pour cette opération est compliquée.
C'est pourquoi la ligne de commande s'arrête si un des quelconques fichiers de
sortie existe déjà.

Il existe d'autres paramètres pour indiquer des fichiers de remplacement pour
les préférences et les lots.  Une tentative pour utiliser autre chose que les
valeurs par défaut est assez risquée et n'a donc pas été testée.

@c cincvdoc_node_number_262
@node Rendu de vidéos pour internet
@section Rendu de vidéos pour internet
@cindex Rendu de vidéos pour internet

@menu
* Encoder une vidéo au format MPEG4 pour internet::
* Encoder une vidéo au format FLV pour internet::
@end menu

Si vous désirez réencoder votre fichier rendu avec mencoder, nous vous
recommandons d'en effectuer son rendu sous forme de fichier Quicktime4linux, et
d'ensuite encoder ce fichier dans les formats MPEG4 ou FLV@.  Le fichier
Quicktime4linux rendu depuis Cinelerra doit avoir les propriétés @w{suivantes :}

@itemize @bullet
@item Options Audio : Complément à deux 16bits (PCM)
@item Options Vidéo : DV
@end itemize

@c cincvdoc_node_number_329
@node Encoder une vidéo au format MPEG4 pour internet
@subsection Encoder une vidéo au format MPEG4 pour internet
@cindex Encoder une vidéo au format MPEG4 pour internet

Pour obtenir la meilleure qualité possible, vous devez encoder votre fichier
Quicktime4linux en deux passes.

@b{Première passe :}
@verbatim
mencoder input.mov -ovc xvid -xvidencopts bitrate=600:pass=1 \
-vf scale=320:240 -oac mp3lame -lameopts abr:br=64 -o output.avi
@end verbatim
@b{Seconde passe :}
@verbatim
mencoder input.mov -ovc xvid -xvidencopts bitrate=600:pass=2 \
-vf scale=320:240 -oac mp3lame -lameopts abr:br=64 -o output.avi
@end verbatim
N'oubliez pas de changer la dimension de la vidéo encodées, en utilisant
l'option @option{-vf scale=}.@*

Voici d'autres lignes de commandes.  Elles procurent des fichiers vidéos dont le poids
est d'environ 13 Mb pour 3 minutes.@*
@b{Première passe :}
@verbatim
mencoder -oac pcm -sws 2 -vf scale=${width}:${height},hqdn3d=2:1:2 \
-ovc lavc -lavcopts vcodec=mpeg4:vbitrate=${video_bitrate}:vlelim=-4:\
vcelim=7:lumi_mask=0.05:dark_mask=0.01:scplx_mask=0.3:naq:v4mv:mbd=2:\
trell:cmp=3:subcmp=3:mbcmp=3:aspect=4/3:sc_threshold=1000000000:\
vmax_b_frames=2:vb_strategy=1:dia=3:predia=3:cbp:mv0:preme=2:\
last_pred=3:vpass=1:cgop -ofps 25 -of avi movie.mov -o /dev/null\
-ffourcc DIVX
@end verbatim
@b{Seconde pass :}
@verbatim
mencoder -srate 32000 -oac mp3lame -lameopts cbr:br=${audio_bitrate}:\
aq=0 -sws 2 -vf scale=${width}:${height},hqdn3d=2:1:2 -ovc lavc\
-lavcopts vcodec=mpeg4:vbitrate=${video_bitrate}:vlelim=-4:vcelim=7:\
lumi_mask=0.05:dark_mask=0.01:scplx_mask=0.3:naq:v4mv:mbd=2:trell:\
cmp=3:subcmp=3:mbcmp=3:aspect=4/3:sc_threshold=1000000000:\
vmax_b_frames=2:dia=3:predia=3:cbp:mv0:preme=2:last_pred=3:vpass=3:\
cgop -ofps 25 -of avi movie.mov -o movie.avi -ffourcc DIVX
@end verbatim

Vous devrez probablement adapter ces lignes de commandes si l'image de la vidéo
originale comprend beaucoup de bruit; renseignez-vous sur les filtres de
pré-traitement de mencoder.  Les paramètres *_mask sont très important lors
d'un encodage à un faible débit binaire.@*

Si vous voulez que votre fichier vidéo soit affiché correctement dans un
visualisateur de vidéo très connu sous Windows, vous devez @w{savoir que :}
@itemize @bullet
@item l'information de ratio d'aspect contenue dans l'entête du fichier AVI ne
sera pas prise en compte par ce lecteur.  C'est pourquoi vous devez
redimenssionner vous-même l'image au bon ratio d'aspect.  La largeur et la
hauteur doivent être des multiples de 16.  Voici les résolutions recommandées
pour des vidéos en 4/3 au @w{format PAL :} 384:288, 448:336, 512:384 or
704:528.
@item ce visualisateur de vidéo fonctionnant sous Windows va perdre la
synchronisation audio/vidéo si un débit binaire variable (VBR) est utilisé pour
l'audio, à la place d'un débit binaire constant (CBR).
@item Le paramètre @option{-ffourcc} est nécessaire afin que le codec vidéo
soit reconnu en tant que Divx.
@end itemize

@c cincvdoc_node_number_330
@node Encoder une vidéo au format FLV pour internet
@subsection Encoder une vidéo au format FLV pour internet
@cindex Encoder une vidéo au format FLV pour internet

Le poids des fichiers FLV (FLash Video) est très petit et les seuls composants
qui soient nécessaires pour les afficher est un navigateur internet et un
greffon flash version 7 ou supérieur installé.  Ce format est vraiment utile
pour les personnes qui désirent partager leur vidéo avec une large audience sur
internet.

@b{Première passe :}
@verbatim
ffmpeg -i movie.mov -b 430 -s 320x240 -aspect 4:3 -pass 1 -ar 22050 movie.flv
@end verbatim
@b{Seconde passe :}
@verbatim
ffmpeg -i movie.mov -b 430 -s 320x240 -aspect 4:3 -pass 2 -ar 22050 movie.flv
@end verbatim

Faites attention à l'extension du nom de fichier de sortie.  Ffmpeg l'utilise
pour déterminer le format de sortie.  La fréquence d'échantillonnage de l'audio
à utiliser est de 22050 et le paramètre @option{-ar} doit être utilisé pour
permettre à la vidéo d'être correctement encodée.  Ffmpeg n'écrit pas de
méta-données dans le fichier flv.  La durée doit être écrite dans ces
meta-données afin que certains visualisateur flash puissent afficher une barre
de progression de la lecture.  FLVTool2
(@uref{http://www.inlet-media.de/flvtool2}) peut être utilisé afin d'insérer
cette @w{information :}
@verbatim
cat fichier_entree.flv | flvtool2 -U stdin fichier_sortie.flv
@end verbatim

@c cincvdoc_node_number_328
@node Charte de compatibilité de Quicktime pour GNU/Linux
@section Charte de compatibilité de Quicktime pour GNU/Linux
@cindex Charte de compatibilité de Quicktime pour GNU/Linux

Scott Frase a écrit une charte de compatibilité de Quicktime pour GNU/Linux.  Elle
comprend une liste exhaustive des tous les schémas de compression Quicktime
disponibles et de leur compatibilité avec Cinelerra, Mplayer et autres
logiciels de lecture de de médias.  Ce document comporte deux parties
principales, une est basée sur un projet formaté selon une résolution HDV et
une autre basée sur un projet dans une résolution au format DV.

Il se trouve disponible @w{ici :}@*
@uref{http://content.serveftp.net/video/qtcompatibility.ods}

Quelques notes intéressantes :
@itemize @bullet
@item Mplayer se comporte mieux avec la résolution vidéo DV, plus faible
@item La compatibilité de Cinelerra avec des fichiers rendus depuis un projet
DV n'est pas très différente de sa compatibilité avec des fichiers rendus
depuis un projet HDV.
@item Elle comporte une charte de comparaison de compatibilité DV/HDV
mplayer/Cinelerra
@end itemize

@c cincvdoc_node_number_263
@node Faire un DVD
@section Faire un DVD
@cindex Faire un DVD
@cindex DVD, faire un

@menu
* Rendu vers mpeg2::
* Faire un menu de DVD::
* Créer un DVD::
* Graver un DVD::
@end menu

@c cincvdoc_node_number_264
@node Rendu vers mpeg2
@subsection Rendu vers mpeg2
@cindex Rendu vers mpeg2
@cindex mpeg2, rendu vers

Voici une méthode pour exporter une vidéo mpeg2 et réaliser un DVD ne
comportant qu'un seul chapitre.  Cette méthode vous permet de définir
précisément les options d'encodage que vous désirez et produit un fichier mpeg2
100% compatible avec tous les lecteurs de DVD de salon.

Le programme mplex, qui fait partie de @b{mjpegtools} doit être installé.  Le
paquet mjpegtools fait partie de la distribution hvirtual et l'utilitaire mplex
peut en être extrait.

Assurez-vous d'abord que vous avez correctement défini votre format de projet
Cinelerra avant d'effectuer le rendu de votre vidéo (menu
@b{Configuration->Format}).  En PAL, il d'agit de 720x576 à 25 images/seconde,
et en NTSC, il s'agit de 720x480 à 29,97 images par seconde.

@enumerate 1
@item Créez un script @file{~/cine_render.sh}
@item Copiez dans le fichier @file{~/cine_render.sh file} les lignes
@w{suivantes :}@*
@command{#/bin/bash}@*
@command{mpeg2enc -v 0 -K tmpgenc -r 16 -4 1 -2 1 -D 10 -E 10 -g 15 -G 15 -q 6
-b 8600 -f 8 -o $1}
@item Donnez les droits d'exécution à ce fichier :
@command{chmod 777 ~/cine_render.sh}
@item Lancez Cinelerra, et sélectionnez la partie de la vidéo dont vous désirez
effectuer le rendu à l'aide des points [ et ]
@item Pressez @kbd{MAJ-R}
@item Sélectionnez le format de fichier @b{YUV4MPEG Stream}
@item Désélectionnez @b{Rendu des pistes audio} et sélectionnez @b{Rendu des
pistes vidéo}
@item Cliquez sur la clé des options
@item Dans la fenêtre qui s'ouvre alors, indiquez le nom du fichier @file{m2v}
que vous désirez créer.  Ce fichier ne comportera que de la vidéo.
@item Cliquez sur @b{Use pipe} et écrivez cette commande :
@command{/home/<your_user>/cine_render.sh %}
@item Cliquez sur OK pour fermer la seconde fenêtre et de nouveau OK pour
effectuer le rendu de votre fichier @file{m2v}
@item Lorsque le rendu du fichier m2v est terminé, ouvrez de nouveau la fenêtre
de rendu, et effectuez le rendu audio d'un fichier AC3 à 224 kbits
@item Enfin, combinez la vidéo et l'audio avec cette @w{commande :}@*
@command{mplex -f 8 votre_fichier_video.m2v votre_fichier_audio.ac3 -o
votre_fichier_audio_et_video.mpeg}@*
Si vous obtenez des erreurs lors de l'appel à mplex, augmentez la valeur du
paramètre de quantification (option @option{-q}, voyez ci-dessous).
@end enumerate

Vous pouvez modifier les paramètres de mpeg2enc si vous le désirez.  Consultez
la page de manuel de mpeg2enc.  Quelques détails concernant les paramètres :
@itemize
@item @w{@option{-b 8600} :} c'est le débit binaire maximum de votre fichier
@file{m2v} (il ne comprend pas le débit binaire audio).  Nous vous recommandons
de ne pas augmenter cette valeur car vous pourriez avoir des erreur en
multiplexant l'audio et la vidéo.
@item @w{@option{-q 6} :} c'est le paramètre de quantification.  Si vous le
réduisez (n'allez pas en-dessous de 3), la qualité s'améliore.  Mais le débit
binaire augmente.  Il est recommandé de conserver le débit binaire moyen obtenu
(il est affiché lorsque vous effectuez le multiplexage des fichiers audio et
vidéo) aux alentours de 10% en-dessous du débit binaire définit avec l'option
@option{-b}.
@item @option{-K tmpgenc} : utilise les matrices d'encodage de TMPGEnc.  Cela
réduit le débit binaire moyen d'environ 10% comparé aux tables par défaut.
Lorsque la vidéo utilisée en entrée est de très bonne qualité, on peut se
passer de cette option.
@end itemize

Si votre matériau est affecté de bruit (support Hi8 analogique par exemple),
vous pouvez ajouter quelques commandes de mjpegtools dans la lignes de
commandes écrite dans @file{~/cine_render.sh} :
@itemize @bullet
@item @command{y4mshift} et @command{y4mscaler} peuvent être utilisés pour
supprimer les bords bruités autour de la vidéo.  Par exemple, ces commandes,
ajoutées au début de la ligne de commande dans le @file{cine_render.sh}
suppriment les bordures noires qui entourent une vidéo @w{Hi8 :}@*
@command{yuvscaler -v 0 -I ACTIVE_700x560+8+8 | y4mshift -n 2 |}
@item @command{yuvdenoise} et @command{yuvmedianfilter} peuvent aider à
supprimer le bruit.  @w{Example :}@*
@command{yuvdenoise -F | yuvmedianfilter -T 3 |}@*
La suppression de bruit est une tâche complexe, et les options indiquées
ci-dessus sont juste un exemple.  Veuillez lire la documentation de mjpegtools
et vous abonner à sa liste de diffusion pour davantage s'informations.
@end itemize

@c cincvdoc_node_number_265
@node Faire un menu de DVD
@subsection Faire un menu de DVD
@cindex Faire un menu de DVD
@cindex DVD, faire un menu de

Un menu de DVD est composé :

@itemize @bullet
@item d'un arrière-plan (image fixe ou vidéo)
@item de boutons
@item de son/musique
@end itemize

Vous pouvez bâtir un menu avec une interface graphique telles que QDVDAuthor,
dvdstyler, dvdwizard ou tovid.  Cependant, l'utilisation de ces interfaces
n'est pas parfaite ou est pour le moment limitée.

Si vous préférez utiliser une interface graphique, nous vous recommandons
d'essayer @w{tovid :}@*
@uref{http://tovid.wikia.com/wiki/Main_Page}@*
QDVDAuthor contenait énormément de bugs il y a quelque temps, mais son auteur
en a corrigé certains, ce qui rend QDVDAuthor plus utilisable.

La méthode que nous expliquons ci-dessous est plus compliquée que l'utilisation
d'une interface graphique, mais cependant :

@itemize @bullet
@item elle produit des DVD lisibles sur tous les lecteurs de salon
@item elle n'est pas sujette à des bogues
@item elle vous fera gagner beaucoup de temps car tout ce que vous aurez à
faire pour créer un nouveau DVD sera d'éditer des fichiers de texte
@end itemize

Voici les étapes nécessaires à la création de votre menu de DVD :

@itemize @bullet
@item créez l'arrière-plan du menu avec Cinelerra
@item ajoutez les boutons en créant des images PNG
@item combinez le menu et les boutons à l'aide de spumux
@end itemize

Supposons que vous désiriez créer un menu avec un arrière-plan animé.  Lancez
Cinelerra et créez un projet contenant l'arrière-plan du menu.  Vous pouvez
ajouter une musique si vous le désirez.  Faites attention au fait que le menu
sera joué en boucle.

Pour dessiner les boutons, vous avez deux @w{possibilités :}

@itemize @bullet
@item affichez-les dans Cinelerra.  De cette manière, il vous sera possible de
faire de boutons animés, comme des vignettes vidéo pour chacune des parties de
votre vidéo.
@item ne pas dessiner les boutons dans in Cinelerra.  Vous les ajouterez plus
tard, depuis des images PNG ajoutées au fichier de menu mpeg2.  Ceci est la
méthode la plus simple mais elle ne vous permet pas d'afficher des boutons
animés.
@end itemize

Effectuez le rendu de cette vidéo en m2v et ac3 en utilisant la méthode
@command{cine_render.sh} expliquée plus haut.  Combinez l'audio et la vidéo en
utilisant mplex comme vous le feriez avec une vidéo normale.

Vous obtenez un fichier mpeg2 qui contient l'arrière-plan du menu, avec
quelques boutons affichés si vous les avez ajoutés dans Cinelerra.

Nous devons utiliser spumux pour définir la position de chacun des boutons dans
le fichier mpeg2.  Si vous n'avez pas dessiné les boutons dans Cinelerra, vous
pourrez les ajouter avec spumux.

Spumux est un utilitaire en ligne de commande qui prend 2 @w{paramètres :}

@itemize @bullet
@item un fichier XML décrivant où se trouvent les boutons
@item le nom du fichier mpeg2 (celui dont vous avez effectué le rendu pour le
menu)
@end itemize

Voici un exemple de fichier XML spumux :
@verbatim
<subpictures>
 <stream>
  <spu start="00:00:00.0" image="buttons_normal.png" highlight=
  "buttons_highlight.png" select="buttons_select.png">
   <button name="1" x0="94 " y0="234 " x1="253 " y1="278"
   down="2" right="4" />
   <button name="2" x0="63 " y0="287 " x1="379 " y1="331" up="1"
   down="3" right="5" />
  </spu>
 </stream>
</subpictures>
@end verbatim

@itemize @bullet
@item @b{image="buttons_normal.png"} cette image png contient les boutons tels
qu'ils apparaîtront lorsqu'ils ne sont pas sélectionnés ni mis en surbrillance.
@item @b{highlight="buttons_highlight.png"} cette image png contient les
boutons dans leur état de surbrillance.
@item @b{select="buttons_select.png} cette image png contient les boutons dans
leur état sélectionné.
@end itemize

Si vous avez déjà fait les boutons depuis Cinelerra, vous devez indiquer ici
des images PNG vides (100% transparentes).

Les images PNG utilisées dans spumux doivent :

@itemize @bullet
@item contenir un @b{canal alpha} (c'est-à-dire gérer la transparence)
@item avoir @b{4 couleurs indexées}.  Vous pouvez facilement convertir une
image sous un format à 4 couleurs indexées en utilisant Gimp.
@end itemize

Il y a une ligne par bouton.  Chaque ligne comporte les coordonnées du bouton,
chaque bouton ayant une forme @w{rectangulaire :}

@itemize @bullet
@item @w{@b{x0, y0}} : angle supérieur gauche
@item @w{@b{x1, y1}} : angle inférieur droit
@end itemize

Vous devez aussi définir quel bouton actionner lors de l'utilisation des
boutons haut, bas, gauche et droite de la télécommande du lecteur de DVD.
Voici un exemple :

@verbatim
<button name="3" ...coordinates... up="1" down="5" left="2" right="4" />
@end verbatim

Lorsque le bouton 3 est sélectionné, si la touche "haut" est pressée sur la
télécommande, alors le bouton 1 sera mis en surbrillance.  Si la touche
"droite" est pressée sur la télécommande, alors le bouton 4 sera mis en
surbrillance.

Lorsque vous avez terminé l'édition de votre fichier XML spumux, vous devez
entrer cette @w{commande :}@*
@command{spumux menu.xml < menu.mpeg > menu_with_buttons.mpeg}@*
Ceci créera le fichier @file{menu_with_buttons.mpeg}.  C'est un fichier mpeg2
avec les boutons.

@c cincvdoc_node_number_266
@node Créer un DVD
@subsection Créer un DVD
@cindex Créer un DVD
@cindex DVD, créer un

Après avoir effectué le rendu de vos fichiers vidéo mpeg2, et après avoir
préparé un menu à l'aide de spumux, vous devez créer le DVD avec dvdauthor.

Dvdauthor utilise des fichiers XML pour décrire la structure du DVD@.  Sa
syntaxe est rigoureuse, et vous devrez faire très attention à la syntaxe du
fichier .xml.  Dans le cas contraire, le risque est que le DVD soit lisible sur
certains lecteurs de salon, mais pas sur tous.

Pour vous aider dans l'utilisation de dvdauthor, voyons quelques exemples de
fichiers XML.

@verbatim
<dvdauthor dest="/chemin/vers/le/dossier/qui/contient/le/dvd">
    <vmgm />
    <titleset>
        <titles>
            <pgc>
                <vob file="/the/mpeg/file.mpeg" />
		<post>
                    jump chapter 1;
                </post>
            </pgc>
        </titles>
    </titleset>
</dvdauthor>
@end verbatim

C'est un fichier XML très simple pour dvdauthor.  Il n'y a pas de menu, le
fichier vidéo @file{/the/mpeg/file.mpeg} sera joué dès que vous insérerez le
DVD dans le lecteur.

La commande entre les balises <post> signifie que la vidéo doit être lue en
boucle.  Quand la platine DVD arrive à la fin de la vidéo, elle se repositionne
au premier chapitre de la vidéo (que dvdauthor assume être le début de la vidéo
puisqu'aucun chapitre n'a été défini).

Pour créer le DVD, entrez juste la commande @w{suivante :}@*
@command{dvdauthor -x simple_example.xml}

Maintenant, voyons un exemple plus complexe.  Lorsque le DVD est inséré, un
menu est affiché et vous avez le choix de la lecture entre 4 vidéos.

@verbatim
<dvdauthor dest="/chemin/vers/le/dossier/qui/contient/le/dvd" jumppad="yes" >
<vmgm>
 <fpc> jump menu 1; </fpc>
  <menus>
   <video format="pal" aspect="4:3" resolution="720x576" />
   <pgc entry="title" >
    <vob file="menu.mpeg" pause="0" />
    <button name="1" > { g3=1; jump titleset 1 menu entry root; } </button>
    <button name="2" > { g3=2; jump titleset 1 menu entry root; } </button>
    <button name="3" > { g3=3; jump titleset 1 menu entry root; } </button>
    <button name="4" > { g3=4; jump titleset 1 menu entry root; } </button>
     <post> { jump cell 1; } </post>
   </pgc>
  </menus>
 </vmgm>
 <titleset>
  <menus>
   <pgc entry="root" >
    <pre> { if ( g3 gt 0 )  {
		if ( g3 eq 1 ) { g3=0; jump title 1  chapter 1; }
		if ( g3 eq 2 ) { g3=0; jump title 1  chapter 3; }
		if ( g3 eq 3 ) { g3=0; jump title 1  chapter 5; }
		if ( g3 eq 4 ) { g3=0; jump title 1  chapter 7; }
		jump vmgm menu entry title;
		}
	} </pre>
    <post> { jump vmgm menu entry title; } </post>
   </pgc>
  </menus>
  <titles>
   <video format="pal" aspect="4:3" resolution="720x576" />
   <pgc pause="0" >
    <vob file="video_1.mpeg" pause="0" />
    <vob file="blackvideo.mpg" pause="0" />
    <vob file="video_2.mpeg" pause="0" />
    <vob file="blackvideo.mpg" pause="0" />
    <vob file="video_3.mpeg" pause="0" />
    <vob file="blackvideo.mpg" pause="0" />
    <vob file="video_4.mpeg" pause="0" />
    <post> { call vmgm menu entry title; } </post>
   </pgc>
  </titles>
 </titleset>
</dvdauthor>
@end verbatim

Le fichier @file{blackvideo.mpg} est utilisé pour ajouter deux secondes
d'affichage noir entre chaque vidéo.  Voici la manière de le @w{créer :}@*
@command{convert -size 720x576 xc:black -depth 8 blackframe.ppm}@*
@command{dd if=/dev/zero bs=4 count=960000 | toolame -b 128 -s 48 /dev/stdin
emptyaudio.mpa}@*
@command{ppmtoy4m -S 420mpeg2 -n 50 -F 25:1 -r blackframe.ppm | mpeg2enc -a 2
-n p -f 8 -o blackvideo.mpv}@*
@command{mplex -f 8 -o blackvideo.mpg blackvideo.mpv emptyaudio.mpa}

@c cincvdoc_node_number_267
@node Graver un DVD
@subsection Graver un DVD
@cindex Graver un DVD

Lorsque vous avez terminé la création du DVD, vous obtiendrez dans le dossier
de destination les répertoires @w{suivants :} @file{AUDIO_TS} et
@file{VIDEO_TS}.  Pour tester votre DVD avant de le graver, allez dans ce
dossier et @w{exécutez :}@*
@command{xine dvd:`pwd`}

Si votre DVD est lu sans problème sur votre ordinateur, c'est le moment de le
graver.  Lorsque vous vous trouvez dans le dossier de qui contient @file{AUDIO_TS}
et @file{VIDEO_TS}, lancez cette @w{commande :} (ajustez pour votre graveur,
par exemple /dev/dvdrw)@*
@command{nice -n -20 growisofs -dvd-compat -speed=2 -Z /dev/dvd -dvd-video -V
VIDEO ./ && eject /dev/dvd}

Si vous avez de nombreuses copies à réaliser, vous pouvez d'abord créer un
fichier master .iso en utilisant cette @w{commande :}@*
@command{nice -n -20 mkisofs -dvd-video -V VIDEO -o ../dvd.iso .}@*
Ce fichier @file{../dvd.iso} peut être gravé en utilisant cette @w{commande :}
@*
@command{nice -n -20 growisofs -dvd-compat -speed=2 -Z /dev/dvd=../dvd.iso &&
eject /dev/cdrom}

Nous vous recommandons de ne pas effectuer de gravure à une vitesse supérieure
à 4x.  Utilisez uniquement des DVD-R de bonne qualité.

Pour tester votre DVD sur une platine de salon sans avoir à gaspiller plusieurs
DVD-R, vous pouvez graver sur des DVD-RW@.  Tout d'abord, formattez votre DVD-RW
en utilisant cette @w{commande :}@*
@command{dvd+rw-format -lead-out /dev/dvd}@*
Vous pouvez alors graver votre DVD-RW en utilisant les commandes qui ont été
indiquées plus haut.

@c cincvdoc_node_number_268
@node Utiliser le rendu en tâche de fond
@section Utiliser le rendu en tâche de fond
@cindex Rendu en tâche de fond, utiliser

Le rendu en tâche de fond permet à des effets très lents d'être joués en temps
réel rapidement après avoir été déposé sur la timeline.  Il effectue en
permanence le rendu vers une sortie temporaire.  Si la grappe de calcul est
active, le rendu en tâche de fond l'utilise en permanence.  De cette manière,
n'importe quelle taille de vidéo peut être affichée en temps réel en créant
simplement un réseau suffisamment rapide avec suffisamment de noeuds

Le rendu en tâche de fond est activé depuis
@b{Configuration->Préférences->Performances}.  Il possède une fonction
@w{interactive :} @b{Configuration->Point de départ du rendu en tâche de fond}.
Ceci définit le point à partir duquel se fait le rendu en tâche de fond.  S'il
y a de la vidéo, une barre rouge apparaît dans la barre temporelle qui indique
ce qui a été rendu en tâche de fond.

Il est souvent utile d'insérer un effet ou une transition et de sélectionner
ensuite @b{Configuration->Rendu en tâche de fond} juste avant l'effet pour le
prévisualiser à la vitesse normale.

@c cincvdoc_node_number_269
@node Astuces
@chapter Astuces
@cindex Astuces

Dans cette partie, vous trouverez des méthodes pour résoudre les problèmes
rencontrés avec Cinelerra.  Cette section est arrangée dans l'ordre des
problèmes rencontrés et des outils à utiliser pour les résoudre.  La section
suivante est arrangée dans l'ordre des outils et de leur usages.

@menu
* Encodage Dolby Pro Logic::
* Nettoyage de la TV analogique::
* Supprimer l'entrelacement::
* Faire ressembler la vidéo à un film::
* Eclaircir la brume::
* Créer une sonnerie::
* Etirement du temps audio::
* Copies d'écran vidéo::
* Améliorer les performances::          faire mieux tourner Cinelerra sous GNU/Linux.
* Traduire Cinelerra::             	comment traduire Cinelerra en différentes langues.
* Effectuer des panoramiques et des zooms dans les images fixes::
* Edition HDV 1080i avec des fichiers proxy::
* Ajouter des sous-titres::
@end menu

@c cincvdoc_node_number_270
@node Encodage Dolby Pro Logic
@section Encodage Dolby Pro Logic
@cindex Encodage Dolby Pro Logic

Le Dolby Pro Logic permet de créer de l'audio sur six canaux en sortie à partir
d'une carte-son à deux canaux avec des résultats variables mais utilisables.
Un encodage Dolby Pro Logic rudimentaire peut être réalisé par une utilisation
intelligente des effets.

Tout d'abord créez les canaux gauche et droite.  Créez deux pistes audio,
chacune portant le canal gauche ou droit.  Avec la commande panoramique, mettez
le canal gauche à gauche, et le canal droit à droite.

Ensuite, créer les canaux arrières gauche et droit.  Créez deux nouvelles pistes
audio comme indiqué plus haut.  Ensuite, appliquez un effet d'@b{inversion
audio} sur les deux pistes, et le signal proviendra des hauts-parleurs
arrières.

Créez une piste audio unique avec de l'audio mono provenant d'une source
différente.  Centrez-la à l'aide de la commande de @b{panoramique}.  Le signal
provient du haut-parleur central.

Créez d'autres pistes avec des signaux différents et ajustez-les latéralement à
gauche ou à droite de façon à envoyer les signaux dans le haut-parleur avant
gauche ou avant droit.

Enfin, si vous désirez une copie du signal du haut-parleur arrière dans un seul
des hauts-parleurs avant, le signal du haut-parleur arrière doit être retardé
d'au moins 0,05 seconde et une seule nouvelle piste doit être créée.  Ajustez
le réglage de panoramique de la nouvelle piste pour orienter le signal vers les
hauts-parleurs avants.

Si vous désirez avoir le même signal dans tous les hauts-parleurs sauf dans le
haut-parleur central, retardez les hauts-parleurs arrière de 0,5 seconde et
retardez soit le haut-parleur avant gauche soit le haut-parleur avant droit de
0,2 seconde.

Si vous désirez entendre quelque chose dans le caisson de grave, créez une
nouvelle piste, choisissez la plage, déposez un effet de synthétiseur avec une
fréquence en-dessous de 60 Hz.  Le caisson de grave reproduira tout ce qui se
trouve en-dessous d'environ 60 Hz.

Une astuce que vous pouvez employer pour séparer les hauts-parleurs est
d'utiliser l'égaliseur paramétrique pour ne reproduire que certaines bandes de
fréquences dans les différents hauts-parleurs et d'utiliser un filtre passe-bas
pour les signaux à destination du caisson de grave.

@c cincvdoc_node_number_271
@node Nettoyage de la TV analogique
@section Nettoyage de la TV analogique
@cindex Nettoyage de la TV analogique
@cindex TV, analogique nettoyage

A moins que vous ne viviez dans une nation opulente comme la Chine ou que vous
ne soyez un terroriste, vous enregistrez probablement de la télé analogique
plutôt que de la télé numérique.  La qualité image de la télé analogique est
horrible mais vous pouvez faire certaines choses dans Cinelerra pour qu'elle
ressemble davantage à ce qu'elle était en studio.

Premièrement, quand vous capturez la vidéo, faites-le dans la résolution la
plus haute possible.  Pour les Européens il s'agit de 720 x 576, et de 720 x
480 pour les Nord-Américains.  Ne vous tracassez pas concernant l'ajustement de
la luminosité ou du contraste sur le moniteur d'enregistrement, bien que
maximiser la couleur soit intéressant.  Effectuez, si possible, la capture en
MJPEG ou dans un mode composantes vidéo non-compressé.  Si c'est trop demander
faites-la en JPEG@.  RVB en dernier ressort.

Maintenant sur la timeline, utilisez @b{Configuration->Format} pour définir un
modèle colorimétrique YUV@.  Glissez un effet de @b{sous-échantillonage} sur le
plan, avec les options suivantes :
@verbatim
Horizontal:        2
Horizontal offset: 0
Vertical:          2
Vertical offset:   0
      red
  x   green
  x   blue
      alpha
@end verbatim

Utilisez l'outil caméra pour décaler l'image d'une ligne vers le haut ou vers
le bas afin enlever le plus d'interférences colorées de l'image.  Voici la
différence obtenue :

@center @image{manual_images_fr/cleaning1}

Si vous avez des informations de suppression verticale ou des ondulations qui
changent constamment pour chaque image, supprimez-les à l'aide de l'outil
@b{masque}.  Ceci permet d'améliorer les taux de compression.

C'est à peu près tout ce que vous pouvez faire sans détruire plus de données
que celles que vous perdrez naturellement lors de la compression.  Des
techniques plus agressives de "nettoyage" mettent en oeuvre le
désentrelacement.

@c cincvdoc_node_number_272
@node Supprimer l'entrelacement
@section Supprimer l'entrelacement
@cindex Entrelacement, supprimer

La plupart des sources vidéo sont entrelacées parce qu'il est beaucoup plus
cher de construire des caméras et des écrans fonctionnant avec un balayage
progressif.  De nombreux amateurs ont été déçus, après avoir dépensé 5 mois de
salaire dans un caméscope, de découvrir les horribles images déchiquetées qu'il
produisait sur un écran d'ordinateur.

Quant aux caméras à balayage progressif, oubliez-les.  Les facteurs de coûts
font que les caméras à balayage progressif mettront encore longtemps avant
d'avoir une résolution équivalente à celle des caméras à balayage entrelacé.
L'entrelacement existera probablement encore longtemps.  C'est pourquoi il y a
un effet de désentrelacement dans Cinelerra.

Nous ne pensons pas qu'il existe d'outil parfait pour l'effet de
désentrelacement.  Soit ils sont irréversibles, soit ils ne fonctionnent pas.
Cinelerra coupe la poire en deux en fournissant des outils de déentrelacement
qui sont parfois irréversibles et qui parfois ne fonctionnent pas.  Mais ils ne
sont jamais l'un, ou l'autre.

@itemize @bullet
@item
@cindex Entrelacement, doublement des lignes
@b{Doublement des lignes}
C'est effectué par l'effet de @b{désentrelacement} lorsqu'il est configuré avec
@b{moyenne des lignes paires} ou @b{moyenne des lignes impaires}.  Lorsqu'il
est appliqué à une piste, il réduit la résolution verticale de moitié et vous
donne des images progressives crénelées.  Ce n'est utile que pour réduire
l'image à la moitié de sa taille.

@item
@cindex Entrelacement, moyenne des lignes
@b{Moyenne des lignes}
L'effet de @b{désentrelacement}, lorsqu'il est configuré pour faire la
@b{Moyenne des lignes paires} ou la @b{Moyenne des lignes impaires} fait
exactement ce que le doublement des lignes fait, sauf qu'au lieu de faire une
simple copie des lignes, il en fait la moyenne.  C'est utile en pratique pour
tous les redimensionnements.@*
Il existe une option pour avoir une moyenne des ligne adaptative, qui
sélectionne les lignes dont il faut effectuer la moyenne et les lignes qu'il
faut laisser entrelacées, en se basant sur la différence entre les lignes.
Elle ne fonctionne pas.

@item
@cindex Entrelacement, télécinéma inverse
@b{télécinéma inverse}
C'est l'outil de désentrelacement le plus efficace lorsque le métrage provient
de la diffusion NTSC d'un film.  @xref{Télécinéma inverse}.

@item
@cindex Entrelacement, correction de base de temps
@b{Correction de base de temps}
Les trois premiers outils soit détruisent irrémédiablement le métrage soit
parfois ne fonctionnent pas.  La correction de base de temps est la dernière
parce qu'elle est l'outil parfait de désentrelacement.  Elle laisse le métrage
intact.  Elle ne réduit pas la résolution, perceptuellement du moins.  Elle ne
provoque pas de sautes de temps.

@item
@cindex Entrelacement, images vers champs
L'effet @b{Images vers champs} convertit chacune des images en deux trames, il
doit donc être utilisé sur une timeline dont la fréquence du projet est le
double de la fréquence du média.  Il place dans la première trame une copie des
lignes paires.  Dans la seconde trame, il place une copie des trames impaires.
Lorsqu'il est lu à la vitesse normale, il donne l'illusion d'une vidéo
progressive sans aucune perte de détails.@*
L'effet peut même être inversé à l'aide de l'effet non temps réel @b{Champs
vers Trames}.  Celui-ci recombine deux trames de média dans le format entrelacé
d'origine avec une fréquence d'images réduite de moitié.@*
Soyez conscient que l'effet prend en entrée les images à la moitié de la
fréquence d'images du projet.  Les effets avant @b{images vers champs}
effectuent leur traitement à une fréquence réduite d'images.@*
Malheureusement la sortie de @b{Trames vers champs} ne peut pas être compressée
aussi efficacement que l'original par ce qu'il introduit un twitter vertical et
une fréquence d'images très élevée.@*
Le métrage entrelacé à 29,97 i/s peut être rendu semblable à du film en
appliquant @b{Trames vers champs} et en réduisant ensuite la fréquence des
images du métrage résultant de 59.94 i/s à 23.97 i/s.  Cette procédure ne
provoque pas de sautillement dans le temps et les champs impairs occasionnels
donnent l'illusion d'avoir davantage de détails qu'il y en aurait si vous ne
faisiez que la moyenne des lignes de l'original.
@end itemize

@cindex Entrelacement, HDTV exceptions
@cindex Entrelacment HDTV
@b{Exceptions HDTV}@*
La HDTV 1920x1080 est encodée d'une manière particulière.  S'il s'agit de la
diffusion d'un film HDTV original, l'effet de télécinéma inverse fonctionne
bien.  S'il s'agit d'un reformatage d'une source 720x480, vous devrez utiliser
un algorithme de base de temps et de doublage des lignes pour la désentrelacer.
@xref{1080 vers 540}.

@c cincvdoc_node_number_273
@node Faire ressembler la vidéo à un film
@section Faire ressembler la vidéo à un film
@cindex Faire ressembler la vidéo à un film
@cindex Film, aspect

La qualité de la vidéo s'améliore de jour en jour.  Depuis peu, la meilleure
chose que vous puissiez faire pour de la vidéo en provenance d'un caméscope bon
marché est de la convertir en une sortie progressive à 24 im/s.  Bien que vous
ne puissiez pas vraiment faire cela, vous pouvez vous en approcher à moindre
coût.  Souvenez-vous que cette procédure peut aussi bien dégrader une vidéo de
haute qualité qu'améliorer une vidéo de piètre qualité.  Cette méthode ne doit
être employée que sur des vidéos de basse qualité.

@enumerate 1
@item Fixez la fréquence d'images du projet à deux fois celle de la vidéo.
@item Appliquez un effet de @b{Netteté}.  Définissez la netteté à 25, sans
entrelacement, et horizontalement seulement.
@item Déposez un effet de @b{trames vers champs} sur la même piste.  Fixez les
options à @b{Effectuer la moyenne des lignes vides} et jouez la vidéo plusieurs
fois pour déterminer le champ apparaîssant en premier.  Si le mauvais champ est
affiché en premier, le déplacement est saccadé.  Par la suite, toute opération
de montage avec la fréquence d'images doublée va perturber l'ordre des champs.
On recherche encore un moyen d'avertir des changements d'ordre des champs mais
pour l'instant il vous faudra revenir à la fréquence d'image initiale pour
faire le montage ou faire des tests de relecture pour être certain que les
champs se présentent dans le bon ordre.
@item Effectuez le rendu de la vidéo dans la qualité de fichier la plus élevée
possible.
@item Importez de nouveau la vidéo avec la fréquence d'images normale.  Fixez
la fréquence d'images du projet à 24 im/s.  La nouvelle piste devrait afficher
des images ressemblant davantage à du film et plus piquées que le métrage
d'origine.
@end enumerate

Cette procédure pourrait être implémentée en entier dans un effet non
temps-réel, mais le plus gros problème avec cela est que vous voudrez la
plupart du temps conserver la sortie basée sur les champs et la fréquence de 24
im/s pour le futur.  Un effet qui n'est pas temps réel aurait besoin de faire
tout ce traitement uniquement pour la copie à 24 im/s.

@c cincvdoc_node_number_274
@node Eclaircir la brume
@section Eclaircir la brume
@cindex Eclaircir la brume
@cindex Brume, éclaircir
@cindex Effet de dégradé

Vous avez probablement photographié beaucoup de brume et n'avez sans doute
jamais vu un ciel bleu.  Même si vous pouvez vous permettre d'aller brièvement
dans un endroit où il y a du ciel bleu, les prises de vue de l'horizon
pourraient avoir davantage de profondeur.  L'effet de dégradé est fait pour ça.

Déposez l'effet de dégradé sur les pistes embrumées.  Positionnez les
paramètres comme suit :

@itemize @bullet
@item Angle : 0
@item Rayon intérieur : 0
@item Rayon extérieur : 40
@item Couleur @w{intérieure :} bleu, alpha à 100%
@item Couleur @w{extérieure :} bleu, alpha à 0%
@end itemize

Il est important de choisir la couleur bleue pour le canal alpha à 0%, même si
c'est un canal alpha à 0%.  Ce sont les paramètres généralement applicables
pour les dégradés.  L'orange ou le marron peuvent mieux convenir à certaines
scènes pour leur donner une ambiance de soirée.

@c cincvdoc_node_number_275
@node Créer une sonnerie
@section Créer une sonnerie
@cindex Sonnerie, créer une

Voici comment créer une sonnerie pour les Motorola V180 bas de gamme et qui
fonctionnera probablement avec n'importe quel téléphone.  Allez dans
@b{Fichier->Charger des fichiers...} et chargez un fichier son avec la
stratégie d'insertion @b{Remplacer le projet actuel}.  Allez dans
@b{Configuration->Format} et changez @b{Canaux} en 1 et @b{Taux
d'échantillonnage} en 16000 ou 22050.

Mettez en surbrillance la région de la timeline ou définissez les points
d'entrée et de sortie à utiliser pour la sonnerie.  Pour améliorer la qualité
du son sur le téléphone cellulaire, vous devez avoir l'amplitude maximum dans
autant de parties du son que possible.  Faites un clic droit sur la piste audio
1 et sélectionnez @b{Attacher un effet...}.  Mettez en surbrillance l'effet de
@b{Compresseur} et cliquez sur @b{Attacher} dans la fenêtre qui apparaît.

Assurez-vous que le point d'insertion ou que la région en surbrillance soit
dans la zone qui comporte l'effet de compresseur.  Faires un clic droit sur la
piste audio 2 et sélectionnez @b{Attacher l'effet..}.  Mettez en surbrillance
@w{@b{Audio 1 : Compresseur}} et cliquez @b{Attacher}.  Cliquez sur la loupe du
compresseur Audio1 @image{manual_images_intl/magnify,7mm} afin d'afficher
l'interface graphique du compresseur.

Définissez les paramètres suivants :
@itemize @bullet
@item Temps de @w{réaction :} @b{-0.1}
@item @w{Décroissance :} @b{0.1}
@item Type de @w{déclenchement :} @b{Total}
@item @w{Déclencheur :} @b{0}
@item Lisser @w{seulement :} @b{No}
@end itemize

Cliquez sur @b{Effacer} pour effacer le graphe.  Cliquez n'importe où sur la
zone de la grille et glissez le nouveau point pour une sortie à 0 et une entrée
à -50.  Le graphique devrait se présenter comme ceci.

@center @image{manual_images_fr/compress,70mm}

Aller à @b{Fichier->Rendu}.  Indiquez le mom d'un fichier mp3 vers lequel
effectuer le rendu.  Définissez le format de fichier à @b{Audio MPEG}.  Cliquez
la @image{manual_images_intl/wrench,4.33mm} clé pour l'Audio et définissez
@b{Niveau} à @b{III} et @b{Kbits par seconde} soit à @b{24} soit à @b{32}.
Cochez @b{Rendu des pistes audio} et décochez @b{Rendu des pistes video}.
Cliquez OK pour effectuer le rendu du fichier.

Le fichier @file{.mp3} résultant doit être chargé sur un serveur Web.  Ensuite,
le navigateur web du téléphone doit être utiliser pour télécharger le fichier
@file{.mp3} directement depuis l'URL@.  Il peut aussi y avoir une limite de
taille pour le fichier.

@c cincvdoc_node_number_276
@node Etirement du temps audio
@section Etirement du temps audio
@cindex Etirement du temps audio
@cindex Audio, étirement du temps

Il peut sembler que pour étirer le temps en audio, il suffise de sélectionner
une zone des pistes audio, d'activer l'enregistrement pour la piste désirée,
d'aller dans @b{Audio->Rendu d'effet}, et d'appliquer @b{Etirement du temps}.
Il y a en fait 3 effets audio pour l'étirement du @w{temps :} @b{Etirement du
temps}, @b{Rééchantillonnage}, et le @b{dialogue info de l'objet}.

L'étirement du temps applique une transformation de Fourier rapide pour essayer
de modifier la durée sans changer la hauteur, mais ceci introduit des artefacts
de "fenêtre" à l'audio.  Ce n'est utile que pour de grandes modifications du
temps car ces artefacts sont alors moins sensibles.

Pour des changements de durée moins importants, de l'ordre de 5%,
@b{Rééchantillonner} devrait être utilisé.  Il change la hauteur de l'audio
mais suffisamment peu pour que cela ne soit pas perceptible.  Le
rééchantillonnage n'introduit pas d'artefact de "fenêtre", c'est donc le plus
utile pour de faibles changements de la durée lorsque l'auditeur n'est pas
supposé savoir ce qui se passe.

Une autre manière de modifier légèrement la durée est d'aller dans la fenêtre
des @b{Ressources} et de mettre en surbrillance le dossier des @b{media}, de
faire un clic droit sur le fichier audio, de cliquer sur @b{Info}.  Ajustez le
taux d'échantillonnage dans le dialogue @b{Info} pour ajuster la durée.  Cette
méthode demande aussi de faire un clic gauche sur la limite droite des pistes
audio et de la glisser à gauche ou à droite afin qu'elle corresponde à la
modification de longueur.

@c cincvdoc_node_number_277
@node Copies d'écran vidéo
@section Copies d'écran vidéo
@cindex Copies d'écran vidéo

Nous allons expliquer ici comment enregistrer des captures d'écran et les
monter dans Cinelerra.

Vous devez d'abord enregistrer la vidéo à l'aide de xvidcap.  Vous pourrez
trouver cet utilitaire dans les dépôts de la plupart des distributions, ou le
télécharger depuis @w{là :}@*
@uref{http://xvidcap.sourceforge.net}

Faites d'abord une capture @w{d'écran :}@*
@command{xvidcap --fps 10 --cap_geometry 1280x1024+0+0 --file "file1.mpeg"
--gui no --audio no}

Ne pas oublier de modifier l'option de géométrie en fonction de la taille de
votre écran.  Ensuite, convertissez le fichier @file{file1.mpeg} obtenu en un
fichier mpeg compatible avec @w{Cinelerra :}@*
@command{ffmpeg -r 10 -i file1.mpeg -s 1280x1024 -b 3000 -aspect 1.33 -r 25
file2.mpeg}

Vous pouvez maintenant charger votre fichier dans Cinelerra.  Assurez-vous
d'avoir défini correctement le format vidéo de votre projet (dimensions,
fréquence des images, rapport d'aspect).

Lorsque vous avez terminé le montage de votre vidéo, vous devez en effectuer le
rendu.  Faites le rendu sous forme d'une séquence jpeg.  Il est recommandé
d'écrire les fichiers jpeg dans un nouveau dossier car de très nombreux
fichiers vont y être créés.

Ensuite, dans une console shell, déplacez-vous dans ce dossier et exécutez les
commandes suivantes :

@b{Première passe :}
@verbatim
mencoder "mf://*.jpg" -mf fps=25 -oac pcm -sws 2 -vf scale=\
1280:1024,hqdn3d=2:1:2 -ovc lavc -lavcopts vcodec=mpeg4:\
vbitrate=800:aspect=4/3:vpass=1 -ofps 10 -of avi -o /dev/null \
-ffourcc DIVX
@end verbatim
@b{Seconde passe :}
@verbatim
mencoder "mf://*.jpg" -mf fps=25 -oac pcm -sws 2 -vf \
scale=1280:1024,hqdn3d=2:1:2 -ovc lavc -lavcopts \
vcodec=mpeg4:vbitrate=800:aspect=4/3:vpass=2 -ofps 10 -of avi \
-o ../rendered_file.avi -ffourcc DIVX
@end verbatim

Vous pouvez aussi effectuer le rendu de la vidéo directement en mpeg4 depuis
Cinelerra si vous le désirez.

@c cincvdoc_node_number_278
@node Améliorer les performances
@section Améliorer les performances
@cindex Performances, amélioration

Pour l'instant, GNU/Linux n'est pas un excellent ordinateur de bureau.  C'est
plutôt un serveur.  La plupart de ce que vous trouverez dans les distributions
modernes de GNU/Linux sont des programmes sans charme, uniquement pour le
réseau et conçus stratégiquement pour contrer une fonctionnalité ou une autre
d'un serveur Microsoft, et ils ne se comportent pas très bien dans son
interaction avec l'utilisateur.  Il y a de nombreux paramètres que les
utilisateurs de base peuvent ajuster pour rendre son comportement plus adapté à
son utilisation comme ordinateur de bureau.

@menu
* Désactiver l'espace d'échange::
* Agrandir les tampons audio::
* Libérer davantage de mémoire partagée::
* Accélérer le disque dur::
* Désactiver les tâches planifiées::
* Réduire la sensibilité de la souris USB::
* Assortiment de réglages pour X::
* Accélérer le système de fichiers::
* Améliorer la vidéo Zoran::
@end menu

@c cincvdoc_node_number_279
@node Désactiver l'espace d'échange
@subsection Désactiver l'espace d'échange
@cindex Désactiver l'espace d'échange
@cindex Swap, désactiver

Sur les systèmes comportant beaucoup de mémoire, Cinelerra tourne parfois mieux
sans espace d'échange.  Si vous avez 4 Go de mémoire, vous aurez sans doute
intérêt à vous passez d'espace d'échange.  Si vous n'avez que 512 Mo de
mémoire, il vous faudra le conserver.  Si vous voulez faire de
l'enregistrement, vous devriez le désactiver dans tous les cas.  La raison en
est que GNU/Linux ne permet d'utiliser que la moitié de la mémoire disponible.
Après cela, il commence à chercher des pages à échanger de façon à libérer de
la mémoire pour l'utiliser comme cache pour les accès disque.  Sur un système
avec 4 Go, vous commencez à attendre l'accès à des pages présentes dans
l'espace d'échange à partir de 2 Go.

La question est alors de savoir comment faire fonctionner GNU/Linux sans espace
d'échange.  Théoriquement, la commande suivante devrait suffire@*
@command{swapoff -a}

Malheureusement, sans espace d'échange, la tâche kswapd tourne en boucle à
100%.  Pour éliminer ce problème, éditez @file{linux/mm/vmscan.c}.  Dans ce
fichier, mettez une ligne avec @command{return 0;} juste avant :
@verbatim
	/*
     	 * Kswapd main loop.
     	 */
@end verbatim

Recompilez alors le noyau.

@c cincvdoc_node_number_280
@node Agrandir les tampons audio
@subsection Agrandir les tampons audio
@cindex Tampons audio, agrandir

De façon à améliorer les performances en temps réel, les tampons réservés au
son pour tous les pilotes sonores de GNU/Linux sont limités entre 128k et 64k.
Pour enregistrer de l'audio et de la vidéo simultanément et pour la plupart des
enregistrements audio, ceci provoque des pertes de données ("dropouts").
L'application des patches du noyau @b{preempt} et @b{low-latency} permettent
d'enregistrer plus d'audio mais n'améliorent pas l'enregistrement simultanné de
vidéo et d'audio.  C'est pour cela qu'il vous faut modifier votre noyau.

Pour voir si les tampons pour l'audio sont suffisants, lancez le programme
@b{soundtest} inclus avec Cinelerra sans aucune lecture ou enregistrement
actifs.  Ceci allouera les tampons les plus gros possibles et les affichera.
Si @b{Total bytes available} est en-dessous de 131 072, vous devrez envisager
d'agrandir les tampons dans le pilote.  Comme de nombreux pilotes sont
différents, nous avons modifié au moins l'un d'entre-eux.

Ceci ne s'applique qu'à la version OSS du pilote Soundblaster Live.  Comme
chaque carte son et chaque dérivé de pilote son connaît une implémentation
différente, il vous faudra faire quelques recherches pour d'autres cartes son.
Editez @file{linux/drivers/sound/emu10k1/audio.c}

Où vous trouvez
@verbatim
if (bufsize >= 0x10000)
@end verbatim
modifiez cette ligne de façon à @w{avoir :}
@verbatim
if (bufsize > 0x40000)
@end verbatim

Où vous trouvez :
@verbatim
    for (i = 0; i < 8; i++)
        for (j = 0; j < 4; j++)
@end verbatim

modifiez cette ligne pour avoir :
@verbatim
    for (i = 0; i < 16; i++)
        for (j = 0; j < 4; j++)
@end verbatim

Dans @file{linux/drivers/sound/emu10k1/hwaccess.h}, modifiez
@verbatim
#define MAXBUFSIZE 65536
@end verbatim
en
@verbatim
#define MAXBUFSIZE 262144
@end verbatim

Enfin, dans @file{linux/drivers/sound/emu10k1/cardwi.h}, modifiez
@verbatim
#define WAVEIN_MAXBUFSIZE         65536
@end verbatim
en
@verbatim
#define WAVEIN_MAXBUFSIZE         262144
@end verbatim

Recompilez ensuite les modules du noyau.

@c cincvdoc_node_number_281
@node Libérer davantage de mémoire partagée
@subsection Libérer davantage de mémoire partagée
@cindex Libérer davantage de mémoire partagée
@cindex Mémoire partagée, libérer
@cindex Mémoire, libérer

Par défaut, le noyau de GNU/Linux n'alloue que 32 Mo de mémoire partagée.  Il
faut augmenter cette valeur pour pouvoir faire quelques chose d'utile.  Lors du lancement de
Cinelerra, il est possible que le message d'erreur suivant @w{apparaisse :}
@verbatim
The following errors occurred:
void MWindow::init_shm0: WARNING:/proc/sys/kernel/shmmax is 0x2000000, which is too low.
Before running Cinelerra do the following as root:
echo "0x7ffffff">/proc/sys/kernel/shmmax
@end verbatim

Pour un changement permanent, ajoutez au fichier @file{/etc/sysctl.conf} la
ligne @w{suivante :}

@verbatim
kernel/shmmax=0x7fffffff
@end verbatim

La première fois, pour éviter d'avoir à redémarrer votre ordinateur, lancez la
commande suivante depuis le compte @w{root :}
@verbatim
sysctl -p
@end verbatim

@c cincvdoc_node_number_282
@node Accélérer le disque dur
@subsection Accélérer le disque dur
@cindex Accélérer le disque dur
@cindex Disque dur, accélérer le
@cindex hdparm

Voici une commande très populaire chez les gourous de GNU/Linux, elle n'est pas
appliquée par défaut par toutes les distributions de GNU/Linux@*
@command{hdparm -c3 -d1 -u1 -k1 /dev/hda}

@itemize @bullet
@item @option{-c3} place le disque en mode d'entrées/sorties synchrones 32 bit.
Ceci ne fonctionne pas dans la plupart des cas en raison d'une gestion inepte
de la plupart des contrôleurs IDE par le noyau.  Si vous obtenez des lost
interrupt ou des erreurs SeekComplete, passez rapidement la commande avec
@option{-c0} à la place de @option{-c3}.
@item @option{-d1} active le DMA@.  Ceci libère partiellement le processeur
pendant les transferts de données.
@item @option{-u1} permet à plusieurs interruptions d'être prises en compte
pendant les transactions avec le disque dur.  Ceci libère encore plus de temps
processeur.
@item @option{-k1} évite à GNU/Linux de réinitialiser vos paramètres en cas de
problème.
@end itemize

@c cincvdoc_node_number_283
@node Désactiver les tâches planifiées
@subsection Désactiver les tâches planifiées
@cindex Désactiver les tâches planifiées
@cindex Cron, désactiver

GNU/Linux lance certaines opérations journalières comme la compression des
pages de manuel.  Ceci peut être acceptable en tâche de fond lorsque vous
faites des compilations ou utilisez un traitement de texte mais pas pendant que
vous jouez une vidéo.  Désactivez ces opérations en éditant
@file{/etc/rc.d/init.d/anacron}.

Mettez @command{exit} avant la première ligne qui ne commence pas par
@command{#}.

Dans @file{/etc/rc.d/init.d/crond}, mettez @command{exit} avant la première
ligne qui ne commence pas par @command{#}.  Ensuite, redémarrez le système.

Vous ne pouvez alors plus utiliser la commande @command{at}, mais qui utilise
encore cette @w{commande ?}

@c cincvdoc_node_number_284
@node Réduire la sensibilité de la souris USB
@subsection Réduire la sensibilité de la souris USB
@cindex Réduire la sensibilité de la souris USB
@cindex Souris, réduire la sensibilité
@cindex Souris USB, réduire la sensibilité

Les joueurs aiment avoir des souris de haute résolution, mais ceci peut être
pénible pour placer la souris précisément sur la timeline d'un écran vidéo.
XFree86 vous permettait de diminuer la sensibilité des souris de type PS/2 en
utilisant des commandes telles que @command{xset m 1 1} mais vous n'avez pas
cette chance si vous utilisez une souris USB ou un KVM.

Il y a une manière de réduire la sensibilité de la souris USB mais elle demande
d'éditer le code source du noyau.  Même si les souris USB sont gérées depuis
des années, le code source du noyau pour les souris USB est en perpétuelle
réécriture.  Les informations qui suivent s'appliquent pour la version
2.6.12.3.  Editez @file{/usr/src/linux/drivers/input/mousedev.c}.

Après la ligne suivante
@verbatim
struct mousedev_hw_data {
@end verbatim
mettez
@verbatim
#define DOWNSAMPLE_N 100
#define DOWNSAMPLE_D 350
int x_accum, y_accum;
@end verbatim

Ensuite, la section qui ressemble à ceci :
@verbatim
switch (code) {
    case REL_X:	mousedev->packet.dx += value; break;
    case REL_Y:	mousedev->packet.dy -= value; break;
    case REL_WHEEL:	mousedev->packet.dz -= value; break;
}
@end verbatim

doit être remplacée par :
@verbatim
switch (code) {
    case REL_X:
    mousedev->packet.x_accum += value * DOWNSAMPLE_N;
    mousedev->packet.dx += (int)mousedev->packet.x_accum
    / (int)DOWNSAMPLE_D;
    mousedev->packet.x_accum -=
    ((int)mousedev->packet.x_accum / (int)DOWNSAMPLE_D)
    * (int)DOWNSAMPLE_D;
    break;
    case REL_Y:
    mousedev->packet.y_accum += value * DOWNSAMPLE_N;
    mousedev->packet.dy -= (int)mousedev->packet.y_accum
    / (int)DOWNSAMPLE_D;
    mousedev->packet.y_accum -=
    ((int)mousedev->packet.y_accum
    / (int)DOWNSAMPLE_D) * (int)DOWNSAMPLE_D;
    break;
    case REL_WHEEL: mousedev->packet.dz -= value; break;
}
@end verbatim

Modifiez la valeur de @b{DOWNSAMPLE_N} pour changer la sensibilité de la
souris.

@c cincvdoc_node_number_285
@node Assortiment de réglages pour X
@subsection Assortiment de réglages pour X
@cindex X, assortiment de réglages pour X

Par défaut, XFree86 ne peut pas afficher très vite le rendu des pixmap avancés
de Cinelerra.  Le serveur X ne répond plus lors du dessin de la boîte de liste.
Vous pouvez corriger ceci en ajoutant une ligne à vos fichiers de configuration
XF86Config*.

Dans la zone de la @b{Section Device}, ajoutez la @w{ligne :}
@verbatim
Option "XaaNoOffscreenPixmaps"
@end verbatim
et redémarrez le serveur X.

La mise en veille inopinée de l'écran est vraiment très gênante, à moins que
vous ne soyez fabuleusement riche et que vous puissiez vous permettre de
laisser votre écran en marche 24 heures par jour sans mode d'économie
d'énergie.  Dans le fichier
@file{/etc/X11/xinit/xinitrc}, mettez
@verbatim
xset s off
xset s noblank
@end verbatim
avant la première instruction @command{if}.

Et ces touches "windows" dont aucune distribution de GNU/Linux ne veut entendre
parler.  Vous pouvez les utiliser pour fournir la fonction Alt en éditant
@file{/etc/X11/Xmodmap}.  Ajoutez-y ce qui @w{suit :}
@verbatim
keycode 115 = Hyper_L
keycode 116 = Hyper_R
add mod4 = Hyper_L
add mod5 = Hyper_R
@end verbatim

Les modifications complètes pour qu'un gestionnaire de fenêtre reconnaisse les
touches "windows" comme une touche @key{ALT} sont complexes.  Dans @b{FVWM} au
moins, vous pouvez éditer le fichier @file{/etc/X11/fvwm/system.fvwm2rc} et y
@w{mettre :}
@verbatim
Mouse 0 T A move-and-raise-or-raiselower
#Mouse 0 W M move
Mouse 0 W 4 move
Mouse 0 W 5 move
Mouse 0 F A resize-or-raiselower
Mouse 0 S A resize-or-raiselower
@end verbatim

à la place de la section par défaut pour le déplacement et le
redimensionnement.  Vous obtiendrez de meilleures performances avec FVWM@.  Les
autres gestionnaires de fenêtres semblent ralentir la vidéo avec la gestion
d'événements supplémentaires et n'autorisent pas une disposition aussi
efficace.

@c cincvdoc_node_number_286
@node Accélérer le système de fichiers
@subsection Accélérer le système de fichiers
@cindex Accélérer le système de fichiers
@cindex Système de fichiers, accélérer le

Vous enregistrerez souvent de la vidéo sur une matrice de disque disque
coûteuse, énorme et indépendante de votre disque d'amorçage.  Il vous faudra
donc installer vous-même un système de fichiers EXT sur cette matrice de
disques en utilisant la commande @command{mke2fs}.  Le système de fichiers le
plus rapide, et de loin, est obtenu de la manière suivante@*
@cindex mke2fs
@cindex tune2fs
@command{mke2fs -i 65536 -b 4096 my_device}@*
@command{tune2fs -r0 -c10000 my_device}

Il ne comporte pas de journalisation, réserve aussi peu de blocs que possible
pour les noms de fichiers et permet l'accès à la taille de données par bloc la
plus grande possible.  Un autre système de fichiers légèrement plus lent, mais
qui est plus facile à récupérer après une coupure d'alimentation électrique est
constitué de la manière suivante@*
@command{mke2fs -j -i 65536 -b 4096 my_device}@*
@command{tune2fs -r0 -c10000 my_device}

Ceci ajoute un journal qui ralentit les écritures mais qui permet de raccourcir
notablement le temps que met fsck à remettre en état une partition lorsqu'elle
n'a pas été correctement démontée.

@c cincvdoc_node_number_287
@node Améliorer la vidéo Zoran
@subsection Améliorer la vidéo Zoran
@cindex Vidéo Zoran, améliorer la

La vidéo enregistrée à partie des entrées ZORAN est normalement non alignée, ou
pas complètement encodée sur la droite.  Ceci peut être légèrement amélioré en
ajustant des paramètres dans le code source du pilote.

Dans @file{/usr/src/linux/drivers/media/video/zr36067.c}, la structure définie
près de la ligne 623 affecte l'alignement.  Au moins en NTSC, la version 2.4.20
du pilote peut être améliorée en modifiant
@verbatim
    static struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 16 };
en
    static struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 17 };
@end verbatim

Dans @file{/usr/src/linux/drivers/media/video/bt819.c} d'autres structures près
de la ligne 76 affectent l'alignement et l'encodage.@*

En NTSC
@verbatim
    {858 - 24, 2, 523, 1, 0x00f8, 0x0000},
pourrait être changé en
    {868 - 24, 2, 523, 1, 0x00f8, 0x0000},
@end verbatim

En ajustant ces paramètres, vous pouvez ou pas, déplacer votre image plus près
du centre.  La plupart du temps, ils planteront le pilote juste avant la
capture de la première image.

@b{Nouveau en 2.6.5 :}@*
Avec les noyaux 2.6, le sous-système vidéo a été de nouveau réécrit
complètement	.  Pour ajuster les paramètres Zoran, allez dans le fichier
@file{drivers/media/video/zoran_card.c} et recherchez un groupe de lignes
ressemblant à
@verbatim
    static struct tvnorm f50sqpixel = { 944, 768, 83, 880, 625, 576, 16 };
    static struct tvnorm f60sqpixel = { 780, 640, 51, 716, 525, 480, 12 };
    static struct tvnorm f50ccir601 = { 864, 720, 75, 804, 625, 576, 18 };
    static struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 16 };

    static struct tvnorm f50ccir601_lml33 = { 864, 720, 75+34, 804, 625, 576, 18 };
    static struct tvnorm f60ccir601_lml33 = { 858, 720, 57+34, 788, 525, 480, 16 };

    /* The DC10 (57/16/50) uses VActive as HSync, so HStart must be 0 */
    static struct tvnorm f50sqpixel_dc10 = { 944, 768, 0, 880, 625, 576, 0 };
    static struct tvnorm f60sqpixel_dc10 = { 780, 640, 0, 716, 525, 480, 12 };

    /* FIXME: I cannot swap U and V in saa7114, so i do one
     * pixel left shift in zoran (75 -> 74)
     * (Maxim Yevtyushkin <max@@linuxmedialabs.com>) */
    static struct tvnorm f50ccir601_lm33r10 = { 864, 720, 74+54, 804, 625, 576, 18 };
    static struct tvnorm f60ccir601_lm33r10 = { 858, 720, 56+54, 788, 525, 480, 16 };
@end verbatim

Elles semblent contrôler la position de l'image.  Au moins pour le LML33, la
définition suivante pour @b{f60ccir601_lml33} le fait.
@verbatim
static struct tvnorm f60ccir601_lml33 = { 858, 720, 67+34, 788, 525, 480, 13 };
@end verbatim

@c cincvdoc_node_number_288
@node Traduire Cinelerra
@section Traduire Cinelerra
@cindex Traduire Cinelerra

@menu
* Traductions disponibles::
* Mettre à jour une traduction existante::
* Créer une nouvelle traduction::
@end menu

Les informations suivantes sont nécessaires si vous désirez participer à la
traduction de Cinelerra.  @xref{Variables d'environnement}, pour faire lancer
Cinelerra dans votre langue.

@c cincvdoc_node_number_289
@node Traductions disponibles
@subsection Traductions disponibles
@cindex Traductions disponibles

Il existe un certain nombre de traductions disponibles pour @w{Cinelerra :}
@itemize @bullet
@item @b{DE} - allemand
@item @b{ES} - espagnol
@item @b{EU} - basque
@item @b{FR} - français
@item @b{IT} - italien
@item @b{PT_BR} - portugais (Brésil)
@item @b{SL} - slovène
@end itemize

@c cincvdoc_node_number_290
@node Mettre à jour une traduction existante
@subsection Mettre à jour une traduction existante
@cindex Mettre à jour une traduction existante

Pour créer un fichier @file{*.po} à jour avec les nouvelles chaînes du code
source de Cinelerra qui ne se trouvent pas encore dans le fichier @file{.po}
lancez après @command{./configure} :@*
@command{cd po && make}

Editez ensuite le fichier @file{.po} qui se trouve dans le répertoire
@file{po/} de la langue qui vous intéresse et envoyez le fichier diff à
l'équipe de Cinelerra-CV.

@c cincvdoc_node_number_291
@node Créer une nouvelle traduction
@subsection Créer une nouvelle traduction
@cindex Créer une nouvelle traduction

Pour créer une nouvelle traduction, lancez après la commande
@w{@command{./configure} :}@*
@command{cd po && make}

Ensuite, éditez le fichier @file{cinelerra.pot} qui se trouve dans @file{po/}
et ajoutez les chaînes traduites.  Renommez le fichier en
@file{(prefixe_de_langue).po} et ajoutez le prefixe de la langue dans le
fichier @file{po/LINGUAS}.  Enfin, soumettez le diff à l'équipe de
Cinelerra-CV.

NDT : la commande @command{intltool-update fr} lancée depuis le répertoire
@file{po/} permet de mettre à jour le fichier @file{fr.po} existant.  Il suffit
alors de l'éditer pour mettre à jour la traduction.

@c cincvdoc_node_number_292
@node Effectuer des panoramiques et des zooms dans les images fixes
@section Effectuer des panoramiques et des zooms dans les images fixes::
@cindex Panoramiques et zooms des images fixes
@cindex Images fixes, panoramiques et zooms

La puissance des fonctionnalités des images-clés de Cinelerra vous permet des
effets élaborés de panoramique et de zoom dans une image fixe.
@enumerate 1
@item Chargez et créez un clip depuis une image fixe tel que décrit ci-dessus.
Configurez le clip pour une durée de 10 secondes.
@item Activez la @b{création automatique des images-clés}
@item A l'aide des @b{commandes de transport} déplacez-vous au début du clip
@item A l'aide de la @b{commande de composition de la caméra} définissez la
position initiale de votre clip
@item A l'aide des @b{commandes de transport} déplacez-vous sur le clip de
quelques secondes vers l'avant
@item Par un glisser dans la @b{caméra de composition} déplacez le centre de la
caméra vers une autre position
@item Maintenant, revenez en début du clip et jouez-le.
@end enumerate
Vous pouvez voir que la caméra se déplace de manière fluide d'image-clé en
image-clé, Cinelerra ajuste automatiquement le mouvement de caméra selon des
lignes droites d'un point à un autre.

@c cincvdoc_node_number_342
@node Edition HDV 1080i avec des fichiers proxy
@section Edition HDV 1080i avec des fichiers proxy
@cindex Edition HDV 1080i avec des fichiers proxy

Travailler avec des fichiers haute définition, qui proviennent de camescopes
HDV, nécessite beaucoup de puissance de calcul.  Même si un système est en
mesure de jouer une seule piste en temps-réel, il n'est pas forcément capable
de jouer plusieurs pistes simultannément.  Ainsi, un simple effet de fondu
enchaîné s'en trouve si ralentie que cela devient innacceptable.  De plus, le
HDV est un format reposant sur les GOP, et donc une simple coupure à un endroit
nécessite le décodage du GOP entier en moins d'1/25ième de seconde.  Une
solution consiste à réaliser l'édition sur des fichiers en basse résolution, et
d'utiliser la vidéo HDV seulement pour le calcul final.  La méthode expliquée
çi-dessous a été initialement proposée par Hermann @sc{Voßeler}.

@menu
* Vue d'ensemble::
* Récupérer la vidéo HDV depuis le camescope::
* Utilisation de fichiers TOC et WAV::
* Générer les fichiers proxy::
* Convertir l'HDV et les fichiers proxy::
* Réaliser le calcul d'un projet HDV::
* Autres problèmes::
@end menu

@c cincvdoc_node_number_343
@node Vue d'ensemble
@subsection Vue d'ensemble
@cindex Edition HDV 1080i, vue d'ensemble

@itemize @bullet
@item Pour chaque fichier HDV est créé un fichier proxy à l'échelle 0.5.
@item Le projet est créé avec une résolution HDV, par exemple 1440×1080 en
16/9.
@item Les nouvelles ressources sont créées à la fois avec les fichiers HDV et
les fichiers proxy.
@item Chaque piste vidéo doit avoir un paramètre de zoom de caméra défini à
2.0.
@item L'édition est réalisée avec les fichiers proxy.
@item Pour le rendu en HDV, sortir de Cinelerra et convertir le fichier du
projet en utilisant le script proxychange.py, puis réouvrir le projet.
@item Après le rendu, si une nouvelle édition est nécessaire, le projet peut
être reconverti dans sa version proxy.
@end itemize

@c cincvdoc_node_number_344
@node Récupérer la vidéo HDV depuis le camescope
@subsection Récupérer la vidéo HDV depuis le camescope
@cindex Edition HDV 1080i, récupérer la vidéo HDV depuis le camescope

Il n'existe actuellement pas de version parfaite.  Une possibilité est
d'exécuter la commande @command{test-mpeg2} qui est disponible avec les sources
de  @b{libiec61883}.
Utiliser cette @w{syntaxe :}@*
@command{test-mpeg2 > hdv_tape.mpeg}@*
et pressez @b{Play} sur le camescope.  Vous ne devriez pas exécuter de tâche
fortement consommatrice de ressources sur l'ordinateur pendant la récupération
de la vidéo, puisque l'absence d'utilisation de cache par test-mpeg2 peut
causer des sauts d'images.

@c cincvdoc_node_number_345
@node Utilisation de fichiers TOC et WAV
@subsection Utilisation de fichiers TOC et WAV
@cindex Edition HDV 1080i, utilisation de fichiers TOC et WAV

Utilisez des fichiers WAV pour le son, et chargez les fichiers HDV MPEG-2 via
leur fichier toc généré.  Pour générer les fichiers toc, utilisez cette
@w{commande :}@*
@command{for i in *.mpeg; do mpeg3toc $i `basename $i mpeg`toc; done}

@c cincvdoc_node_number_346
@node Générer les fichiers proxy
@subsection Générer les fichiers proxy
@cindex Edition HDV 1080i, générer les fichiers proxy

Les fichiers proxy peuvent être convertis en utilisant plusieurs méthodes.
Cependant, Cinelerra fonctionne mieux lors de l'édition de fichiers n'utilisant
pas de GOP.  Pour convertir vos fichiers HDV en fichiers à l'échelle 0.5, au
format MJPEG avec des I-frames, utilisez la commande @w{suivante :}@*
@command{for i in *.mpeg;do mencoder -mc 0 -noskip $i -ovc lavc -lavcopts
vcodec=mjpeg -vf scale=720:540 -oac pcm -o `basename $i mpeg`avi; done}

@c cincvdoc_node_number_347
@node Convertir l'HDV et les fichiers proxy
@subsection Convertir l'HDV et les fichiers proxy
@cindex Edition HDV 1080i, convertir l'HDV et les fichiers proxy

Le script python @b{proxychange.py} réalise la conversion entre les projets HDV
et proxy.  Vous pouvez télécharger ce script @w{ici :}@*
@uref{http://cvs.cinelerra.org/docs/proxychange.py}

Ce script écrase les projets existants, et copie le fichier original dans
@file{projectfile.xml.bak}.

@itemize @bullet
@item Proxy -> HDV (pour le rendu):@*
@command{./proxychange.py projectfile.xml -from `proxyfiles/(\w+)\.avi` -to
`hdv/\1.toc` -scale 0.5}
@item HDV -> Proxy (après avoir réalisé le rendu, si vous voulez de nouveau
éditer votre vidéo):@*
@command{./proxychange.py projectfile.xml -from `hdv/(\w+)\.toc` -to
`proxyfiles/\1.avi` -scale 2.0}
@end itemize

Le fichier XML du projet n'est pas un fichier XML parfaitement valide.  En
conséquence de quoi, après chaque opération de sauvegarde sous Cinelerra,
quelques problèmes peuvent apparaître.  Parfois les balises ne sont pas
fermées, <TAG> n'est pas suivi de </TAG>.  Ceci peut être corrigé manuellement.

ACODEC contient quelques caractères \001.  Editez le fichier manuellement ou
utilisez la commande @w{suivante :}@*
@command{cat temp001.xml| tr -d `\001` > /tmp/1 ; mv /tmp/1 temp001.xml}

@c cincvdoc_node_number_348
@node Réaliser le calcul d'un projet HDV
@subsection Réaliser le calcul d'un projet HDV
@cindex Edition HDV 1080i, réaliser le calcul d'un projet HDV

Les fichiers HDV peuvent être calculés et rendus dans un flux YUV4MPEG et alors
encodées en MPEG2 en utilisant une version modifiée du binaire de Mjpegtools.
@command{mpeg2enc -verbose 0 -aspect 3 -format 3 -frame-rate 3 -video-bitrate
25000 -nonvideo-bitrate 384 -force-b-b-p -video-buffer 448 -video-norm n
-keep-hf -no-constraints -sequence-header-every-gop -min-gop-size 6
-max-gop-size 6 -o %}

Réalisez le rendu du son dans un fichier AC3, et multiplexez le tout avec
mplex.

@c cincvdoc_node_number_349
@node Autres problèmes
@subsection Autres problèmes
@cindex Edition HDV 1080i, autres problèmes

Lors de la lecture de fichiers MJPEG, l'effet de fondu enchaîné peut ne pas
fonctionner correctement dans les modes RGBA ou YUVA, mais fonctionne bien dans
les modes RGB ou YUV.

@c cincvdoc_node_number_350
@node Ajouter des sous-titres
@section Ajouter des sous-titres
@cindex Sous-titres, ajouter des

Il existe deux méthodes pour ajouter des sous-titres dans une @w{vidéo :}
@itemize @bullet
@item Utiliser le titreur de Cinelerra.  Cette tâche est longue et fastidieuse.
De plus, les sous-titres sont incrustés dans l'image,  Il est impossible
d'afficher par la suite la vidéo sans sous-titres.  Si vous voulez que votre
vidéo soit disponible avec plusieurs sous-titres, il vous faudra réaliser son
rendu plusieurs fois.  @xref{Titreur}, pour plus d'information sur le titreur
de Cinelerra.
@item Ajouter les sous-titres avec un éditeur de sous-titres, après avoir rendu
la vidéo avec Cinelerra.
@end itemize

La seconde méthode est celle à utiliser si vous voulez que votre vidéo soit
disponible avec des sous-titres en différentes langues.  Si vous voulez
réaliser un DVD, cette méthode est la seule qui est compatible avec les
fonctions de sous-titres de dvdauthor.  Si vous prévoyiez de distribuer votre
vidéo sur internet, un seul fichier vidéo et plusieurs fichiers de sous-titres
prend moins de place que plusieurs vidéos, à raison d'une pour chaque langue.

Les fichiers de sous-titres peuvent être affichés avec n'importe quel lecteur
vidéo digne de ce nom.  Avec mplayer, vous pouvez utiliser la syntaxe
@w{suivante :}
@command{mplayer -sub <fichier_de_sous_titres> <fichier_video>}

Un fichier de sous-titres est un simple fichier texte, qui contient le texte et
l'indication de temps ou bien le numéro d'image où chaque sous-titre doit être
affiché à l'écran.

Il y a plusieurs éditeurs de sous-titres disponibles sous LInux.  Cependant, la
majorité conviennent à la traduction de sous-titres, et ne sont pas appropriés
pour vraiment @b{créer} et @b{synchroniser} de nouveaux sous-titres sur une
vidéo.  Puisque la création de vidéos est ce qui nous intéresse, la tâche qui
retient le plus notre attention est celle de l'ajout de sous-titres sur une
vidéo.

Nous vous recommandons vivement @b{Subtitleeditor}, qui est disponible @w{ici
:}@*
@uref{http://kitone.free.fr/subtitleeditor}

@center @image{manual_images_fr/subtitleeditor,100mm}
@center @b{Subtitleeditor}

Subtitleeditor a l'immense avantage d'afficher l'audio sous forme d'ondes
sonores.  Cette fonctionnalité est vraiment importante pour synchroniser
précisément les sous-titres et les paroles.  Gardez à l'esprit que la
synchronisation sera perdue si vous éditez votre vidéo après avoir ajouté les
sous-titres.  L'ajout des sous-titres doit s'effectuer après l'édition de la
vidéo.@*

Une fois que le fichier de sous-titres a été créé, vous @w{pouvez :}
@itemize @bullet
@item Le distribuer avec votre vidéo.  Les personnes qui la regarderont devront
charger le fichier de sous-titres approprié avec leur lecteur de vidéo pour
voir les sous-titres.
@item L'utiliser avec dvdauthor, pour ajouter des sous-titres dans un DVD.
Lisez la documentation de dvdauthor pour plus d'information.
@item Incruster les sous-titres dans la vidéo en utilisant mencoder.  Cette
ligne de commande est un exemple.  Adaptez-la à vos @w{besoins :}@*
@command{mencoder -sub <your_subtitle_file> <video_file_without_subtitles> -ovc lavc
-lavcopts vcodec=mpeg4:vhq:vbitrate=1000 -oac mp3lame -lameopts br=256:vol=1
-ffourcc DIVX -o <converted_video.avi>}
@end itemize

@c cincvdoc_node_number_293
@node Résolution de problèmes
@chapter Résolution de problèmes
@cindex Résolution de problèmes

@menu
* Signaler des bogues::
* La lecture ne s'arrête pas::
* Plantages du pilote Buz::
* Le glisser des points d'entrée et de sortie ne fonctionne pas::
* Blocage lors du chargement de fichiers::
* Perte de synchronisation lors de l'enregistrement::
* L'application de gamma suivie de flou de fonctionne pas::
* Copier-coller de sélections de piste ne fonctionne pas sur la timeline::
* Cinelerra se plante souvent::
* Erreur "Thème Blond introuvable"::
@end menu

@c cincvdoc_node_number_294
@node Signaler des bogues
@section Signaler des bogues
@cindex Signaler des bogues
@cindex Bogues, signaler

Si vous remarquez un bogue, la première chose à faire est d'aller sur
@uref{http://bugs.cinelerra.org} pour vérifier s'il n'a pas déjà été signalé.
S'il n'existe pas de signalement de bogue correspondant, vous pouvez renseigner
un signalement de bogue.  Créez un compte sur @uref{http://bugs.cinelerra.org}
si vous n'en avez pas déjà un.  Ensuite, remplissez le rapport de bogue, en y
incluant les informations suivantes :

@itemize @bullet
@item Numéro de version de Cinelerra CV@.  @w{Exemple :} r959

@item Nom et version de la distribution.  @w{Exemple :} Debian SID

@item Etapes permettant de reproduire le bogue.  C'est très important car cela
aide énormément les personnes qui essaient de corriger les bogues.  Exemple :
@enumerate 1
@item lancer Cinelerra
@item ouvrir la fenêtre d'enregistrement
@item cliquer OK
@item plantage de Cinelerra
@end enumerate

@item Lors d'un plantage de Cinelerra CV, une sortie de débogueur est utile.
@w{Lancez :}@*
@command{gdb cinelerra}@*
@command{run}@*
(Vous déclenchez le bogue et Cinelerra CV se plante)@*
@command{thread apply all bt}@*
Copiez alors tous les informations affichées dans votre signalement de bogue.
@end itemize

Ne pas hésiter à joindre tous les fichiers que vous jugerez utiles, tels que
des captures d'écran par exemple.  La sortie de gdb est plus utile lorsque
Cinelerra est compilé avec les symboles de débogage.  @xref{Compiler avec les
symboles de débogage}, pour les instructions de compilation correspondantes.

De plus, si le bogue que vous avez trouvé concerne un problème de chargement
d'un fichier particulier dans Cinelerra-CV, mettre à disposition un petit
exemple d'un tel fichier sur internet sera apprécié.  Ceci permettra aux
personnes qui corrigent les bogues de charger elles-mêmes ce fichier dans
Cinelerra pour voir ce qui se produit.

@c cincvdoc_node_number_351
@node La lecture ne s'arrête pas
@section La lecture ne s'arrête pas
@cindex Lecture ne s'arrête pas

Si la lecture des pistes audio ne s'arrête pas sur la timeline et continue
après la fin de la vidéo, allez dans @b{Préférences->Lecture} et cliquez sur
@b{Stop playback locks up}.  Ce bouton ne sera affiché que si vous avez défini
ALSA en tant que pilote audio.

@c cincvdoc_node_number_295
@node Plantages du pilote Buz
@section Plantages du pilote Buz
@cindex Buz, plantages du pilote

Tout d'abord, on accède aux cartes d'acquisition Zoran en utilisant le pilote
vidéo @b{Buz} depuis @b{Préférences->Enregistrement} et
@b{Préférences->Lecture}.  Quelques réglages de configuration sont disponibles
dans une autre section, @xref{Améliorer les performances}..

Une fois réglé, le pilote Buz semble planter si le nombre de tampons
d'enregistrement est trop important.  Assurez-vous que la valeur dans
@b{Préférence->Enregistrement->Images à mettre en tampon sur le périphérique}
est inférieure à 10.

@c cincvdoc_node_number_296
@node Le glisser des points d'entrée et de sortie ne fonctionne pas
@section Le glisser des points d'entrée et de sortie ne fonctionne pas
@cindex Glisser les points d'entrée et de sortie ne fonctionne pas
@cindex Points d'entrée/sortie, le glisser ne fonctionne pas

Parfois il y a deux plans trop proches l'un de l'autre.  Le plan sélectionné
pour le glisser peut se trouver sur un plan trop proche d'un plan qui se trouve
invisible dans le facteur de zoom actuel.  Effectuez un zoom horizontal.

Si vous pensez que vous ne pouvez pas déplacer toutes les éditions débutant au
même endroit sur des pistes armées, zoomez horizontalement pour vérifier
qu'elles commencent effectivement bien au même endroit.  Parfois la
synchronisation verticale des éditions peut être perdue car vous n'avez pas
correctement défini les attributs du projet (PAL/NTSC).  Vérifiez cela dans
@b{Configuration->Format...}

@c cincvdoc_node_number_297
@node Blocage lors du chargement de fichiers
@section Blocage lors du chargement de fichiers
@cindex Blocage lors du chargement de fichiers
@cindex Fichier, blocage lors du chargement

Souvent, lorsqu'un blocage se produit lors du chargement d'un fichier, cela est
dû au fait que le codec de ce fichier n'est pas supporté.  Une autre raison
possible est que Cinelerra est en train de construire les vignettes des images
pour la fenêtre des ressources.  Il lui faut en effet décompresser un grand
nombre d'images pour constituer ces vignettes.  Aller à
@b{Configuration->Préférences->Interface} et désactivez @b{Utiliser les
vignettes dans la fenêtre des ressources} afin de sauter cette étape de
traitement, si cela pose problème.

@c cincvdoc_node_number_298
@node Perte de synchronisation lors de l'enregistrement
@section Perte de synchronisation lors de l'enregistrement
@cindex Perte de synchronisation lors de l'enregistrement
@cindex Enregistrement, synchronisation

Si la fréquence des images de l'enregistrement est bien plus faible que la
fréquence des images de la source, au cours du temps, la vidéo va s'accumuler
dans les tampons d'enregistrement et l'audio et la vidéo ne seront plus
synchronisées.  Diminuez le @b{nombre d'images à mettre en tampon dans le
périphérique} depuis @b{Préférence->Acquisition} pour que les images en excès
soient sautées plutôt que mises en tampon.

@c cincvdoc_node_number_299
@node L'application de gamma suivie de flou de fonctionne pas
@section L'application de gamma suivie de flou de fonctionne pas

L'effet gamma utilise la fonction @b{pow} alors que l'effet de flou utilise un
certain nombre de fonctions @b{exp} de la bibliothèque mathématique.  Pour
certaines raisons, l'utilisation de la fonction pow casse le fonctionnement
ultérieur des fonctions exp de la bibliothèque mathématique.  Vous devrez
appliquer le gamma après le flou pour qu'il puisse fonctionner.

@c cincvdoc_node_number_300
@node Copier-coller de sélections de piste ne fonctionne pas sur la timeline
@section Copier-coller de sélections de piste ne fonctionne pas sur la timeline
@cindex Copier-coller de sélections de piste ne fonctionne pas sur la timeline

Si vous utilisez l'application KDE Klipper, il vous faut soit la désactiver,
soit faire un clic dans l'icône de sa barre de tâches, sélectionner
@b{Configurer Klipper} et vous assurer que @b{Eviter que le presse-papier ne
soit vide} n'est pas sélectionné.

@c cincvdoc_node_number_301
@node Cinelerra se plante souvent
@section Cinelerra se plante souvent
@cindex Plantages

Effectuez une installation propre.  Assurez-vous de ne pas avoir de
bibliothèque provenant d'une installation antérieure.  Supprimez aussi votre
répertoire @file{$HOME/.bcast/}.@*
@command{rm -f /usr/local/lib/libguicast*}@*
@command{rm -f /usr/lib/libguicast*}@*
@command{rm -f /usr/local/lib/libquicktimehv*}@*
@command{rm -f /usr/lib/libquicktimehv*}@*
@command{rm -f /usr/local/lib/libmpeg3hv*}@*
@command{rm -f /usr/lib/libmpeg3hv*}

@c cincvdoc_node_number_302
@node Erreur "Thème Blond introuvable"
@section Erreur "Thème Blond introuvable"
@cindex Theme Blond, introuvable

Si le message suivant est @w{affiché :} @command{Aborted, MWindow::init_theme:
Theme Blond not found}, alors :
@itemize @bullet
@item Vous devriez avoir le fichier @file{defaulttheme.*} dans
@file{/usr/lib/cinelerra} ou dans @file{/usr/local/lib/cinelerra}.  Si ce n'est
pas le cas, il vous faut de nouveau installer les greffons.
@item Essayez de supprimer le répertoire @file{$HOME/.bcast/}
@item Regardez dans le fichier @file{$HOME/.bcast/Cinelerra_rc} et recherchez
THEME, ce devrait être => THEME Blond
@end itemize

@c cincvdoc_node_number_303
@node Création de greffons
@chapter Création de greffons
@cindex Création de greffons
@cindex Greffons, création

L'API de création des greffons de Cinelerra date de 1997, avant que LADSPA et
avant que VST ne deviennent populaires.  Il est resté identique à ce qu'il
était en 1997, avec des modifications mineures pour manipuler les images-clés
et les informations reçues en retour de l'interface graphique.
Malheureusement, l'interface graphique ne contient pas de niveau d'abstraction
accessible au programmeur.  Ceci permet au programmeur d'utiliser la boîte à
outils ("toolkit") qu'il désire et permet davantage de flexibilité en
apparence mais demande plus d'efforts.

Il y a différents types de greffons, chacun comporte une procédure
d'implémentation commune avec des modifications spécifiques à son type
particulier.  La manière la plus simple pour implémenter un greffon est de
prendre le plus simple de son groupe et d'en renommer les symboles.

@menu
* Introduction à la méthode PULL:: le paradigme actuel de l'écriture des greffons.
* Fonctions communes aux greffons:: ce que tous les effets doivent faire.
* Greffons en temps réel:: ce que doivent faire les effets en temps réel.
* Greffons qui ne sont pas en temps réel:: ce que doivent faire les effets rendus.
* Greffons audio:: ce que doivent faire les effets audio.
* Greffons vidéo:: ce que doivent faire les effets vidéo.
* Greffons de transitions:: ce que les transitions doivent faire.
* Greffons dont l'interfaces utilisateur se met à jour lors de la lecture:: comment utiliser les données en
  cours de lecture pour dessiner une interface graphique utilisateur.
* Utiliser OpenGL:: comment utiliser le matériel pour accélérer les opérations.
* Requêtes des greffons:: comment les greffons obtiennent des informations concernant les
  informations devant être traitées.
@end menu

@c cincvdoc_node_number_304
@node Introduction à la méthode PULL
@section Introduction à la méthode PULL
@cindex Pull, méthode, introduction à

La manière la plus simple de concevoir des greffons est la méthode "pousser"
("push").  La méthode "pousser" est intuitive.  Une source pousse des données
dans le greffon, le greffon effectue des opérations mathématiques sur ces
données et le greffon les pousse vers leur destination.  Pendant 6 ans, ceci a
été la manière dont les greffons étaient gérés de manière interne, mais cela ne
permettait pas de réduire le débit des données en temps réel.  Bien que les
greffons continuent à être écrits comme s'ils poussaient les données, ce n'est
plus de cette manière que le traitement interne est fait dorénavant.

La dernière évolution dans la conception des greffons de Cinelerra est la
méthode "tirer" ("pull").  Le pipeline de rendu commence par la fin, et les
dernières étapes dans le pipeline de rendu demandent des informations aux
étapes qui les précèdent.  Lorsque le pipeline demande ensuite des données à
une chaîne de greffons, chaque greffon va demander des données au greffon qui
le précède.

C'est moins intuitif mais plus puissant que la méthode "pousser".  Les greffons
en temps réel écrits pour utiliser la méthode "tirer" peuvent non seulement
modifier le débit auquel les données sont présentées à la visionneuse mais
aussi le sens de la lecture.  La méthode "tirer" permet aux greffons de prendre
les données à un débit supérieur à celui auquel ils les envoient.

Pour tirer toute la puissance de l'indépendance du débit, il est nécessaire,
dans la méthode "tirer", que le greffon connaisse davantage de choses
concernant les données que ce qui est nécessaire avec la méthode "pousser".
Les greffons doivent connaître le débit du projet et à quel débit se fait leur
demande de sortie.  Ces deux débits de données doivent être interchangés pour
permettre la configuration correcte d'un greffon.

Les images-clés d'un greffon sont enregistrées relativement à la fréquence
d'images du projet.  Les requêtes de position actuelle de la lecture sont
relatives à la fréquence des images du projet.  Il est inutile que le greffon
demande des données à deux fois la fréquence d'images du projet car les
images-clés ne correspondront pas aux bonnes positions des données.  Deux
classes de données ont été créées pour répondre à ce problème.

Les conversions de débit sont faites en termes de @b{débit de projet} et de
@b{débit demandé}.  Le débit du projet est identique pour tous les greffons.
Il est déterminé dans la fenêtre @b{Configuration->Format...}.  Le débit
demandé est déterminé par le greffon situé plus bas dans le flux qui demande
des données au greffon en cours.  Il est arbitraire.  Vous trouverez plus loin
une explication exacte sur la manière d'utiliser ces débits.

@c cincvdoc_node_number_305
@node Fonctions communes aux greffons
@section Fonctions communes aux greffons
@cindex Greffons, fonctions communes

Tous les greffons héritent d'un dérivé de PluginClient.  Ce dérivé de
PluginClient implémente la plupart des méthodes requises dans PluginClient,
mais les utilisateurs doivent quand même définir des méthodes pour
PluginClient.  les méthodes les plus couramment utilisées sont prédéfinies sous
forme de macros pour simplifier la saisie tout en conservant le maximum de
flexibilité.

Les fichiers qu'ils incluent dépendent du type de greffon.  Les greffons audio
incluent @file{pluginaclient.h} et les greffons vidéo incluent
@file{pluginvclient.h}.  Ils héritent respectivement de @b{PluginAClient} et de
@b{PluginVClient}.

Cinelerra crée au moins deux instances de tous les greffons lorsqu'ils sont
utilisés dans un film.  Une instance est réservée à l'interface utilisateur
graphique.  L'autre instance est réservée au traitement du signal.  L'entrée
utilisateur, à travers une séquence compliquée, est propagée depuis l'instance
de l'interface graphique à l'instance de traitement du signal.  Si le
traitement du signal a besoin de modifier l'interface graphique, il propage les
données en retour vers l'instance de l'interface.  Il y a des fonctions
utilitaires pour effectuer tout ça.

Les greffons définissent au moins trois objets :

@itemize @bullet
@item @b{Objet traitement}@*
Il contient des pointeurs vers tous les autres objets et exécute le traitement
du signal.  Cet objet comporte un certain nombre de requêtes pour s'identifier
lui-même et c'est l'objet qu'il faut enregistrer pour enregistrer le greffon.
@item @b{Objet interface utilisateur}@*
Il est défini selon ce que désire le programmeur.  Il peut soit utiliser la
boîte à outils de Cinelerra, soit une autre boîte à outils ("toolkit").  Il
affiche les données sur l'écran et récupère les paramètres en provenance de
l'utilisateur.@*
Lorsqu'il utilise la boîte à outils de Cinelerra, le seul objet de l'interface
utilisateur dont le programmeur doit se soucier est la fenêtre.  La fenêtre
comporte des pointeurs vers un certain nombre d'éléments graphiques
("widgets"), quelques méthodes d'initialisation et un pointeur arrière vers
l'objet de traitement du greffon.  Cette documentation traite de l'utilisation
de la boîte à outils de Cinelerra.@*
Selon la boîte à outils utilisée pour l'interface utilisateur, un processus
("thread") peut être créé pour faire tourner l'interface utilisateur de manière
complètement asynchrone.  La synchronisation de l'interface utilisateur avec
les modifications de configuration du greffon est l'un des aspects les plus
compliqués du greffon, le processus et l'objet de l'interface utilisateur sont
largement gérés par des macros si vous utilisez la boîte à outils de Cinelerra.
@item @b{Objet de configuration}@*
Il enregistre les paramètres de l'utilisateur et a toujours besoin de fonctions
d'interpolation, de copie et de comparaison.  Les macros pour le greffon client
appellent automatiquement des méthodes pour interpoler les images-clés.
@end itemize

@menu
* L'objet de traitement::
* L'objet de configuration::
* L'objet d'interface utilisateur::
@end menu

@c cincvdoc_node_number_306
@node L'objet de traitement
@subsection L'objet de traitement
@cindex Objet de traitement

Chargez un greffon simple tel que le gain pour voir à quoi ressemble cet objet.
L'objet de traitement doit hériter du dérivé prévu de PluginClient.  Son
constructeur doit avoir un paramètre PluginServer.
@verbatim
MyPlugin(PluginServer *server);
@end verbatim

Dans l'implémentation, le greffon doit comporter une ligne d'enregistrement
avec le nom de l'objet traitement telle que
@verbatim
REGISTER_PLUGIN(MyPlugin)
@end verbatim

Le constructeur doit contenir
@verbatim
PLUGIN_CONSTRUCTOR_MACRO
@end verbatim
pour initialiser les variables les plus courantes.

L'objet traitement doit avoir un destructeur comportant
@verbatim
PLUGIN_DESTRUCTOR_MACRO
@end verbatim
pour supprimer les variables les plus courantes.

Une autre fonction utile mais non nécessaire est
@verbatim
int is_multichannel();
@end verbatim
Elle doit retourner 1 si une instance du greffon gère simultanément plusieurs
pistes et 0 si une instance du greffon ne gère qu'une piste.  Si cette valeur
est omise, elle est de 0 par défaut.

Les greffons multicanal doivent, dans leur fonction de traitement, se référer à
une fonction appelée @b{PluginClient::get_total_buffers()#}pour déterminer le
nombre de canaux.

Pour simplifier l'implémentation des greffons en temps réel, une macro pour les
membres habituellement utilisés a été créée pour les en-têtes de classes.  Elle
prend comme paramètres l'objet de configuration et le processus objet de
l'interface utilisateur.  Les définitions de macros s'adressent principalement
aux greffons en temps réel et ne sont pas utiles pour les greffons qui ne sont
pas en temps réel.  Heureusement, les greffons qui ne sont pas en temps réel
sont plus simples.
@verbatim
PLUGIN_CLASS_MEMBERS(config_name, thread_name)
@end verbatim

Les membres de PLUGIN_CLASS_MEMBERS couramment utilisés sont décrits
ci-dessous.

@b{int load_configuration();}@*
Charge la configuration en se basant sur les images-clés qui se trouvent à
proximité et sur la position actuelle.  La définition de classe pour
load_configuration doit contenir
@verbatim
LOAD_CONFIGURATION_MACRO(plugin_class, config_class)
@end verbatim

pour implémenter le comportement par défaut de load_configuration.  Ceci
enregistre dans l'objet de configuration du greffon ce qui se trouve dans la
configuration actuelle, et retourne 1 si la nouvelle configuration est
différente de la précédente.  La valeur de retour de load_configuration est
utilisée par une autre fonction couramment utilisée, update_gui pour déterminer
si l'interface graphique a vraiment besoin d'être mise à jour.@*
L'objet de configuration du greffon est toujours appelé @b{config} dans
PLUGIN_CLASS_MEMBERS.

@b{VFrame* new_picon();}@*
Crée une vignette à afficher dans la fenêtre des ressources.  Utilisez
@verbatim
#include "picon_png.h"
NEW_PICON_MACRO(plugin_class)
@end verbatim
pour implémenter une nouvelle vignette.  De plus, l'utilisateur doit créer le
fichier d'en-tête @file{picon_png.h} à partir d'une image PNG en utilisant
@command{pngtoh}.  @command{pngtoh} est construit dans le répertoire
@file{guicast/ARCH}.@*
L'image PNG source doit s'appeler @file{picon.png} et peut être de n'importe
quel format géré par PNG@.

@b{char* plugin_title();}@*
Retourne une chaîne de texte identifiant le greffon dans la fenêtre des
ressources.  Cette chaîne doit être unique.

@b{void update_gui();}@*
Doit d'abord charger la configuration, teste un code de retour égal à 1 et
redessine ensuite l'interface graphique avec les nouveaux paramètres.  Tous les
greffons qui utilisent GuiCast ont un format semblable à
@verbatim
    void MyPlugin::update_gui()
    {
        if(thread)
        {
        if(load_configuration())
        {
            thread->window->lock_window();
            // update widgets here
            thread->window->unlock_window();
        }
        }
    }
@end verbatim
pour gérer les accès concurrents et les conditions dans lesquelles il n'y a pas
d'interface graphique.

@b{int show_gui();}@*
Instancie l'interface graphique et bascule le greffon en mode interface
graphique ("GUI mode").  C'est implémenté par
@verbatim
SHOW_GUI_MACRO(plugin_class, thread_class)
@end verbatim

@b{int set_string();}@*
Change le titre de la fenêtre de l'interface graphique en utilisant une
certaine chaîne de caractères.  C'est implémenté par
@verbatim
SET_STRING_MACRO(plugin_class)
@end verbatim

@b{void raise_window();}@*
Affiche la fenêtre de l'interface graphique sur le dessus de la pile.  C'est
implémenté par
@verbatim
RAISE_WINDOW_MACRO(plugin_class)
@end verbatim

Des fonctions importantes que doit définir l'objet de traitement sont les
fonctions qui chargent et enregistrent les données de configuration depuis les
images-clés.  Ces fonctions sont appelées par les macros, et vous n'avez donc
pas à vous préoccuper de l'accès aux données des images-clés.
@verbatim
void save_data(KeyFrame *keyframe);
void read_data(KeyFrame *keyframe);
@end verbatim

Les fonctions read_data sont utilisées dans les greffons en temps réel.  Les
fonctions data_functions convertissent la configuration du greffon depuis le
paramètre KeyFrame vers l'objet de configuration du greffon.  Les images-clés
sont enregistrées sur la timeline et peuvent changer pour chaque projet.

Utilisez un objet appelé FileXML pour effectuer la translation et certaines
commandes spécifiques pour obtenir les données à partir du paramètre KeyFrame.
Vous trouverez des exemples d'utilisation de KeyFrame et de FileXML dans les
greffons existants.
@verbatim
int load_defaults();
int save_defaults();
@end verbatim

Les fonctions load_defaults sont utilisées dans les greffons en temps réel et
les greffons qui ne sont pas en temps réel.  Les fonctions load_defaults
convertissent la configuration du greffon entre un objet BC_Hash et la
configuration du greffon.  L'objet BC_Hash enregistre les configurations dans
des fichiers individuels sur disque pour chacun des greffons, mais il n'isole
pas les configurations entre les différents projets.

La fonction qui surcharge @b{load_defaults} doit aussi créer l'objet BC_Hash.
Vous pouvez consulter un greffon existant pour des exemples d'utilisation de
BC_Hash.

D'autres objets standards peuvent être définis dans l'objet de traitement, ils
dépendent du type de greffon.

@c cincvdoc_node_number_307
@node L'objet de configuration
@subsection L'objet de configuration
@cindex Configuration, objet de

L'objet de configuration est critique pour les mises à jour de l'interface
graphique, le traitement du signal, et les paramètres par défaut dans les
greffons en temps-réel.  Remarquez qu'il n'est pas utilisé dans les greffons
qui ne sont pas temps réel.  L'objet de configuration n'hérite de rien et n'a
pas de dépendances.  Il est constitué simplement d'une classe contenant trois
fonctions et les variables spécifiques aux paramètres du greffon.

Habituellement, l'objet de configuration commence par le nom du greffon suivi
de Config.
@verbatim
    class MyPluginConfig
    {
    public:
        MyPluginConfig();
@end verbatim

Après le nom de la classe de configuration, nous trouvons les trois fonctions
requises et les variables de configuration.
@verbatim
        int equivalent(MyPluginConfig &that);
        void copy_from(MyPluginConfig &that);
        void interpolate(MyPluginConfig &prev,
        MyPluginConfig &next,
        int64_t prev_position,
        int64_t next_position,
        int64_t current_position);
        float parameter1;
        float parameter2;
        int parameter3;
    };
@end verbatim

Maintenant il faut définir les trois fonctions.  @b{Equivalent} est appelée par
LOAD_CONFIGURATION_MACRO pour déterminer si les paramètres de la configuration
locale sont identiques aux paramètres de la configuration de l'argument.  Si
equivalent retourne 0, load_configuration permet de redessiner l'interface
graphique.  Si equivalent retourne 1, l'interface graphique n'est pas
redessinée.@*
Ensuite, il y a @b{copy_from} qui transfère les valeurs de configuration depuis
le paramètre vers les variables locales.  C'est de nouveau utilisé dans
LOAD_CONFIGURATION_MACRO pour enregistrer les configurations dans des espaces
temporaires.  Une fois que LOAD_CONFIGURATION_MACRO a répliqué la
configuration, elle charge une seconde configuration.  Elle interpole ensuite
les deux configurations pour obtenir la configuration actuelle.  Les fonctions
d'interpolation réalisent l'interpolation et enregistrent les résultats dans
les variables locales.

Normalement, la fonction d'interpolation calcule une fraction précédente et une
fraction suivante en utilisant les paramètres.
@verbatim
    void MyPluginConfig::interpolate(MyPluginConfig &prev,
        MyPluginConfig &next,
        int64_t prev_position,
        int64_t next_position,
        int64_t current_position
    {
        double next_scale =
        (double)(current_position - prev_position)
        / (next_position - prev_position);
        double prev_scale =
        (double)(next_position - current_position) /
        (next_position - prev_position);
@end verbatim

Ensuite, les fractions sont appliquées à l'objet de configuration précédent et
suivant pour obtenir les valeurs actuelles.
@verbatim
        this->parameter1 =
        (float)(prev.parameter1 * prev_scale
        + next.parameter1 * next_scale);
        this->parameter2 =
        (float)(prev.parameter2 * prev_scale
        + next.parameter2 * next_scale);
        this->parameter3 =
        (int)(prev.parameter3 * prev_scale
        + next.parameter3 * next_scale);
    }
@end verbatim

Vous pouvez aussi copier les valeurs depuis le paramètre de configuration
précédent si vous ne souhaitez pas d'interpolation.

Cette utilisation est identique pour les greffons audio ou vidéo.  Lors de la
lecture vidéo, la fonction d'interpolation est appelée à chaque image, ce qui
permet d'obtenir une interpolation lissée.  Lors de la lecture audio, la
fonction d'interpolation est appelée pour chaque fragment de console et une
fois chaque fois que le point d'insertion se déplace.  C'est suffisant pour
effectuer la mise à jour de l'interface graphique lorsqu'on sélectionne des
régions sur la timeline, mais ce n'est pas assez précis pour un rendu
réellement fluide de l'effet.

Pour des rendus réellement fluides de l'audio, vous pouvez continuer à utiliser
load_configuration pour la mise à jour de l'interface graphique.  Cependant,
pour le traitement en temps réel, oubliez load_configuration et écrivez votre
propre routine d'interpolation qui chargera toutes les images-clés d'un
fragment de console et interpolera chaque échantillon.  Ceci sera vraiment très
lent et difficile à mettre au point, pouvant conduire à des améliorations qui
ne seront même pas audibles.

Une manière plus simple de rendre l'interpolation plus fine est de réduire la
taille des fragments de console à 1 échantillon.  Ceci devra être rendu et
reproduit avec un fragment de console qui soit de nouveau de l'ordre de 2048,
bien entendu.  Le pilote audio de GNU/Linux ne sait pas lire des fragments de
durée réduite à 1 échantillon.

@c cincvdoc_node_number_308
@node L'objet d'interface utilisateur
@subsection L'objet d'interface utilisateur
@cindex Interface utilisateur, objet de

L'objet d'interface utilisateur enfin, consiste en un pointeur vers une fenêtre
et des pointeurs vers tous les éléments graphiques de la fenêtre.  En utilisant
la boîte à outil de Cinelerra, il consiste en un dérivé de @b{BCWindow} et un
dérivé de @b{Thread}.  Le dérivé de Thread est déclaré dans l'en-tête du
greffon en utilisant
@verbatim
PLUGIN_THREAD_HEADER(plugin_class, thread_class, window_class)
@end verbatim

Il est ensuite défini par
@verbatim
PLUGIN_THREAD_OBJECT(plugin_class, thread_class, window_class)
@end verbatim

Ceci, en combinaison avec la macro SHOW_GUI, effectue tout le travail
d'instanciation de la fenêtre.  Ce système de deux classes est utilisé dans les
greffons en temps réel mais pas dans les greffons qui ne sont pas en temps
réel.  Les greffons qui ne sont pas en temps réel créent et détruisent leur
interface graphique dans leur fonction @b{get_parameters} et il n'y a pas
besoin de Thread.

Maintenant, la classe de la fenêtre doit être déclarée dans l'en-tête du
greffon.  Le plus facile pour implémenter la fenêtre est de copier un greffon
existant et d'en renommer les symboles.  Ce qui suit est un aperçu de ce qui se
passe.  L'en-tête du greffon doit déclarer le constructeur de la fenêtre en
utilisant les paramètres appropriés.
@verbatim
    #include "guicast.h"
    class MyPluginWindow : public BC_Window
    {
    public:
        MyPluginWindow(MyPluginMain *plugin, int x, int y);
@end verbatim

Ceci apparaît sous la forme d'une fenêtre sur l'écran placée en x et y.

Il a besoin de deux méthodes
@verbatim
int create_objects();
int close_event();
@end verbatim
et un pointeur arrière vers le greffon
@verbatim
MyPlugin *plugin;
@end verbatim

La définition du constructeur doit comporter des extents et des flags pour que
la fenêtre soit cachée lorsqu'elle vient d'être créée.  Le membre de l'objet
créé place les objets graphiques dans la fenêtre selon la syntaxe de GuiCast.
Un pointeur vers chaque élément graphique que vous désirez synchroniser à un
paramètre de configuration est enregistré dans la classe de la fenêtre.  Ils
sont mis à jour dans la fonction @b{update_gui} que vous avez précédemment
défini dans le greffon.  Les éléments graphiques sont habituellement des
dérivés d'un élément graphique GuiCast et ils surchargent des fonctions dans
GuiCast afin de gérer des événements.  Enfin, créez les appels aux objets
@verbatim
show_window();
flush();
@end verbatim
afin que la fenêtre soit dessinée en une seule fois.

Le membre close_event doit être implémenté en utilisant
@verbatim
WINDOW_CLOSE_EVENT(window_class)
@end verbatim

Chaque élément graphique de l'interface doit détecter quand sa valeur est
modifiée.  Dans GuiCast, la méthode @b{handle_event} est appelée quand une
valeur change.  Dans @b{handle_event}, l'élément graphique doit appeler
@b{plugin->send_configure_change()} pour propager les changements à toutes les
copies du greffon qui traitent des données.

@c cincvdoc_node_number_309
@node Greffons en temps réel
@section Greffons en temps réel
@cindex Greffons en temps réel

Les greffons en temps réel doivent utiliser la classe PLUGIN_CLASS_MEMBERS pour
définir le jeu de base des membres dans leurs en-têtes.  Tous les greffons en
temps réel doivent définir un membre
@verbatim
int is_realtime()
@end verbatim

qui retourne 1.  Ceci entraîne l'appel d'un certain nombre de méthodes lors de
la lecture @w{"live"} et permet au greffon d'être utilisable sur la timeline.

Les greffons en temps réel doivent surcharger un membre appelé @b{process_buffer}

Cette fonction prend différents paramètres selon que le greffon gère de l'audio
ou de la vidéo.  Le mieux est d'examiner comment est réalisé un greffon
existant pour voir comment cela est appliqué.

La fonctionnalité principale de la fonction process_buffer est de fournir un
tampon où placer la sortie, de définir la position de départ pour la sortie et
de définir le débit requis en sortie.  Pour de l'audio, il y a aussi un
paramètre qui définit le nombre d'échantillons.

La position de départ dans le tampon de sortie est l'échantillon de rang le
moins élevé sur la timeline si la lecture a lieu vers l'avant et l'échantillon
de rang le plus élevé si la lecture a lieu en arrière.  Le sens de la lecture
est déterminé par une des requêtes du greffon, décrite ci-dessous.

Les paramètres de dimensions et de position sont tous relatifs à la fréquence
des images et au taux d'échantillonnage passés à process_buffer.  C'est le
débit des données requis et il peut être différent du débit du projet.

La fonction process_realtime doit commencer par l'appel de
@b{load_configuration}.  LOAD_CONFIGURATION_MACRO retourne 1 si la
configuration a été modifiée.

Après avoir déterminé la configuration du greffon, le média d'entrée doit être
chargé pour le traitement.  Appelez :
@verbatim
    read_frame(VFrame *buffer,
        int channel,
        int64_t start_position,
        double frame_rate)
ou
    read_samples(double *buffer,
        int channel,
        int sample_rate,
        int64_t start_position,
        int64_t len)
@end verbatim

pour demander des données d'entrée à l'objet qui vient juste avant ce greffon.
La fonction read a besoin d'un tampon pour y enregistrer les données d'entrée.
Il peut être créé de manière temporaire dans le greffon, le tampon de sortie
fourni à process_buffer peut aussi être utilisé si vous n'avez pas besoin de
tampon temporaire.

Il a aussi besoin d'un ensemble de paramètres de position pour déterminer quand
vous désirez lire les données.  La position de départ, le débit et la longueur
passés à une fonction read n'ont pas besoin d'être les mêmes que les valeurs
reçues par la fonction process_buffer.  De cette manière, le greffon peut lire
des données à un débit différent du débit auquel il envoie les données vers la
sortie.

Le paramètre channel n'a de signification que pour les greffons multicanaux.
Ils leur faut lire les données pour chaque piste dans la valeur
get_total_buffers() et traiter toutes les pistes.  Les greffons monocanal
doivent passer la valeur 0 pour channel.

Des membres supplémentaires sont implémentés pour maintenir la configuration
des greffons en temps réel.  Certains d'entres-eux sont nécessaires aussi dans
le cas des greffons qui ne sont pas en temps réel.

@itemize @bullet
@item @b{void read_data(KeyFrame *keyframe);}@*
Charge dans la configuration du greffon, des données depuis une image-clé.  Il
y a, dans la structure d'une image-clé, une chaîne XML@.  Elle est analysée plus
facilement en créant un objet de type @b{FileXML}.  Voir dans un greffon
existant comment la fonction read_data est implémentée.@*
read_data charge les données depuis l'objet XML et range les valeurs dans
l'objet de configuration du greffon.  Comme les objets de configuration varient
d'un greffon à l'autre, ces fonctions ne peuvent pas être automatisées.

@item @b{void save_data(KeyFrame *keyframe);}@*
Enregistre les données depuis la configuration du greffon dans une image-clé.  A
l'intérieur de l'image-clé, vous mettrez une chaîne XML qui est normalement
créée par un objet FileXM@.  Voir dans un greffon existant comment la fonction
save_data est implémentée.@*
save_data enregistre les données venant de l'objet de configuration du greffon
dans l'objet XML.

@item @b{int load_defaults();}@*
Un greffon peut aussi obtenir ses paramètres depuis un fichier de valeurs par
défaut.  Les routines @b{load_defaults} et @b{save_defaults} utilisent un objet
de valeurs par défaut pour analyser les fichiers des valeurs par défaut.
L'objet des valeurs par défaut est créé dans @b{load_defaults} et détruit dans
le destructeur du greffon.  Voir dans un greffon existant comment l'objet des
valeurs par défaut est utilisé.

@item @b{int save_defaults();}@*
Enregistre la configuration dans l'objet des valeurs par défaut.
@end itemize

@c cincvdoc_node_number_310
@node Greffons qui ne sont pas en temps réel
@section Greffons qui ne sont pas en temps réel
@cindex Greffons qui ne sont pas en temps réel

Quelques exemples de greffons qui ne sont pas en temps réel sont @b{Normaliser}
pour l'audio et @b{Reframe} pour la vidéo.

Comme pour les greffons en temps réel, il faut implémenter @b{load_defaults} et
@b{save_defaults}.  Pour les greffons qui ne sont pas en temps réel, elles sont
utilisées non seulement pour les paramètres par défaut mais aussi pour
transférer des valeurs depuis l'interface utilisateur vers le moteur de
traitement du signal.  Elles n'ont pas besoin d'être une classe de
configuration pour les greffons qui ne sont pas en temps réel.

A l'inverse des greffons en temps réel, il ne faut pas utiliser
LOAD_CONFIGURATION_MACRO dans l'en-tête du greffon.  Il faut, à la place,
définir les méthodes suivantes.

Le greffon qui n'est pas en temps réel doit contenir un pointeur vers l'objet
par défaut.
@verbatim
BC_Hash *defaults;
@end verbatim
Il doit aussi comporter un pointeur vers une barre d'avancement
MainProgressBar.
@verbatim
MainProgressBar *progress;
@end verbatim

Le pointeur d'avancement permet aux greffons qui ne sont pas en temps réel
d'afficher leur avancement dans la fenêtre principale de Cinelerra.

Le constructeur pour les greffons qui ne sont pas en temps réel ne peut pas
utiliser PLUGIN_CONSTRUCTOR_MACRO, mais doit appeler directement
@b{load_defaults}.

Le destructeur, de la même manière, doit appeler @b{save_defaults} et
@b{delete_defaults} directement à la place de PLUGIN_DESTRUCTOR_MACRO#.

@itemize @bullet
@item @b{VFrame* new_picon();}@*
@b{char* plugin_title();}@*
Leur usage est le même que dans le cas des greffons en temps réel.

@item @b{int is_realtime();}@*
Cette fonction doit toujours retourner 0 pour indiquer que le greffon n'est pas
un greffon en temps réel.

@item @b{int get_parameters();}@*
Ici, l'utilisateur doit créer une interface utilisateur graphique, attendre que
l'utilisateur clique le bouton "Accepter" (OK) et enregistrer les paramètres
dans les variables du greffon.  Cette routine doit retourner 0 en cas de succès
et 1 en cas d'échec.  De cette manière, l'utilisateur peut arrêter l'effet
depuis l'interface graphique. @*
A l'inverse des greffons en temps réel, cette interface graphique n'a pas
besoin de tourner de manière asynchrone par rapport au greffon.  Elle doit
bloquer la fonction get_parameters jusqu'à ce que l'utilisateur clique sur
"Accepter" ou "Abandonner".

@item @b{int load_defaults();}@*
Ceci doit créer un objet de valeurs par défaut et charger les paramètres depuis
cet objet vers les variables du greffon.

@item @b{int save_defaults();}@*
Ceci permet de sauvegarder les variables du greffon dans l'objet des valeurs
par défaut.

@item @b{int start_loop();}@*
Si @b{get_parameters} a retourné 0 en raison du succès, celle-ci est appelée
une fois pour permettre au greffon de démarrer le traitement.  Le greffon doit
instancier l'objet d'avancement avec une ligne telle @w{que :}@*
@code{progress = start_progress("MyPlugin progress...",}@*
@code{PluginClien ::get_total_len());}@*
L'utilisation de @b{start_progress} varie selon que le greffon est multicanal
ou monocanal.  S'il est multicanal, il faudra toujours appeler
@b{start_progress}.  S'il est monocanal, il vous faudra d'abord savoir si la
barre d'avancement a déjà été lancée par une autre instance du greffon.@*
Si la valeur de @b{PluginClient::interactive} est de 1, il vous faut démarrer
la barre d'avancement.  Si elle est de 0, la barre d'avancement a déjà été
lancée.@*
PluginClient définit @b{get_total_len()} et @b{get_source_start()} pour décrire
la plage de la timeline a traiter.  Les unités sont soit les échantillons, soit
les images dans le débit du projet.

@item @b{int process_loop}@*
Ceci est appelé de manière répétitive jusqu'à ce que la plage de la timeline
soit traitée.  Elle comporte un tampon soit d'images, soit d'échantillons pour
la sortie et une référence vers write_length pour enregistrer le nombre
d'échantillons traités.  Si c'est un greffon audio, l'utilisateur doit appeler
@b{get_buffer_size()} pour savoir combien le tampon de sortie peut contenir
d'échantillons.@*
Ces greffons doivent utiliser @b{read_samples} ou @b{read_frame} pour lire
l'entrée.  Ces fonctions sont un peu différentes selon que le greffon est de
type temps réel ou non.@*
Elle prennent un tampon et une position relative par rapport au début de la
timeline, dans le débit de la timeline.  Vous devez alors le traiter et mettre
la sortie dans le paramètre de tampon de process_loop.  write_length doit
contenir le nombre d'échantillons créés dans le cas de l'audio.@*
Enfin, process_loop doit tester @b{PluginClient::interactive} et mettre à jour
la barre d'avancement si elle est à 1.@*
@code{progress->update(total_written);}@*
retourne 1 ou 0 si la barre d'avancement a été abandonnée.  Si elle est égale à
1, process_loop doit retourner 1 pour indiquer l'abandon.  En plus de l'abandon
de la barre d'avancement @b{process_loop} retourne 1 lorsque toute la plage de
la timeline a été traitée.

@item @b{int stop_loop();}@*
Ceci est appelé après que process_loop ait traité son dernier tampon.@*
Si PluginClient::is_interactive est à 1, ceci va appeler @b{stop_progress} dans
le pointeur de la barre d'avancement et supprimer le pointeur.  Ensuite, elle
doit supprimer tous les objets qu'elle a créée pour le traitement dans
@b{start_loop}.
@end itemize

@c cincvdoc_node_number_311
@node Greffons audio
@section Greffons audio
@cindex Greffons audio

Le plus simple des greffons audio est le Gain.  L'objet de traitement doit
inclure @file{pluginaclient.h} et hériter de @b{PluginAClient}.  Les greffons
audio en temps réel doivent définir
@verbatim
    int process_buffer(int64_t size,
        double **buffer,
        int64_t start_position,
        int sample_rate);
s'ils sont multicanal ou
    int process_buffer(int64_t size,
        double *buffer,
        int64_t start_position,
        int sample_rate);
@end verbatim
en simple canal.  Ils doivent toujours retourner 0 en cas de succès et 1 en cas
d'échec.  Dans le futur, la valeur de retour pourra provoquer un abandon du
rendu par échec.

Les fonctions de traitement doivent demander des échantillons d'entrée avec
@verbatim
    int read_samples(double *buffer,
        int channel,
        int sample_rate,
        int64_t start_position,
        int64_t len);
@end verbatim
Elles retournent toujours 0.  L'utilisateur peut indiquer un taux
d'échantillonnage et une positon de départ quelconque.

Les greffons audio qui ne sont pas en temps réel doivent définir
@verbatim
{int process_loop(double *buffer, int64_t &write_length);}
@end verbatim
pour un seul canal ou
@verbatim
{int process_loop(double **buffers, int64_t &write_length);}
@end verbatim
en multicanal.  Les greffons qui ne sont pas en temps réel utilisent un jeu
différent de fonctions read_samples pour demander des données d'entrée.  Elles
sont fixées au taux d'échantillonnage du projet.

@c cincvdoc_node_number_312
@node Greffons vidéo
@section Greffons vidéo
@cindex Greffons vidéo

Le plus simple des greffons vidéo est l'effet "Retourner".  L'objet de
traitement doit inclure @file{pluginvclient.h} et hérite de @b{PluginVClient}.
Les greffons en temps réel doivent définir
@verbatim
    int process_buffer(VFrame **frame,
        int64_t start_position,
        double frame_rate);
@end verbatim
s'ils sont multicanaux, ou
@verbatim
    int process_buffer(VFrame *frame,
        int64_t start_position,
        double frame_rate);
@end verbatim
si c'est pour un seul canal.

Les greffons vidéo qui ne sont pas en temps réel doivent définir
@verbatim
{int process_loop(VFrame *buffer);}
pour un seul canal, ou
{int process_loop(VFrame **buffers);}
@end verbatim
en multicanal.  Le nombre d'images créées dans une seule boucle de traitement
est toujours supposé être de 1 en raison de l'absence d'un paramètre
write_length.  Un code retour de 0 permet au rendu de se poursuivre.  Un code
retour de 1 arrête le rendu.

Il existe un jeu de fonctions read_frame pour demander des images d'entrée dans
les greffons vidéo qui ne sont pas en temps réel.  Ils sont fixés à la
fréquence d'images du projet.

@c cincvdoc_node_number_313
@node Greffons de transitions
@section Greffons de transitions
@cindex Greffons de transitions

La plus simple des transitions vidéo est le @b{volet} et la plus simple des
transitions audio est le @b{fondu enchaîné}.  Elles utilisent un sous-ensemble
des membres de la classe par défaut des greffons en temps réel, mais ce n'est
cependant pas analogue à ce qui a été effectué par PLUGIN_CLASS_MEMBERS pour
les transitions.

L'objet de traitement pour les transitions audio hérite toujours de
PluginAClient et il hérite toujours de PluginVClient pour les transitions
vidéo.

Les transitions peuvent ou non avoir une interface graphique.  Si elles en ont
une, elles doivent aussi gérer un processus ("thread") comme les greffons temps
réel.  Ceci est effectué avec les mêmes macros PLUGIN_THREAD_OBJECT et
PLUGIN_THREAD_HEADER que pour les greffons en temps réel.  Comme il n'y a
qu'une seule image-clé par transition, vous n'avez pas à vous préoccuper de la
mise à jour de l'interface utilisateur à partir de l'objet de traitement comme
vous deviez le faire pour les greffons en temps réel.

Si la transition possède une interface utilisateur graphique, vous pouvez
utiliser les macros PLUGIN_CONSTRUCTOR_MACRO et PLUGIN_DESTRUCTOR_MACRO pour
initialiser l'objet de traitement.  Vous aurez également besoin pour ces macros
d'un objet BC_Hash et d'un objet thread.

Comme l'interface graphique utilisateur est optionnelle, surchargez la fonction
appelée @b{uses_gui()} pour indiquer si la transition possède ou non une
interface graphique.  Elle doit retourner 1 si elle est présente et 0 dans le
cas contraire.

Les transitions ont besoin des fonctions @b{load_defaults} et @b{save_defaults}
de façon à avoir une configuration utilisable la première fois qu'elles seront
déposées sur la timeline.

Les fonctions @b{read_data} et @b{save_data} leur succèdent après l'insertion
pour accéder aux données qui sont spécifiques à chaque instance de la
transition.

La différence la plus importante entre les transitions et les effets en temps
réel est l'ajout d'une méthode @b{is_transition} à l'objet de traitement.
@b{is_transition} retourne 1 pour indiquer que le greffon est une transition.

Les transitions traitent les données dans une fonction @b{process_realtime
function}.
@verbatim
    int process_realtime(VFrame *input,
        VFrame *output);
    int process_realtime(int64_t size,
        double *input_ptr,
        double *output_ptr);
@end verbatim
Les données pour le plan suivant sont utilisées comme paramètre d'entrée de
process_realtime.  Le paramètre de sortie de process_realtime est constitué des
données du plan précédent.

Il existe des routines pour déterminer si l'on se trouve placé relativement au
début ou à la fin de la transition.

@itemize @bullet
@item
@b{PluginClient::get_source_position()} - retourne la position actuelle depuis
le début de la transition de l'échantillon de rang le plus bas se trouvant dans
les tampons.

@item
@b{PluginClient::get_total_len()} - retourne la durée entière de la transition.
Les unités sont soit les échantillons, soit les images, dans le débit demandé
par le premier greffon.
@end itemize

Les utilisateurs doivent diviser la position source par la durée totale pour
obtenir la fraction de la transition à laquelle se trouve la fonction
@b{process_realtime}.

Les transitions tournent dans le débit de données requis par le premier greffon
qui se trouve sur la piste.  Il peut être différent du débit de données du
projet.  Comme les processus en temps réels n'ont pas de paramètre de débit, il
faut utiliser @b{get_framerate()} ou @b{get_samplerate} pour obtenir le débit
demandé.

@c cincvdoc_node_number_314
@node Greffons dont l'interfaces utilisateur se met à jour lors de la lecture
@section Greffons dont l'interfaces utilisateur se met à jour lors de la lecture
@cindex Greffons, interface utilisateur

Des effets comme l'@b{Histogramme} ou le @b{Vidéoscope} ont besoin de mettre à
jour l'interface utilisateur pour afficher des informations concernant le
signal.  Ceci est obtenu avec les méthodes @b{send_render_gui} et @b{render_gui
methods}.  Normalement, dans process_buffer, lorsque l'objet de traitement veut
mettre à jour l'interface graphique, il devrait appeler @b{send_render_gui}.
Il ne devrait être appelé que dans process_buffer.  send_render_gui commence une
recherche et appelle ensuite @b{render_gui} dans l'instance de l'interface
graphique du greffon.

render_gui devrait comporter une séquence telle que
@verbatim
    void MyPlugin::render_gui(void *data)
    {
        if(thread)
        {
        thread->window->lock_window();
    // update GUI here
        thread->window->unlock_window();
        }
    }
@end verbatim

send_render_gui et render_gui utilisent un paramètre, un pointeur de type void
pour transférer les informations depuis l'objet de traitement vers l'interface
graphique.  L'utilisateur devra transtyper le pointeur en quelque chose
d'utile.

@c cincvdoc_node_number_315
@node Requêtes des greffons
@section Requêtes des greffons
@cindex Greffons, requêtes

Il existe un certain nombre de requêtes utiles auxquelles on peut accéder dans
PluginClient pour le traitement d'objets.  Certaines ont une signification
différente selon qu'on se trouve dans le mode temps-réel ou non.  Elles donnent
toutes des informations concernant le système d'exploitation ou le projet, qui
peuvent être utilisées pour améliorer la qualité du traitement.

@menu
* Requêtes système:: utilitaires permettant déterminer les ressources du système.
* Requêtes de temps:: utilitaires permettant effectuer des traitements qui dépendent du temps.
@end menu

@c cincvdoc_node_number_316
@node Requêtes système
@subsection Requêtes système
@cindex Système, requêtes

@itemize @bullet
@item @b{get_interpolation_type()}@*
Retourne le type d'interpolation voulue par l'utilisateur pour toutes les
opérations de mise à l'échelle.  C'est une macro d'overlayframe.inc.  Elle peut
être appliquée à un quelconque appel à l'objet @b{OverlayFrame}.

@item @b{get_project_smp()}@*
Donne le nombre de processeurs sur le système moins 1.  Sur un système
uniprocesseur, il est de 0.  Sur un biprocesseur, il est de 1.  Ce nombre peut
être utilisé pour gérer le parallélisme.

@item @b{get_total_buffers()}@*
Donne le nombre de pistes qu'un greffon multicanal doit traiter.
@end itemize

@c cincvdoc_node_number_317
@node Requêtes de temps
@subsection Requêtes de temps
@cindex Temps, requêtes

Un greffon en temps réel doit prendre en compte deux @w{débits :} le débit du
projet et le débit demandé.  Il existe des fonctions pour obtenir les débits du
projet et ceux demandés.  De plus, la réalisation d'effets dépendant du temps
demande l'utilisation de certaines fonctions qui vous permettent de savoir où
l'on se trouve dans l'exécution de l'effet.

@itemize @bullet
@item @b{get_project_framerate()}@*
Donne le nombre d'images par seconde de la vidéo tel que défini par les
paramètres du projet.

@item @b{get_project_samplerate()}@*
Donne le nombre d'échantillons par seconde de l'audio tel que défini par les
paramètres du projet.

@item @b{get_framerate()}@*
Donne le nombre d'images par seconde que demande le greffon qui s'exécutera
après celui-ci.  C'est le débit d'images demandé et il est identique au
paramètre frame_rate de la fonction process_buffer.

@item @b{get_samplerate()}@*
Donne le nombre d'échantillons par seconde demandé par le greffon qui suit
celui-ci, il est identique au paramètre sample_rate pour process_buffer.

@item @b{get_total_len()}@*
Donne le nombre d'échantillons ou d'images dans la page couverte par l'effet,
relativement au débit demandé.

@item @b{get_source_start()}@*
Pour les greffons en temps réel, elle donne l'échantillon ou l'image de rang le
moins élevé dans la plage de l'effet, dans le débit de données demandé.  Pour
les effets qui ne sont pas temps réel, c'est le début de la partie de la
timeline à traiter.

@item @b{get_source_position()}@*
Pour les greffons en temps réel, c'est l'échantillon de rang le moins élevé de
la région demandée, à traiter si la lecture est en sens normal et l'échantillon
de rang le plus élevé si la lecture a lieu en arrière.  Pour la vidéo, c'est le
début de l'image si l'on effectue une lecture avant et la fin de l'image si
l'on effectue une lecture arrière.  La position est relative au début de l'EDL
et dans le débit de données demandé.@*
Pour les transitions, c'est toujours l'échantillon de rang le moins élevé de la
région à traiter par rapport au début de la transition.

@item @b{get_direction()}@*
Donne le sens de l'opération de lecture en cours.  C'est une macro définie dans
transportque.inc.  C'est utile pour appeler les fonctions de lecture car ces
fonctions se placent d'elles-mêmes au début ou à la fin de la région à lire en
fonction de l'opération de lecture.

@item @b{local_to_edl()}@*
@b{edl_to_local()}@*
Celles-ci effectuent la conversion entre le débit demandé et le débit du
projet.  Elles sont utilisées pour convertir la position des images-clés sous
forme de nombres qui puissent être interpolés dans le débit demandé.  La
conversion est automatiquement basée sur la fréquence des images ou sur le taux
d'échantillonnage selon le type de greffon.

@item @b{get_prev_keyframe(int64_t position, int is_local)}@*
@b{get_next_keyframe(int64_t position, int is_local)}@*
Celles-ci donnent l'image-clé la plus proche située avant ou après la position
indiquée.  La version de load_configuration définie par macro retrouve
automatiquement les images-clés appropriées, mais vous pouvez aussi le faire
vous-même.@*
Le paramètre de position peut être soit dans le débit du projet, soit dans le
débit demandé.  Utilisez la valeur 1 pour set_local si c'est le débit demandé
et 0 si c'est le débit du projet.@*
Pour chacune des images-clés, une autre valeur de la position indique que la
position de l'image-clé est relative au début de la timeline et possède le
débit du projet.@*
La seule manière d'obtenir une interpolation douce entre les images-clés est de
convertir les objets se trouvant aux positions des images-clés vers le débit
demandé.
@end itemize

@c cincvdoc_node_number_318
@node Utiliser OpenGL
@section Utiliser OpenGL
@cindex OpenGL, utilisation

Les greffons vidéo en temps réel gèrent l'utilisation d'OpenGL@.  L'utilisation
d'OpenGL pour réaliser les greffons peut accélérer de manière importante la
lecture car la majeure partie du travail est effectuée par le matériel.
Malheureusement, chaque routine OpenGL a besoin d'une contrepartie logicielle
pour effectuer le rendu, ce qui double le volume de logiciel à maintenir.
Heureusement, l'existence d'une routine OpenGL signifie que la version
logicielle n'aura pas besoin d'être aussi optimisée qu'elle l'était lorsque le
logiciel était le seul moyen utilisable.

Comme toujours, la meilleure manière de concevoir son premier greffon OpenGL
est de copier un greffon existant et de le modifier.  Le greffon de
@b{Luminosité} est un greffon OpenGL simple à copier.  Il y a 3 points
principaux pour le rendu OpenGL et un point pour optimiser le rendu OpenGL.

@menu
* Obtenir les données OpenGL:: obtenir les données vidéo sous une forme utilisable par OpenGL
* Dessiner en utilisant OpenGL:: la méthode pour dessiner de la vidéo avec OpenGL
* Utiliser les shaders:: routines pour simplifier l'utilisation des shader
* Agrégation de greffons:: 	combiner des routines OpenGL de différents greffons en une seule.
@end menu

@c cincvdoc_node_number_319
@node Obtenir les données OpenGL
@subsection Obtenir les données OpenGL
@cindex OpenGL, Obtenir les données

Le premier problème est de faire en sorte que des greffons utilisables avec
OpenGL puissent interagir avec des greffons entièrement logiciels.  Pour
résoudre cela, toutes les informations requises pour la lecture OpenGL se
trouvent enregistrées dans l'objet VFrame qui est passé à @b{process_buffer}.
Pour gérer la 3D, le VFrame comporte, en plus des lignes d'origine du VFrame,
un PBuffer et une texture.

En mode OpenGL, le VFrame possède 3 états qui correspondent à l'emplacement de
ses données vidéo.  L'état opengl est récupéré en appelant
@b{get_opengl_state}, il est défini en appelant @b{set_opengl_state}.  Les
états sont :

@itemize @bullet
@item @b{VFrame::RAM}@*
Ceci signifie que les données vidéo sont enregistrées dans les pointeurs de
lignes habituels.  Elles doivent être chargées dans une texture avant d'être
dessinées en utilisant les routines OpenGL.

@item @b{VFram ::TEXTURE}@*
Les données vidéo sont enregistrées dans la mémoire de texture.  Elles sont
prêtes à être dessinées en utilisant les routines OpenGL.

@item @b{VFram ::SCREEN}@*
Les données vidéo sont enregistrées dans un tampon vidéo de la carte graphique.
Pour les greffons, le tampon vidéo est toujours un PBuffer.  L'image sur le
tampon vidéo ne peut pas être à nouveau répliquée à moins qu'elle ne soit relue
dans la texture et que l'état opengl ne soit réinitialisé à TEXTURE@.  Le tampon
vidéo est limité à une profondeur de 8 bits par canal.  Si un effet OpenGL est
utilisé dans un projet en virgule flottante, il ne conservera que 8 bits.
@end itemize

Dans la routine @b{process_buffer} du greffon, il y a normalement un appel à
@b{read_frame} pour obtenir des données depuis le greffon précédent dans la
chaîne.  @b{read_frame} prend un nouveau paramètre appelé @b{use_opengl}.

Le greffon passe la valeur 1 à @b{use_opengl} s'il a l'intention de gérer les
données en utilisant OpenGL@.  Il passe la valeur 0 à @b{use_opengl} s'il ne
gère les données que par logiciel.  La valeur de @b{use_opengl} est passée à la
chaîne afin de s'assurer qu'un greffon qui n'utilise que le logiciel n'obtienne
les données que dans les pointeurs de lignes.  Si @b{use_opengl} est à 0,
l'état opengl dans VFrame est RAM@.

Le greffon ne doit pas seulement savoir s'il est uniquement logiciel, mais
aussi si sa sortie ne doit être que logicielle.  Appelez @b{get_use_opengl}
pour déterminer si la sortie peut être gérée par OpenGL@.  Si @b{get_use_opengl}
retourne 0, le greffon doit passer 0 pour @b{use_opengl} dans @b{read_frame} et
effectuer son traitement par logiciel.  Si @b{get_use_opengl} est à 1, le
greffon doit décider, en fonction de son implémentation, s'il doit utiliser
OpenGL@.

Le principal problème avec OpenGL est que tous les appels gl... doivent être
lancés depuis le même processus ("thread").  Afin de s'y adapter, l'interface
possède les routines nécessaires pour faire tourner OpenGL dans un processus
commun.

@b{run_opengl} passe le contrôle au processus commun d'OpenGL@.  Ceci est
normalement appelé par le greffon dans @b{process_buffer} après qu'il ait
appelé @b{read_frame} et seulement si @b{get_use_opengl} est à 1.

Par une série d'indirections, @b{run_opengl} transfère le contrôle à une
fonction virtuelle appelée @b{handle_opengl}.  @b{handle_opengl} doit être
surchargée par une fonction qui exécute toute les routines OpenGL@.  Le contenu
de @b{handle_opengl} soit être compris dans @b{#ifdef HAVE_GL} ... @b{#endif}
afin de lui permettre d'être compilé sur des systèmes n'ayant pas de support
graphique, comme des noeuds de rendu.  La valeur de retour de @b{handle_opengl}
est passée en retour depuis @b{run_opengl}.

@b{read_frame} ne peut pas être appelé depuis @b{handle_opengl}.  Ceci créerait
un verrouillage récursif parce qu'il entraînerait l'appel de @b{run_opengl} par
d'autres objets.

Une fois dans @b{handle_opengl}, le greffon a le plein usage de toutes les
fonctionnalités d'OpenGL@.  VFrame fournit certaines fonctions pour automatiser
les séquences communes d'OpenGL.

Le paramètre de VFrame à @b{process_buffer} est toujours disponible au travers
de la fonction @b{get_output(int layer)}.  Si le greffon est multicanal, le
paramètre de calque récupère un calque spécifique des tampons de sortie.  Le
PBuffer du tampon de sortie est l'endroit où doit aller la sortie OpenGL si un
traitement quelconque est effectué.

@c cincvdoc_node_number_320
@node Dessiner en utilisant OpenGL
@subsection Dessiner en utilisant OpenGL
@cindex Dessiner en utilisant OpenGL

La séquence de commandes pour dessiner sur le PBuffer de sortie commence par
mettre la vidéo dans une zone mémoire qui peut être rappelée pour @w{dessiner
:}
@verbatim
get_output()->to_texture();
get_output()->enable_opengl();
@end verbatim

@itemize @bullet
@item @b{to_texture} transfère les données OpenGL depuis l'endroit où elles se
trouvent vers la mémoire de la texture de sortie et configure l'état de la
sortie à TEXTURE@.
@item @b{enable_opengl} rend le contexte OpenGL relatif au PBuffer de sortie.
@end itemize

L'étape suivante est de dessiner la texture avec certains traitement sur le
PBuffer.  La séquence de commandes normale pour dessiner une texture @w{est :}
@verbatim
get_output()->init_screen();
get_output()->bind_texture(0);
get_output()->draw_texture();
@end verbatim

@itemize @bullet
@item @b{VFrame::init_screen} définit des valeurs connues pour le "frustrum" et
les paramètres d'OpenGL.
@item @b{VFrame::bind_texture(int texture_unit)} lie la texture à l'unité de
texture indiquée et l'active.
@item @b{VFrame::draw_texture()} appelle les fonctions de vertex pour dessiner
la texture normalisée à la taille du PBuffer.  Faites-en une copie si vous
désirez des vertex (vertices) personnalisés.
@end itemize

La dernière étape de la routine handle_opengl, après que les textures aient été
dessinées sur le PBuffer, est de positionner l'état de la sortie d'opengl à
SCREEN par un appel à @b{VFrame::set_opengl_state}.  Le greffon ne doit pas
faire de relecture du tampon vidéo vers une texture ou des pointeurs de ligne
s'il ne fait pas de traitement supplémentaire.  Les greffons ne doivent laisser
que la sortie dans la texture ou la mémoire si son emplacement résulte d'un
traitement normal.  Il doivent positionner l'état d'opengl à RAM ou TEXTURE
s'ils le font.

@b{Les modèles colorimétriques en OpenGL :}@*
Le modèle colorimétrique présenté aux routines OpenGL est toujours en virgule
flottante car c'est ce qu'utilise OpenGL, mais ce peut être YUV ou RVB selon
les paramètres du projet.  Si c'est YUV, il est décalé d'exactement 0,5 comme
avec les traitements logiciels.  Passer des modèles colorimétrique YUV aux
greffons a été rendu nécessaire pour des raisons de vitesse.  L'autre
possibilité était de convertir YUV en RVB lors de la première étape nécessaire
à OpenGL@.  Chaque effet et étape de rendu aurait alors eu besoin d'une routine
de conversion YUV vers RVB@.  Avec le choix d'YUV, seule l'étape de composition
finale doit comporter une routine de conversion YUV vers RGB.

@c cincvdoc_node_number_321
@node Utiliser les shaders
@subsection Utiliser les shaders
@cindex OpenGL, Utiliser les shaders

Il n'y a que très peu d'effets qui puisse faire quelque chose d'utile en
dessinant directement des textures dans le PBuffer.  Normalement, ils
définissent un @b{shader}.  Le shader est un programme C qui tourne sur la
carte graphique.  Comme la carte graphique est optimisée pour les graphiques,
cela lui permet d'être beaucoup plus rapide que s'il tournait sur le
processeur.

Les shaders sont écrits dans le langage de Shading OpenGL@.  Le code source du
shader est contenu dans une chaîne.  La séquence normale pour utiliser un
shader se trouve après un appel à @b{enable_opengl}.

@verbatim
char *shader_source = "...";
unsigned char shader_id = VFrame::make_shader(0, shader_source, 0);
glUseProgram(shader_id);
// Set uniform variables using glUniform commands
@end verbatim

Les étapes de compilation et d'édition de liens pour les shaders sont
encapsulées dans la commande VFrame::make_shader.  Elle retourne un identifiant
de shader_id qui peut être passé aux fonctions OpenGL@.  Le premier et le
dernier paramètre doivent toujours être 0.  Un nombre arbitraire de chaînes
sources peut être placé entre les 0.  Les chaînes sources sont concaténées par
@b{make_shader} en un gros source de shader.  S'il y a plusieurs fonctions
@b{main}, les fonctions main sont renommées et exécutées dans l'ordre.

Il existe de nombreuses macros utiles pour les shaders dans
@file{playback3d.h}.  Jusqu'à présent, tous les shaders ont été des "fragment
shaders".  Après que le shader ait été initialisé, il dessine la texture en
partant de @b{init_screen}.  Le programme shader doit être désactivé par un
autre appel à @b{glUseProgram(0)} avec 0 comme paramètre.

L'identifiant du shader et le code source sont maintenus en mémoire tant que
Cinelerra tourne.  Les appels ultérieurs à @b{make_shader} avec le même code
source s'exécuteront beaucoup plus vite.

@c cincvdoc_node_number_322
@node Agrégation de greffons
@subsection Agrégation de greffons
@cindex Agrégation de greffons

On peut obtenir d'autres améliorations de la vitesse en combinant les routines
OpenGL de deux greffons en une seule fonction handle_opengl.  Ceci est réalisé
lorsque @b{Images vers champs} et @b{RVB vers 601} sont attachés dans cet
ordre.  Les agrégations de plus de deux greffons sont possibles mais très
difficiles à faire fonctionner.  L'agrégation est utile avec OpenGL parce que
chaque greffon doit copier la vidéo depuis une texture vers un PBuffer.  Il n'y
a pas d'opération de copie par logiciel.

Dans l'agrégation, un greffon traite tour depuis l'autre greffon et l'autre
greffon "fall through".  Les greffons fall through doivent copier leurs
paramètres vers le tampon de sortie de manière à pouvoir être détectés par le
greffon qui effectue le traitement.

Le VFrame utilisé comme tampon de sortie comporte une table de paramètres
permettant de passer les paramètres entre les greffons et il est accédé par
@b{get_output()->get_params()}.  Les paramètres sont définis et récupérés dans
la table par des appels à @b{update} et @b{get} exactement comme pour les
valeurs par défaut.

Le greffon fall through doit déterminer si le greffon de traitement est attaché
par des appels à @b{next_effect_is} et @b{prev_effect_is}.  Ils prennent le nom
du greffon de traitement comme paramètre de chaîne de caractères et retournent
1 si le greffon suivant ou précédent est le greffon de traitement.  Si l'un
d'entre-eux retourne 1, le greffon fall through doit quand même appeler
@b{read_frame} pour propager les données mais rend la main ensuite.

Le greffon de traitement doit appeler @b{next_effect_is} et @b{prev_effect_is}
pour déterminer s'il est agrégé à un greffon fall through.  Si c'est le cas, il
doit effectuer les opérations du greffon fall through dans sa routine OpenGL.
Les paramètres pour le greffon fall through devraient être disponibles par
@b{get_output()->get_params()} si le greffon fall through les a positionnés.

@c cincvdoc_node_number_323
@node Raccourcis clavier
@chapter Raccourcis clavier
@cindex Raccourcis clavier
@cindex Raccourcis

Alex Ferrer a commencé à rassembler la plupart des raccourcis clavier.  La
plupart des touches fonctionnent sans modificateur comme @key{MAJ} or
@key{CTRL}.  La plupart des fenêtres peuvent être fermées par @kbd{CTRL-w}.  La
plupart des opérations peuvent être abandonnées avec @key{Echap} et acceptées
avec @key{Entrée}.

@menu
* Raccourcis de la fenêtre du programme::
* Raccourcis des fenêtres de la visionneuse et du compositeur::
* Raccourcis des commandes de transport en lecture::
* Raccourcis de la fenêtre d'acquisition::
@end menu

@c cincvdoc_node_number_331
@node Raccourcis de la fenêtre du programme
@section Raccourcis de la fenêtre du programme
@cindex Raccourcis de la fenêtre du programme

@menu
* Raccourcis d'édition::
* Raccourcis d'édition des marques et des points d'entrée/sortie::
* Raccourcis de navigation::
* Raccourcis d'opérations sur les fichiers::
* Raccourcis d'édition des images-clés::
* Raccourcis de manipulation de piste::
* Raccourcis de ce qui est dessiné sur la timeline::
@end menu

@c cincvdoc_node_number_332
@node Raccourcis d'édition
@subsection Raccourcis d'édition
@cindex Edition, raccourcis

@multitable @columnfractions .2 .8
@item @kbd{z}
@tab Annuler
@item @kbd{Majusc Z}
@tab Refaire
@item @kbd{x}
@tab Couper
@item @kbd{c}
@tab Copier
@item @kbd{v}
@tab Coller
@item @kbd{Suppr}
@tab Effacer
@item @kbd{MAJ Espace}
@tab Insérer une partie vierge
@item @kbd{m}
@tab Rendre la région muette
@item @kbd{a}
@tab Select all
@item @kbd{MAJ + clic}
@tab Lorsque c'est effectué sur un plan, étend la sélection en surbrillance
jusqu'à la position du curseur.  Lorsque c'est effectué au dessus de la limite
d'un effet l'opération d'ajustement ne s'appliquera qu'à l'effet.
@end multitable

@c cincvdoc_node_number_333
@node Raccourcis d'édition des marques et des points d'entrée/sortie
@subsection Raccourcis d'édition des marques et des points d'entrée/sortie
@cindex Raccourcis d'édition des marques et des points d'entrée/sortie

@multitable @columnfractions .2 .8
@item @kbd{[}
@tab Changer l'état du point d'entrée
@item @kbd{]}
@tab Changer l'état du point de sortie
@item @kbd{l}
@tab Changer l'état de la marque se trouvant à la position actuelle
@item @kbd{CTRL <-}
@tab Aller à la marque précédente
@item @kbd{CTRL ->}
@tab Aller à la marque suivante
@end multitable

@c cincvdoc_node_number_334
@node Raccourcis de navigation
@subsection Raccourcis de navigation
@cindex Raccourcis de navigation

@multitable @columnfractions .2 .8
@item @kbd{Flèche droite}
@tab Déplacer vers la droite *
@item @kbd{Flèche gauche}
@tab Déplacer vers la gauche *
@item @kbd{Flèche haute}
@tab Dézoomer *
@item @kbd{Flèche basse}
@tab Zoomer *
@item @kbd{CTRL Haut}
@tab Augmenter l'amplitude la courbe actuelle
@item @kbd{CTRL Bas}
@tab Réduire l'amplitude de la courbe actuelle
@item @kbd{CTRL Alt Haut}
@tab Augmenter l'amplitude de toutes les courbes
@item @kbd{CTRL Alt Bas}
@tab Réduire l'amplitude de toutes les courbes
@item @kbd{ALT Haut}
@tab Augmenter l'amplitude de la courbe
@item @kbd{ALT Bas}
@tab Réduire l'amplitude de la courbe
@item @kbd{f}
@tab Adapter le temps affiché à la sélection
@item @kbd{Alt f}
@tab Définir la plage de tous les types d'automation.  Adapter la plage maximum
et minimum de la sélection actuelle en surbrillance
@item @kbd{Ctrl Alt f}
@tab Définir la plage du type d'automation actuellement sélectionné adaptée à
la plage maximum et minimum de la sélection actuelle en surbrillance
@item @kbd{Alt Left}
@tab Déplacement d'un plan vers la gauche
@item @kbd{Alt Flèche droite}
@tab Déplacement d'un plan vers la droite
@item @kbd{Page Préc}
@tab Déplacer vers le haut *
@item @kbd{Page Suiv}
@tab Déplacer vers le bas *
@item @kbd{Ctrl Page Préc}
@tab Augmenter la hauteur de la piste
@item @kbd{Ctrl Page Suiv}
@tab Réduire la hauteur de la piste
@item @kbd{Début}
@tab Aller au début de la *
@item @kbd{Fin}
@tab Aller à la fin de la timeline *
@end multitable

* Vous est parfois nécessaire de cliquer sur la timeline pour désactiver toutes
les boîtes de texte ou les boutons de réglage avant que ceci ne puisse
fonctionner.

@c cincvdoc_node_number_335
@node Raccourcis d'opérations sur les fichiers
@subsection Raccourcis d'opérations sur les fichiers
@cindex Raccourcis d'opérations sur les fichiers

@multitable @columnfractions .2 .8
@item @kbd{n}
@tab Nouveau projet
@item @kbd{o}
@tab Charger des fichiers
@item @kbd{s}
@tab Enregistrer le projet
@item @kbd{r}
@tab Enregistrer
@item @kbd{MAJ R}
@tab Rendu
@item @kbd{q}
@tab Quitter
@item @kbd{MAJ P}
@tab Préférences
@item @kbd{MAJ B}
@tab Rendu en tâche de fond
@item @kbd{MAJ F}
@tab Définir le format
@item @kbd{}
@tab
@end multitable

@c cincvdoc_node_number_336
@node Raccourcis d'édition des images-clés
@subsection Raccourcis d'édition des images-clés
@cindex Raccourcis d'édition des images-clés
@cindex Images-clés, raccourcis d'édition

@multitable @columnfractions .2 .8
@item @kbd{MAJ X}
@tab Couper les images-clés
@item @kbd{MAJ C}
@tab Copier les images-clés
@item @kbd{MAJ V}
@tab Coller images-clés
@item @kbd{MAJ Suppr}
@tab Réinitialiser les images-clés
@item @kbd{Alt c}
@tab Copier l'image-clé par défaut
@item @kbd{Alt v}
@tab Coller l'image-clé par défaut
@end multitable

@c cincvdoc_node_number_337
@node Raccourcis de manipulation de piste
@subsection Raccourcis de manipulation de piste
@cindex Raccourcis de manipulation de piste

@multitable @columnfractions .2 .8
@item @kbd{t}
@tab Ajouter une piste audio
@item @kbd{u}
@tab Insérer la transition audio par défaut
@item @kbd{MAJ T}
@tab Ajouter une piste vidéo
@item @kbd{MAJ U}
@tab Insérer la transition vidéo par défaut
@item @kbd{d}
@tab Supprimer la dernière piste
@item @kbd{MAJ L}
@tab Lire en boucle
@item @kbd{TAB}
@tab Basculer l'état armé d'une seule piste
@item @kbd{MAJ-TAB}
@tab Inverser l'état armé de toutes les autres pistes
@end multitable

@c cincvdoc_node_number_338
@node Raccourcis de ce qui est dessiné sur la timeline
@subsection Raccourcis de ce qui est dessiné sur la timeline
@cindex Raccourcis de ce qui est dessiné sur la timeline

@multitable @columnfractions .2 .8
@item @kbd{1}
@tab Afficher les titres
@item @kbd{2}
@tab Afficher les transitions
@item @kbd{3}
@tab Images-clés de fondu
@item @kbd{4}
@tab Images-clés de sourdine
@item @kbd{5}
@tab Images-clés de mode
@item @kbd{6}
@tab Images-clés de panoramique
@item @kbd{7}
@tab Images-clés de la caméra
@item @kbd{8}
@tab Images-clés du projecteur
@item @kbd{9}
@tab Images-clés de greffon
@item @kbd{0}
@tab Images-clés de masque
@item @kbd{-}
@tab Zoom de la caméra
@item @kbd{=}
@tab Zoom du projecteur
@end multitable

@c cincvdoc_node_number_339
@node Raccourcis des fenêtres de la visionneuse et du compositeur
@section Raccourcis des fenêtres de la visionneuse et du compositeur
@cindex Raccourcis des fenêtres de la visionneuse et du compositeur

@multitable @columnfractions .2 .8
@item @kbd{x}
@tab Couper
@item @kbd{c}
@tab Copier
@item @kbd{v}
@tab Coller
@item @kbd{v}
@tab Joindre
@item @kbd{b}
@tab Remplacer
@item @kbd{[}
@tab Point d'entrée
@item @kbd{]}
@tab Point de sortie
@item @kbd{l}
@tab Changer l'état de la marque à la position actuelle
@item @kbd{Ctrl <-}
@tab Aller à la marque précédente
@item @kbd{Ctrl ->}
@tab Aller à la marque suivante
@item @kbd{Début}
@tab Aller au début
@item @kbd{Fin}
@tab Aller à la fin
@item @kbd{z}
@tab Annuler
@item @kbd{Majusc Z}
@tab Refaire
@item @kbd{+}
@tab Zoomer
@item @kbd{-}
@tab Dézoomer
@end multitable

@c cincvdoc_node_number_340
@node Raccourcis des commandes de transport en lecture
@section Raccourcis des commandes de transport en lecture
@cindex Raccourcis des commandes de transport en lecture

Les commandes de transport fonctionnent dans n'importe quelle fenêtre
comportant les commandes de navigation.  On y a accès par l'intermédiaire du
pavé numérique lorsque le verrouillage numérique est désactivé.

@multitable @columnfractions .08 .17 .08 .17 .08 .17 .08 .17
@item @kbd{4}
@tab reculer d'une image
@tab @kbd{5}
@tab reculer lentement
@tab @kbd{6}
@tab reculer à vitesse normale
@tab @kbd{+}
@tab reculer rapidement
@item @kbd{1}
@tab avancer d'une image
@tab @kbd{2}
@tab avancer lentement
@tab @kbd{3}
@tab Lecture
@tab @kbd{Entrée}
@tab avancer rapidement
@item @kbd{0}
@tab Arrêt
@tab
@tab
@tab
@tab
@tab
@tab
@end multitable

@key{ESPACE} permet la lecture normale, presser deux fois n'importe quelle
touche mettra en Pause.  Presser n'importe quelle touche de transport alors que
@key{CTRL} est appuyé entraînera la lecture de la région se trouvant entre les
points d'entrée et de sortie, s'ils sont définis.

@c cincvdoc_node_number_341
@node Raccourcis de la fenêtre d'acquisition
@section Raccourcis de la fenêtre d'acquisition
@cindex Raccourcis de la fenêtre d'acquisition

@multitable @columnfractions .2 .8
@item @kbd{Espace}
@tab Démarrer et mettre en pause l'enregistrement du lot en cours
@item @kbd{l}
@tab Placer ou supprimer une marque à l'emplacement actuel
@end multitable

@include gpl_fr.texi

@ifnotplaintext
@ifnothtml
@ifnotdocbook
@c cincvdoc_node_number_324
@node Index
@unnumbered Index
@printindex cp
@end ifnotdocbook
@end ifnothtml
@end ifnotplaintext

@bye
