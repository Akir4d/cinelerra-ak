\input texinfo  @c -*-texinfo-*-

@c Manual do Cinelerra CV - PORTUGUÊS DO BRASIL
@c A versão do Cinelerra Community Version está disponível em http://cvs.cinelerra.org. 
@c Mantenedor do manual: Nicolas MAUFRAIS - e.conti@gmx.net
@c Mantenedores da tradução para português do Brasil são
@c Flavio Freitas (qazav3.0@gmail.com) e Wille Marcel (wille.yyz@gmail.com)

@c Este arquivo texinfo é usado para gerar o manual em vários formatos de saída:
@c    - pdf (manual online)
@c    - html (manual online e wiki)
@c    - txt (manual online)
@c    - xml (ajuda contextual)
@c O formato deve respeitar algumas regras restritas, para que os diferentes formatos
@c de saída sejam exibidos corretamente.
@c * Não use @example uma vez que isto não é exibido corretamente no wiki

@c Licença:
@c Você pode redistribuir o manual do Cinelerra CV e/ou modificá-lo sob os termos
@c da GNU General Public License, conforme publicado pela Free Software
@c Foundation; tanto na versão 2 da Licença, ou (à sua opção) qualquer versão
@c posterior.

@setfilename cinelerra_cv_manual_pt_BR.info
@documentlanguage pt
@documentencoding ISO-8859-1
@settitle Manual do Cinelerra CV
@afourpaper
@set EDITION 1.46.pt_BR
@set VERSION 2.1

@c Tamanho de papel. Opções disponíveis são:
@c (sem opção) : páginas de 8.5 inch por 11 inch (216mm por 280 mm) tamanho padrão,
@c               conforme usado nos Estados Unidos
@c @afourpaper : Papel A4 tamanho europeu (210mm por 297mm)
@c @afivepaper : Papel A5 tamanho europeu
@c @afourwide  : Papel A4 tamanho europeu em formato wide
@c @smallbook  : páginas de 7 inch por 9.25 inch (178mm por 235mm),
@c               boa para livros
@afourpaper

@finalout
@titlepage
@title Manual do Cinelerra CV
@subtitle @b{Editor de vídeo não-linear para GNU/Linux}
@subtitle @b{Community Version} @value{VERSION}
@subtitle Edição @value{EDITION}
@author Heroine Virtual Ltd
@author Equipe do Cinelerra CV
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2003, 2004, 2005, 2006 Adam Williams - Heroine Virtual Ltd.

Copyright @copyright{} 2003, 2004, 2005, 2006, 2007 Cinelerra CV Team.@*

Este manual é livre. Você pode redistribui-lo e/ou modificá-lo sob os termos da GNU General Public License, conforme publicada pela Free Software Foundation; tanto a versão 2 da Licença, quanto (à sua escolha) qualquer versão posterior.

Este documento é distribuído na expectativa de que será útil, mas SEM QUAISQUER GARANTIAS DE QUALQUER TIPO, nem mesmo as garantias de COMERCIALIZAÇÃO ou ADEQUAÇÃO A PROPÓSITOS PARTICULARES. Veja a GNU General Public License para mais detalhes. 

Você deve ter recebido uma cópia da GNU General Public License junto com o seu Cinelerra. Caso não a tenha recebido, escreva para: 
	The Free Software Foundation, Inc.,
	51 Franklin Street, Fifth Floor
	Boston, MA  02110-1301, USA.
@end titlepage
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thischapter @| @| @thispage

@setchapternewpage odd

@contents

@ifnottex
@c cincvdoc_node_number_1
@node Top
@top
@end ifnottex

@menu
* Introdução::                      		O Cinelerra resumido.
* Instalação::                      		Fazendo o Cinelerra funcionar em seu sistema.
* Configuração::                     		Ajustando o comportamento do Cinelerra.
* Atributos do projeto::                	Mudando a forma como a mídia é disposta.
* Carregando e salvando arquivos::          	Movendo a mídia entre o disco e o Cinelerra.
* Janela de Programa::
* Editando::
* Janela de composição::
* Janela de visualização::
* Janela de recursos::
* Janela de medidores de nível de som::
* Controles de transporte::
* Barra de tempo::
* Efeitos tempo-real::
* Efeitos renderizados::
* Efeitos ladspa::
* Transições::
* Usando quadros-chave::                        Fazendo os efeitos mudarem conforme passa o tempo.
* Capturando mídia::                   	Movendo a mídia do mundo real para o disco rígido.
* Renderizando arquivos::
* Dicas::                              		Aplicações não-usuais do Cinelerra para problemas comuns.
* Resolvendo problemas::                   	Problemas com o Cinelerra.
* Autoração de plugin::                  	Como escrever novos efeitos.
* Atalhos de teclado::                		Como acelerar a maioria dos comandos com o teclado.
* Copying::                           		A GNU General Public License
@ifnotplaintext
@ifnothtml
@ifnotdocbook
* Índice::                             		Um menu cobrindo vários tópicos.
@end ifnotdocbook
@end ifnothtml
@end ifnotplaintext
@end menu

@c cincvdoc_node_number_2
@node Introdução
@chapter Introdução
@cindex Introdução

@menu
* Sobre o Cinelerra::
* As duas versões do Cinelerra::
* Sobre este manual::
* Buscando ajuda::
* Tutoriais::
* Links diversos::
@end menu

@c cincvdoc_node_number_3
@node Sobre o Cinelerra
@section Sobre o Cinelerra
@cindex Sobre o Cinelerra

Por anos algumas pessoas desejaram uma forma de editar seu vídeo e áudio em um lugar que fosse tão fluido como os em que se escreve textos. Cinelerra tenta ser um local único para todas as suas necessidades que envolvam edição de vídeo e áudio. Toda a gravação, edição e exibição ("playback") pode ser feita aqui. O software também pode ser usado como um reprodutor de áudio. Ele pode ser usado para gravar áudio ou vídeo. Ele pode até ser usado para retocar fotos.

Existem dois tipos de pessoas que apreciam vídeos: produtores que querem criar novos conteúdos, voltando a seus conteúdos futuramente para um melhor refinamento, e consumidores, que querem adquirir o conteúdo e assisti-lo. O Cinelerra não visa consumidores. O Cinelerra possui vários recursos para conteúdo não-comprimido, processamento de alta resolução e composição, com muito poucos atalhos. Produtores precisam dessas funções devido à necessidade de retocar várias gerações de gravação com alterações no formato, o que torna o programa muito complexo. Existem várias outras ferramentas padrão para consumidores, como MainActor, Kino ou Moxy, que você pode considerar antes de usar o Cinelerra.

@c cincvdoc_node_number_4
@node As duas versões do Cinelerra
@section As duas versões do Cinelerra
@cindex As duas versões do Cinelerra

Existem duas versões do Cinelerra. Uma pode ser encontrada no endereço @uref{http://www.heroinewarrior.com} e a outra em @uref{http://cvs.cinelerra.org}. Esta documentação está focada no @b{Cinelerra-CV (Community Version)}.

O Cinelerra é desenvolvido de forma "upstream" por uma entidade a quem chamaremos de HV que é uma entidade que compartilha, mas que não é do tipo "comunidade". HV prefere trabalhar em sua própria cópia do Cinelerra por conta própria, lançando um novo código em uma base de seis em seis meses mais ou menos. Alguns desenvolvedores decidiram que seria interessante melhorá-la de uma forma comunitária, mas não queriam exatamente dividir ("fork") o desenvolvimento. Basicamente, mantemos uma cópia que é bastante similar à publicação oficial. Porém, aplicamos nossas correções de erros, correções de compilação ("compiler compliance fixes") e alguns melhoramentos ao SVN. Nós tentamos mandar os patches aos desenvolvedores oficiais. Assim, a versão do Cinelerra CV possui um número de características que a versão oficial não possui.

Em termos de estabilidade, ao contrário de outros programas, a publicação que o HV faz não pode ser descrita como uma publicação "estável". Após a versão do Cinelerra HV é lançada, normalmente há questões relacionadas a erros ("bugs") ou usabilidade. Além disso, nem todas as implementações do Cinelerra CV conseguem entrar na versão oficial (por exemplo, renderização para um pipe YUV). Desta forma, quando há um novo lançamento, um dos membros (j6t) funde ("merge") o código do HV com o do Cinelerra CV, pegando as melhorias do HV e re-arranjando o código para ser mais similar ao do HV (espaços em branco, nomenclatura de funções, nomenclatura de diretórios, leves mudanças nas implementações, etc). Após a fusão, a última versão do Cinelerra CV é possivelmente um pouco instável até que todas as questões do novo código HV adicionadas sejam reparadas, usuários encontrem erros e conforme o tempo permita corrigi-los. O Cinelerra CV pode ser visto como uma tentativa da comunidade de estabilizar a publicação do HV e também como um esforço de adicionar melhorias de uma forma comunitária onde podemos comentar as implementações de cada plug-in de cada um. De fato, a HV fica de olho no que fazemos e, eventualmente, diz algumas palavras aqui ou ali sobre nossas implementações. 

Dada a discussão acima, pode-se dizer que obter o SVN logo antes de uma fundição entre os códigos ("merge") seja uma versão estável, mas você provavelmente encontrará problemas de arquivos de descrição de projetos não serem mais compatíveis. Além disso, a HV também acha erros que nós não havíamos encontrado. Em alguns casos, também corrige erros que havíamos apontado mas não conseguíamos corrigir. Assim, o que é "estável" torna-se realmente questionável e para você decidir, mas se você se mantiver conosco, provavelmente conseguirá se comunicar melhor com a gente do que com a HV.

@c cincvdoc_node_number_5
@node Sobre este manual
@section Sobre este manual
@cindex Sobre este manual

Esta edição é a @value{EDITION}, válida para a versão @value{VERSION} da versão do Cinelerra CV. Você pode redistribui-lo e/ou modificá-lo sob os termos da GNU General Public License, conforme publicada pela Free Software Foundation; tanto a versão 2 da Licença, quanto (à sua escolha) qualquer versão posterior.

Este manual se origina do "Secrets of Cinelerra", um excelente manual escrito por @w{Adam @sc{Williams}} do @w{@sc{Heroine Virtual Ltd}}. Em 2003, Alex @sc{Ferrer} criou um Wiki baseado naquele manual e adicionou um monte de capturas de tela e novas informações. Naquela época, o Cinelerra CV ainda não tinha seu próprio manual e informações relacionadas à Versão da Comunidade do Cinelerra estavam jogadas pela internet (listas de discussão, IRC, sites, wiki, etc). Em 2006, Nicolas @sc{Maufrais} combinou o "Secrets of Cinelerra" original com o conteúdo do Wiki de Alex @sc{Ferrer} em um único documento. 

Mantenedores da documentação do Cinelerra-CV:@*
Inglês: Nicolas @sc{Maufrais} (coordenador)@*
Francês: Jean-Luc @sc{Coulon}@*
Português do Brasil: Flavio @sc{Soares}

Outros contribuintes para este manual são: Alexandre @sc{Bourget}, Kevin @sc{Brosius}, Carlos @sc{Davila}, Cillian @sc{de Roiste}, Rafael @sc{Diniz}, Pierre @sc{Dumuid}, Mike @sc{Edwards}, Martin @sc{Ellison}, Graham @sc{Evans}, Scott @sc{Frase}, Joe @sc{Friedrichsen}, Gus Gus, Terje @sc{Hanssen}, Mikko @sc{Huhtala}, Ben @sc{Jorden}, Nathan @sc{Kidd}, Marcin @sc{Kostur}, Joseph @sc{L.}, Valentina @sc{Messeri}, Sean @sc{Pappalardo}, Herman @sc{Robak}, Dana @sc{Rogers}, Jim @sc{Scott}, Andraz @sc{Tori}, Raffaella @sc{Traniello}, Hermann @sc{Vosseler}.

Agradecemos à equipe do projeto GNU, e particularmente a Karl @sc{Berry}, maintenedor do GNU Texinfo, pela preciosa ajuda que nos deu durante a elaboração deste manual.

@ifnotplaintext
@ifnothtml
@ifnotdocbook

@b{Nota:} A intenção deste manual é que ele seja impresso em duplex. Portanto, é normal no manual em PDF que algumas páginas pares sejam deixadas em branco.
@end ifnotdocbook
@end ifnothtml
@end ifnotplaintext

Para conseguir as fontes do manual, instale o cogito e o git-core em seu computador em rode: @*
@command{cg-clone git://scm.pipapo.org/cinelerra-nicolasm} @*

@c cincvdoc_node_number_6
@node Buscando ajuda
@section Buscando ajuda
@cindex Buscando ajuda
@cindex Ajuda, buscando

Você pode conseguir ajuda em: @*
@itemize @bullet
@item @b{Canal IRC:} #cinelerra no Freenode
@item @b{Lista de discussão:} @uref{https://init.linpro.no/mailman/skolelinux.no/listinfo/cinelerra}
@item @b{Site do Cinelerra CV:} @uref{http://cvs.cinelerra.org}
@end itemize

@xref{Reportando erros}, caso você queira preencher um reporte de erros.

@c cincvdoc_node_number_327
@node Tutoriais
@section Tutoriais
@cindex Tutoriais

Alguns tutoriais estão disponíveis na internet:
@itemize @bullet
@item @b{Cinelerra Tutorial - Getting Started}, por Rob @sc{Fisher}@*
@uref{http://www.robfisher.net/video/cinelerra1.html}
@item @b{Cinelerra video tutorials}, por The Source - tutorials (conversa e vídeo de telas capturadas), dentro de The Source Show@*
@uref{http://www.thesourceshow.org/node/11}@*
- #1 está no Episódio 6, "The Return Of The Pixel", do min 45 ao min 60 (Introdução ao Cinelerra e edição não-linear, a interface de 4 janelas, atributos de projeto, carregando arquivos).@*
- #2 está no Episódio 1, "The Filesystem Menace", do min 32 ao min 54 (Armando trilhas, aproximação de amostragem, caixas de seleção, edição em dois monitores, edição por recorte e cola, adicionando e movendo as trilhas, edição de arrastar e soltar, trimming, transições). @*
- #3 está no Episódio 2, "Attack Of The Elephants (Dream)", do min 45 a 1:12 (Quadros-chave, câmera e projetor, máscaras, títulos, efeitos). 
@item @b{Beginner's Guide to Exporting Video from Cinelerra}, por Scott @sc{Frase}@*
@uref{http://content.serveftp.net/video/renderTest/guideToCinExport.html}
@item @b{Capturing desktop screens in Cinelerra}, vídeo de telas capturadas por Scott @sc{Frase}@*
@uref{http://www.youtube.com/watch?v=MhaOgNQ0Bbc}
@item @b{Guide d'utilisation de Cinelerra}, em francês @*
@uref{http://www.funix.org/fr/linux/cinelerra.htm}
@item @b{Faire un montage video} tutorial em francês para iniciantes no Cinelerra HV, por Laurent @sc{Bellegarde}@*
@uref{http://laurent.bellegarde.free.fr/lprod/tutoriels/tutoriel_cinelerra_niv1_debutant.pdf}
@item @b{Capturando e editando video usando Software Livre}, em Português, por Rafael @sc{Diniz}@*
@uref{https://docs.indymedia.org/view/Sysadmin/Cinelerra}
@item @b{Tutorial Cinelerra}, em Português, por Leo @sc{Germani}@*
@uref{http://www.estudiolivre.org/tiki-index.php?page=Cinelerra}
@item @b{Edicion de video bajo GNU/Linux (Cinelerra)}, em espanhol, por Gustavo I@~niguez @sc{Goya}@*
@uref{http://kutxa.homeunix.org/cinelerra}
@end itemize

@c cincvdoc_node_number_10
@node Links diversos
@section Links diversos
@cindex Links diversos

Links diversos:
@itemize @bullet
@item @b{What is Deinterlacing? Facts, solutions, examples}@*
@uref{http://www.100fps.com}
@item @b{MPEG-2 FAQ}@*
@uref{http://bmrc.berkeley.edu/frame/research/mpeg/mpeg2faq.html}
@item @b{"Exporting edited HD content back to the camcorder" (HDV related)}@*
@uref{http://dvinfo.net/conf/showthread.php?t=76674}
@item @b{A Quick Guide to Digital Video Resolution and Aspect Ratio Conversions}@*
@uref{http://lipas.uwasa.fi/~f76998/video/conversion}
@item @b{Colour specification and image coding}@*
@uref{http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html}
@item @b{lprod - Libre Production} um Wiki francês cheio de recursos para edição de vídeo em Open Source, especialmente para o Cinelerra HV (entre eles, um pacote para Ubuntu)@*
@uref{http://fr.lprod.org/wiki/doku.php}
@end itemize

@c cincvdoc_node_number_7
@node Instalação
@chapter Instalação

@cindex Instalação

Todos os pacotes do Cinelerra contêm os seguintes itens:

@itemize @bullet
@item @b{Traduções para outras línguas} - que estão dentro do diretório @file{/usr/share/locale}
@item @b{Executável do Cinelerra} - no diretório @file{/usr/bin}
@item @b{Cinelerra plugins} - no diretório @file{/usr/lib/cinelerra} nos sistemas 32 bits e em @file{/usr/lib64/cinelerra} nos sistemas 64 bits.
@cindex Soundtest
@cindex Tamanho do buffer da placa de som
@item @b{soundtest} - Utilitário para determinar o tamanho do buffer da placa de som.
@cindex mplexlo
@item @b{mplexlo} - Multiplexação de streams MPEG primitivos sem a conformância padrão, no entanto com mais eficiência.
@cindex mpeg3cat
@item @b{mpeg3cat} - Utilitário para ler arquivos MPEG de um determinado padrão e envia-los para uma saída stdout.
@cindex mpeg3toc
@cindex mpeg3dump
@item @b{mpeg3toc, mpeg3cat, mpeg3dump} - Utilitários para indexação e leitura de arquivos MPEG
@cindex mpeg3peek
@item @b{mpeg3peek} - Utilitário para mostrar a compensação de bytes de um frame (quadro) de um arquivo MPEG.
@end itemize

@menu
* Requisitos de hardware::
* Requisitos de software::
* Compilando Cinelerra CV::
* Executando o Cinelerra::
* Live CDs::
* Arch Linux::
* ArkLinux::
* Debian::
* Ubuntu::
* Gentoo::
* Fedora::
* Mandriva::
* Slackware::
* Suse::
* MacOSX::
@end menu

@c cincvdoc_node_number_8
@node Requisitos de hardware
@section Requisitos de hardware
@cindex Requisitos de hardware
@cindex Hardware, requisitos

O Cinelerra não é um programa leve. A demanda de leitura, decodificação e reprodução de vídeo pode sobrecarregar completamente seu sistema. A performance e, conseqüentemente, a usabilidade do cinelerra está diretamente relacionada à velocidade, I/O - portas de entrada e saída, vídeo e à memória do seu hardware e ao tipo de stress a que você pretende submeter o sistema. Para os/as usuários/as que trabalham apenas com áudio ou com formatos leves de vídeo, um computador menos potente pode ser suficiente. No entanto, para alguém que deseja trabalhar com arquivos no formato DV, várias faixas de áudio e um bom conjunto de efeitos e transições é necessário uma melhor configuração de hardware. Como regra geral, é sugerido rodar o Cinelerra em sistemas com, no mínimo, as seguintes especificações:

@itemize @bullet
@item @b{Velocidade da CPU} @*
No mínimo, um processador de 500MHz, menos que isso será inutilizável. Processadores dual-core e SMP aumentam consideravelmente a velocidade do cinelerra.
@item @b{Memória} @*
Ao se trabalhar com vídeo, é aconselhável ter uma grande quantidade de memória disponível para evitar que se utilize a partição swap e para manter os recursos prontamente acessíveis. Para ter uma idéia do que o cinelerra é capaz de fazer, você precisa ter no mínimo 256 Megabytes de memória. Para utilizar o cinelerra em projetos maiores, será necessário dispor de mais memória (> 1 Gb). 
@item @b{Disco rígido} @*
Os requisitos de disco rígido são baseados nas suas necessidades particulares de edição de vídeo. Se você espera produzir vídeos longos em formatos pesados (DV utiliza cerca de 3.5 Mb por segundo, ou 12 Gb por hora), é necessário ter um HD grande (>200 Gb) e rápido. Para projetos menores, é possível fazer até com 1Gb de espaço livre. Edição de vídeo sobrecarrega bastante as portas de entrada e saída (I/O). Para melhores resultados, utilize um disco rígido rápido e configure-o apropriadamente.
@item @b{Placa de vídeo} @*
Desde a versão 2.1, o Cinelerra pode utilizar os benefícios da aceleração de hardware OpenGL. Tenha certeza que sua placa de vídeo suporta OpenGL2.0 para aproveitar esse recurso. Placas Nvidia series 7 (como a 7600GS) são conhecidas por ter um bom desempenho. Se você estiver interessado em enviar a saída de vídeo diretamente para uma TV ou um gravador de vídeo, verifique se a placa de vídeo traz essa possibilidade.
@item @b{Múltiplos monitores} @*
Você pode usar os recursos do XFree86 Xinerama para trabalhar com vários monitores de vídeo. Utilizando dois ou mais monitores, facilita bastante a visualização da linha do tempo e dos vídeos.
@item @b{Saída para TV} @*
Caso sua placa de vídeo tenha a opção de TV-Out (envio de sinal para TV), pode ser útil para visualizar como seu vídeo ficará numa tela de TV.
@item @b{Captura de vídeo} @*
Se você tiver uma câmera de vídeo analógica, ou quiser capturar o vídeo de um videocassete, será necessário utilizar um dispositivo de captura de vídeo. Esses dispositivos são suportados pelo cinelerra através do driver Video4Linux.
@item @b{Firewire} @*
Firewire é a forma mais rápida de transferir vídeo para seu computador. A menos que você transfira material de vídeo para seu computador através de CDs, DVDs ou qualquer outro formato pré-capturado (ou ainda por meio de uma placa de captura analógica), será necessário uma placa firewire no seu computador. 
@item @b{Câmeras digitais} @*
Há uma grande variedade de câmeras digitais que podem ser usadas com o Cinelerra. Praticamente toda câmera que puder ser conectada à porta firewire irá funcionar. O importante é ajustar os parâmetros apropriados no sistema de captura de vídeo para que estes coincidam com os parâmetros da câmera.
@end itemize

@c cincvdoc_node_number_9
@node Requisitos de software
@section Requisitos de software
@cindex Requisitos de software
@cindex Requisitos de software

Para instalar o Cinelerra você precisa ter uma versão atual do Linux com o Sistema de Janelas X (por exemplo, X.org) e com algum software controlador de áudio funcionando corretamente. Você também precisará instalar as seguintes bibliotecas (lista parcial):
@itemize @bullet
@item a52dec
@item dv
@item faac
@item ffmpeg
@item fftw
@item lame
@item libavc1394
@item libfaad2
@item libraw1394
@item mjpegtools
@item OpenEXR
@item theora
@item x264
@end itemize

Você também vai precisar dos cabeçalhos ("headers") para todas as bibliotecas requeridas. Para várias distribuições, isso significa que você precisará instalar os pacotes "-dev" ou "devel" que correspondam aos pacotes de bibliotecas que você possui instalados. Além das bibliotecas listadas aqui, assegure-se de ter os cabeçalhos ("headers") do X. A falta desses cabeçalhos normalmente resultará em uma falha na compilação com mensagens cifradas de erro.

@c cincvdoc_node_number_11
@node Compilando Cinelerra CV
@section Compilando Cinelerra CV
@cindex Compilando Cinelerra CV

@menu
* Processo comum de compilação::
* Compilando com símbolos de depuração::
@end menu

@c cincvdoc_node_number_12
@node Processo comum de compilação
@subsection Processo comum de compilação
@cindex Processo comum de compilação

Você pode instalar Cinelerra CV obtendo o código fonte e compilando-o. Este é o método que você deve utilizar caso deseje compilar a versão mais atual do Cinelerra CV.

O código fonte do Cinelerra-CV está disponível no repositório Subversion (SVN). O Subversion está disponível para download em @uref{http://subversion.tigris.org/}, mas muito provavelmente a sua distribuição possui pacotes pré-compilados. A documentação completa do subversion está disponível em @uref{http://svnbook.red-bean.com/nightly/en/index.html}.

@enumerate 1
@item Primeiro você deve baixar o código fonte do Cinelerra CV no repositório SVN (aproximadamente 170Mb). Execute o comando: @*
@command{svn checkout svn://svn.skolelinux.org/cinelerra/trunk/hvirtual} @*
O comando svn acima criará em sua pasta atual de trabalho um diretório chamado hvirtual que contém os fontes.

@item Entre no diretório hvirtual: @*
@command{cd hvirtual}

@item Crie o arquivo @file{./configure} executando: @*
@command{autoreconf -i --force}

@item Então execute o arquivo @file{.configure}: @*
@command{./configure --with-buildinfo=svn/recompile} @*
Esta opção faz com que o número da revisão seja exibido na aba @b{Sobre} da janela de @b{Preferências}. Você pode dar uma olhada nas outras opções disponíveis executando o comando:@*
@command{./configure --help}@*
A maioria das dependências que estiverem faltando devem ser listadas após a execução deste comando.

@item Agora execute o make: @*
@command{make}
Se você quer gerar um registro para o resultado do make para buscar erros, este comando pode ser usado:@*
@command{make 2>&1 | tee logfile}

@item Finalmente, instale o Cinelerra CV: @*
@command{sudo make install}
@end enumerate

@b{Notas:}
@itemize @bullet
@item @b{SMP machine:} @*
Se você for compilar o Cinelerra CV numa máquina com multiprocessador (SMP), nós recomendamos a adição da opção @option{-j 3} ao make para aproveitar melhor os recursos desses processadores.
@item @b{Somente para processadores x86}: @*
Você provavelmente desejará habilitar o suporte a MMX. Para fazer isto, adicione a opção @option{--enable-mmx} ao @command{./configure}. Se você fizer isto, deverá usar também a opção @option{--without-pic}, caso contrário, a compilação pode falhar. @*
@item @b{Para Pentium-M:} @*
Aqui estão algumas flags utéis ao compilador. @*
@command{./configure --prefix=/usr --enable-x86 --enable-mmx --enable-freetype2 --with-buildinfo=svn/recompile CFLAGS='-O3 -pipe -fomit-frame-pointer -funroll-all-loops -falign-loops=2 -falign-jumps=2 -falign-functions=2 -ffast-math -march=pentium-m -mfpmath=sse,387 -mmmx -msse'}
@item @b{Para 64bits:}@*
Como root, execute:@*
@command{./autogen.sh}@*
@command{./configure}@*
Substitua a opção @option{-prefer-non-pic} pela opção @option{-fPIC \} em seu arquivo @*
@file{quicktime/ffmpeg/libavcodec/i386/Makefile.am}.@*
@command{make}@* 
@command{make install}@*
@item @b{Atualizando o código fonte:}@*
Se você já baixou o código fonte de uma revisão desatualizada, você pode atualizá-lo para a mais recente usando o comando:@*
@command{svn update}@*
@item @b{Instalando revisões antigas:}@*
Se você quer instalar uma revisão antiga, execute o comando:@*
@command{svn checkout -r <revisão> svn://svn.skolelinux.org/cinelerra/trunk/hvirtual}
@item @b{Instalando várias versões:} @*
Se você deseja instalar mais de uma versão do Cinelerra CV no seu computador, crie um diretório @file{/usr/local_cinelerra}, e utilize as seguintes opções no @command{./configure} (substitua @option{xxx} pelo número da versão que você quer compilar): @*
@option{--prefix=/usr/local_cinelerra/rxxx --exec-prefix=/usr/local_cinelerra/rxxx --program-suffix=_rxxx} @*
Você terá de executar o Cinelerra CV do lugar onde ele está instalado em seu computador: @*
@command{cd /usr/local_cinelerra/rxxx} @*
@command{./cinelerra_rxxx}
Se você instalar o Cinelerra utilizando este método, os arquivos de tradução @file{.po} não serão instalados corretamente. Se você quer rodar o Cinelerra em outra língua, veja @xref{Variáveis de ambiente}, para instruções específicas.
@item @b{Versão do Automake:} @*
Você precisará da versão 1.7 do automake. A versão 1.4 não funcionará. Autoconf 2.57 também é exigido.
@end itemize

@c cincvdoc_node_number_13
@node Compilando com símbolos de depuração
@subsection Compilando com símbolos de depuração
@cindex Compilando com símbolos de depuração

Quando o Cinelerra CV trava, você pode compilar com símbolos de depuração e executá-lo dentro do gdb. A informação exibida pelo gdb é muito mais detalhada e, dessa maneira, os desenvolvedores terão informações mais úteis para a corrigir os erros ("bugs").

Primeiro, baixe as fontes do SVN da mesma forma que foi descrito anteriormente. Depois, execute os seguintes comandos: @*
@command{cd hvirtual} @*
@command{nice -19 autoreconf -i --force} @*
@command{mkdir ../hvdbg} @*
@command{cd ../hvdbg} @*
@command{nice -19 ../hvirtual/configure CXXFLAGS='-O0 -g' CFLAGS='-O0 -g' --with-buildinfo=svn/recompile} @*
@command{cd quicktime/ffmpeg} @*
@command{nice -19 make CFLAGS='-O3'} @*
@command{cd ../..} @*
@command{nice -19 make} @*
@command{nice -19 make install}

@xref{Reportando erros}, para informação a respeito da execução do Cinelerra dentro do gdb.

@c cincvdoc_node_number_14
@node Executando o Cinelerra
@section  Executando o Cinelerra
@cindex Cinelerra, executando

A maneira mais simples de executar o cinelerra é através do comando @command{/usr/bin/cinelerra} @*
Esse comando esconde uma interface em linha de comando com muito mais recursos. Execute @command{cinelerra -h} para ver uma lista de opções para linha de comando. A utilidade dessas opções é descrito em várias seções. Para renderização através da linha de comando veja @xref{Renderizando arquivos}.

Se esta mensagem aparecer quando você estiver rodando o Cinelerra pela primeira vez:
@verbatim
WARNING:/proc/sys/kernel/shmmax is 0x2000000, which is too low
@end verbatim
veja @xref{Liberando mais memória compartilhada}, para detalhes.

@c cincvdoc_node_number_19
@node Live CDs
@section Live CDs
@cindex Live CDs

Pode-se tentar usar o Cinelerra em um computador sem que seja preciso instalá-lo no disco rígido. Isso é possível pelo uso de Live CDs, que estão em distribuições GNU/Linux que dão boot pelo CD, sem instalação no disco rígido. Aqui estão alguns dos Live CDs que conhecidamente contém o Cinelerra:

@itemize @bullet
@item @b{Knoppix} - a LiveDistro baseada em Debian "original" - @uref{http://www.knoppix.org}
@item @b{dyne:bolic} - para produção multimídia - usa o gerenciador de janelas Window Maker - @uref{http://www.dynebolic.org}
@item @b{Elive} - Live CD baseado em Debian que usa o gerenciador de janelas Enlightenment - @uref{http://www.elivecd.org}
@item @b{x-evian} - Live CD baseado em Debian para criações multimídia - @uref{http://x-evian.org}
@item @b{Mediainlinux} - baseado no Knoppix - @uref{http://www.mediainlinux.org/}
@item @b{pho} (garbure) - dedicado à edição de vídeo - @uref{http://garbure.org/pho/}   
@item @b{Slo-Tech} - baseado em Debian e Morphix - @uref{http://linux.slo-tech.com}
@end itemize

@c cincvdoc_node_number_357
@node Arch Linux
@section Arch Linux
@cindex Arch Linux

O Cinelerra CV está incluso no repositório da comunidade Arch Linux. @*
Para instalar o pacote cinelerra, você deve habilitar o repositório da comunidade (veja @uref{http://wiki.archlinux.org/index.php/AUR_User_Guidelines} para mais informações).@*
Após habilitar o repositório da comunidade, use o seguinte comando a partir de um terminal:@*
@command{pacman -Sy cinelerra-cv}

@c cincvdoc_node_number_89
@node ArkLinux
@section ArkLinux
@cindex ArkLinux

O Cinelerra CV está incluso no repositório de pacotes ArkLinux. @*
Para instalar o pacote @b{cinelerra}, use a ferramenta @b{Install Software} em Mission Control ou rode os seguintes comandos a partir de uma linha de comando:@*
@command{apt-get update}@*
@command{apt-get install cinelerra}. 

@c cincvdoc_node_number_15
@node Debian
@section Debian
@cindex Debian

@menu
* Pacotes binários para Debian::
* Pré-requisitos para Debian::
@end menu

@c cincvdoc_node_number_16
@node Pacotes binários para Debian
@subsection Pacotes binários para Debian
@cindex Pacotes binários para Debian
@cindex Binários, Debian

Andraz @sc{Tori} mantém instruções de empacotamento para Debian Sid. Ele também faz pacotes binários .deb para Sid. Estes são empacotados a partir de releases não-oficiais do SVN. Pacotes para Debian Sid podem ser encontrados aqui:
@itemize @bullet
@item @b{Repositório do Apt para i386:} @*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/sid/ ./}}
@item @b{Repositório do Apt para Pentium4 (otimizado):} @*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/pentium4/ ./}}
@item @b{Repositório do Apt para Pentium-M (otimizado):} @*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/pentiumm/ ./}}
@item @b{Repositório do Apt para AthlonXP (otimizado):} @*
@command{@w{deb http://www.kiberpipa.org/~minmax/cinelerra/builds/athlonxp/ ./}}
@end itemize

Valentina @sc{Messeri} também construiu o
@itemize @bullet
@item @b{Repositório do Apt para Opteron (AMD64) (otimizado):} @*
@command{@w{deb http://giss.tv/~vale/debian64/ ./}}
@end itemize

@b{Nota:} Se o Cinelerra apresentar o seguinte erro: @*
@command{cinelerra: relocation error: /usr/lib/libavcodec.so.0.4.8:
undefined symbol: faacDecOpen} @*
Você pode resolver o problema com o seguinte comando (como root): @*
@command{apt-get install --reinstall libfaad2-0=2.0.0-0.5}

@c cincvdoc_node_number_17
@node Pré-requisitos para Debian 
@subsection Pré-requisitos para Debian
@cindex Pré-requisitos para Debian
@cindex Pré-requisitos, Debian

Você precisará de algumas dependências que não são encontradas nos repositórios oficiais da Debian. Adicione ao @file{/etc/apt/sources.list} a seguinte linha do repositório de Christian Marillat: @*
@command{deb http://www.debian-multimedia.org/ sid main}

Para usar este repositório, é necessário adicionar ao seu gerenciador de chaves gpg a chave gpg do Marillat: @*
@command{gpg --keyserver hkp://wwwkeys.eu.pgp.net --recv-keys 1F41B907} @*
@command{gpg --armor --export 1F41B907 | sudo apt-key add -} @*
Se você não usa sudo, use o seguinte comando como root: @*
@command{gpg --armor --export 1F41B907 | apt-key add -}

@c cincvdoc_node_number_325
@node Ubuntu
@section Ubuntu
@cindex Ubuntu

@menu
* Repositórios de pacotes Ubuntu::
* Instruções para a instalação de pacotes no Ubuntu::
@end menu

@c cincvdoc_node_number_354
@node Repositórios de pacotes Ubuntu
@subsection Repositórios de pacotes Ubuntu
@cindex Repositórios de pacotes Ubuntu

@b{Para Ubuntu 7.04 Feisty Fawn:}

@itemize @bullet
@item para i386, por muzzol:
@verbatim
deb http://www.kiberpipa.org/~muzzol/cinelerra/feisty-i386/ ./
@end verbatim

@item otimizado para UbuntuStudio, com OpenGL, por Valentina @sc{Messeri}:
@verbatim
deb http://giss.tv/~vale/ubuntuopengl/ ./
@end verbatim

@item para AMD64, por Valentina @sc{Messeri}:
@verbatim
deb http://giss.tv/~vale/ubuntu64 ./
@end verbatim

@item para i686, por Jure @sc{Cuhalev}:
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/feisty/cinelerra/i686/ ./
@end verbatim

@item para athlonxp, por Jure @sc{Cuhalev}:
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/feisty/cinelerra/athlonxp/ ./
@end verbatim

@item para pentium4, por Jure @sc{Cuhalev}:
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/feisty/cinelerra/pentium4/ ./
@end verbatim
@end itemize

@b{Para Ubuntu 6.10 Edgy Eft:}

@itemize @bullet
@item por muzzol
@verbatim
deb http://www.kiberpipa.org/~muzzol/cinelerra/edgy-i386/ ./
@end verbatim

@item por Valentina @sc{Messeri}:
@verbatim
deb http://giss.tv/~vale/ubuntu32 ./
@end verbatim
@end itemize

@b{For Ubuntu 6.06 Dapper Drake}

@itemize @bullet
@item Backport mjpegtools do ubuntu necessário, por Jure @sc{Cuhalev}:
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/dapper/mjpegtools ./
@end verbatim

@item para pentium4, por Jure @sc{Cuhalev}::
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/dapper/cinelerra/pentium4/ ./
@end verbatim

@item para i686, por Jure @sc{Cuhalev}::
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/dapper/cinelerra/i686/ ./
@end verbatim

@item para athlonxp, por Jure @sc{Cuhalev}::
@verbatim
deb http://www.kiberpipa.org/~gandalf/ubuntu/dapper/cinelerra/athlonxp/ ./
@end verbatim
@end itemize

@c cincvdoc_node_number_355
@node Instruções para a instalação de pacotes no Ubuntu
@subsection Instruções para a instalação de pacotes no Ubuntu
@cindex Instalação de pacotes no Ubuntu

Escolha um dos repositórios acima de acordo com o tipo de sua CPU e instale o pacote.@*
Aqui estão 3 formas de se fazer isso:

@b{Com o gerenciador de pacotes Synaptic:}

Abra a janela de repositórios do programa. @*
Você pode fazer isso de duas formas: @*
- Vá para Sistema -> Administração -> Gerenciador de pacotes synaptic@*
- Dentro do programa: vá para Configurações -> Repositórios. @*
Assegure-se de habilitar as fontes universe, multiverse e restricted na primeira aba.@*
Clique em Repositórios de Terceiros ("Third Party"). Clique no botão Adicionar e informe seu repositório escolhido (dos mencionados acima). @*
Clicar em Adicionar Fonte exibirá o novo repositório habilitado na janela de recursos do programa. @*
Você deve agora ser capaz de encontrar o Cinelerra na sua lista de pacotes disponíveis no Synaptic. @*
Siga as instruções do Synaptic para a instalação.@*

@b{Pela linha de comando:}

Edite diretamente o seu arquivo @file{/etc/apt/sources.list}.@*
Assegure-se de estar com os repositórios universe, multiverse e restricted habilitados checando se a seguinte linha está descomentada (se não há um "#" na frente dela): @*
@verbatim
deb http://archive.ubuntu.com/ubuntu dapper universe multiverse restricted
@end verbatim
Adicione a linha completa do APT de seu repositório escolhido (a partir da lista acima).@*
Instale o Cinelerra digitando em seu terminal:
@verbatim
apt-get update
@end verbatim
e então
@verbatim
apt-get install cinelerra
@end verbatim

@b{Com o instalador de pacotes GDebi:}

Mande o Firefox para o endereço de rede do repositório @*
(por exemplo http://www.kiberpipa.org/~muzzol/cinelerra/edgy-i386/.)@*
Clique no link .deb de seu pacote Cinelerra escolhido @*
(por exemplo cinelerra_2.1.0+svn20070109-0ubuntu1_i386.deb)@*
Uma janela de diálogo pedirá a confirmação de sua intenção para abrir este arquivo com o instalador de pacotes GDebi. @*
Clicar em OK iniciará o download.@*
Se durante o processo você obter erros sobre dependências não satisfeitas, tente instalar as bibliotecas problemáticas pelo mesmo método a partir da mesma página.

@b{HOWTOs para a instalação de pacotes ou compilação a partir do código fonte}@*

@itemize @bullet
@item Instalação do pacote Cinelerra no Ubunty Feisty AMD64:@*
@uref{https://help.ubuntu.com/community/CinelerraOnFeistyAMD64}

@item Compilação a partir do código fonte no Ubuntu 6.10 Edgy Eft:@*
@uref{http://www.ubuntuforums.org/showthread.php?t=320701&highlight=cinelerra}

@item Compilação a partir do código fonte no Ubuntu Breezy:@*
@uref{http://placide.home.sapo.pt/cinelerra02.html}

@item Compilação a partir do código fonte no Ubuntu Dapper Drake (para iniciantes, em italiano):@*
@uref{https://faberlibertatis.org/wiki/Cinelerra_CV_su_Ubuntu}
@end itemize

@c cincvdoc_node_number_18
@node Gentoo
@section Gentoo
@cindex Gentoo

A instalação no Gentoo Linux é bastante simples. Simplesmente digite: @*
@command{emerge cinelerra} @*
como root e o Cinelerra será instalado e irá rodar sem problemas. Note que você pode precisar colocar o cinelerra em seu arquivo @file{/etc/portage/package.keywords} para poder usá-lo:
@verbatim
echo "=media-video/cinelerra-cvs-20061020" >> /etc/portage/package.keywords
@end verbatim

Veja @uref{http://www.gentoo.org/doc/en/handbook/handbook-x86.xml?part=3&chap=3} para detalhes. 

@b{Observação:} O ebuild do Gentoo media-video/cinelerra-cvs-20061020 não possui ícones de modos de edição. Veja @xref{Modos de edição}, para mais informações.

@c cincvdoc_node_number_326
@node Fedora
@section Fedora
@cindex Fedora

O Cinelerra está incluso no repositório Freshrpms em @uref{http://freshrpms.net}. O jeito mais fácil de instalar pacotes do Freshrpms é incluir o repositório na configuração do @b{yum}. Também assegure-se que o repositório Fedora Extras esteja habilitado. Este é o caso por padrão no Fedora 5 e 6, e Core e Extras são unidos em um no Fedora 7.

No Fedora 6, como usuário root, rode:
@verbatim
rpm -ivh http://ftp.freshrpms.net/pub/freshrpms/fedora/linux/6/\ freshrpms-release/freshrpms-release-1.1-1.fc.noarch.rpm
@end verbatim

No Fedora 5, faça:
@verbatim
rpm -ivh http://ftp.freshrpms.net/pub/freshrpms/fedora/linux/5/\ freshrpms-release/freshrpms-release-1.1-1.fc.noarch.rpm
@end verbatim

Então digite:
@verbatim
yum -y install cinelerra
@end verbatim
para obter e instalar o Cinelerra e todas as suas dependências, incluindo o ffmpeg e o mjpegtools. Caso isso não funcione, cheque o arquivo @file{/etc/yum.conf} e assegure-se que a configuração do Freshrpms seja inclusa no arquivo @file{/etc/yum.repos.d}.

@b{Observações:}
@itemize @bullet
@item A coleção de pacotes do Freshrpms pode conflitar ou sobrepor outros repositórios de terceiros como o  Livna, que também pode carregar as bibliotecas de áudio e vídeo e o Cinelerra. Também pode ser uma boa idéia manter-se fiel a um repositório e não misturar pacotes de vários repositórios de terceiros.
@item O arquivos de cabeçalho de várias bibliotecas são necessários para a compilação do Cinelerra a partir do código-fonte. Os arquivos de cabeçalho estão inclusos em vários pacotes devel separados que estão inclusos nos repositórios Fedora e Freshrpms e podem ser instalados com o yum. Pelo menos os seguintes são necessários:@*
OpenEXR-devel SDL-devel a52dec-devel alsa-lib-devel e2fsprogs-devel faac-devel faad2-devel ffmpeg-devel fftw-devel imlib2-devel lame-devel libXv-devel libXxf86vm-devel libavc1394-devel libdv-devel libiec61883-devel libogg-devel libraw1394-devel libsndfile-devel libtheora-devel libvorbis-devel mjpegtools-devel x264-devel xvidcore-devel
@item Se você quer compilar o Cinelerra a partir do código fonte no Fedora Core 6, detailed instruções detalhadas sobre como instalar os arquivos de dependência necessários pode ser encontrados em: @uref{http://crazedmuleproductions.blogspot.com/2007/03/fedora-core-6-cinelerra-dependencies.html}@*
@end itemize

@c cincvdoc_node_number_20
@node Mandriva
@section Mandriva
@cindex Mandriva

Pacotes do Cinelerra para Mandriva são feitos por PLF e estão prontos para serem instalados. Leia @uref{http://plf.zarb.org/packages.php} para mais informação.

@c cincvdoc_node_number_21
@node Slackware
@section Slackware
@cindex Slackware

Rafael @sc{Diniz} mantém pacotes do Cinelerra para Slackware.

@itemize @bullet
@item @b{For x86:} @*
@uref{http://slack.sarava.org/packages/slackware/slackware-11.0/multimedia/}
@item @b{For slackintosh:} @*
@uref{http://slack.sarava.org/packages/slackintosh/slackintosh-11.0/multimedia/}
@end itemize

@c cincvdoc_node_number_22
@node Suse
@section Suse
@cindex Suse

RPMs para SuSE 9 são construídos de fontes SVN por Kevin @sc{Brosius}, e disponíveis em @uref{http://cin.kevb.net/files/RPM/}

RPMs para OpenSUSE 10.1 e 10.2, arquiteturas i586 e x86_64, são construídos a partir do SVN por Leon @sc{Freitag} em Packman. Eles estão disponíveis em @uref{http://packman.links2linux.org/package/cinelerra/16413}.

Os pacotes RPM podem ser instalados como root em um terminal usando este comando:
@verbatim
rpm -Uvh package_name.rpm
@end verbatim

O caso seguinte de instalação mostra quatro capturas de tela para uma instalação baseada no GUI do Cinelerra SVN no OpenSUSE 10.2 i586 usando YaST2. Primeiro adicionando o repositório do packman YaST2 como uma fonte de instalação YaST2, e depois a instalação do pacote com o YaST2 Software Manager. 

Inicie o centro de controle do YaST no OpenSUSE 10.2 e adicione a senha de root quando pedido:

@center @image{manual_images_intl/yast2_control_center,100mm}

Inicie a ferramenta de instalação YaST2, selecione o protocolo HTTP e adicione o servername para packman conforme mostrado. A sincronia com o Zenworks pode levar algum tempo, espere até que esteja terminada.

@center @image{manual_images_intl/yast2_installation_source,120mm}

Inicie o YaST2 Software Management. Enter "Cinelerra" no campo de busca à esquerda e habilite as caixas para os pacotes do Cinelerra na janela da direita. Se uma versão mais antiga do Cinelerra for instalada e fique visível com um símbolo de trava, apague-a. Possivelmente, tente fazer uma atualização antes.

@center @image{manual_images_intl/yast2_cinelerra_installation,120mm}
Clique em Accept para começar a instalação do pacote e depois em Next para terminá-la.

@center @image{manual_images_intl/yast2_package_installation,120mm}

@c cincvdoc_node_number_23
@node MacOSX
@section MacOSX
@cindex MacOSX

conserte-me

@c cincvdoc_node_number_24
@node Configuração
@chapter Configuração
@cindex Configuração

Devido à sua variedade de usos, o Cinelerra não pode ser usado de uma forma ótima sem que haja uma configuração precisa, voltada para suas necessidades específicas. Muito poucos parâmetros são ajustáveis à hora da compilação. A configuração na hora de rodar o programa ("runtime") é a única opção para a maioria das configurações, devido à multitude de parâmetros. @*
Aqui nós discutimos não apenas as opções de configuração, mas quais das diferentes APIs são suportadas em GNU/Linux. @*
Vá para @b{configurações->preferências} para ver mais opções.

@menu
* Variáveis de ambiente::  Estas variáveis de ambiente são reconhecidas pelo Cinelerra
* Drivers de Áudio::       Informação sobre os drivers de áudio
* Drivers de Vídeo::       Informação sobre os drivers de vídeo
* Reprodução::		   Configurando parâmetros relacionados à reprodução.
* Gravação::               Configurando parâmetros relacionados à gravação.
* Performance::            Configurando parâmetros relacionados a quão rápidas vão as coisas.
* Interface::              Configurando a interface de usuário.
* Sobre::                  Vendo informações sobre o programa.
@end menu

@c cincvdoc_node_number_25
@node Variáveis de ambiente
@section Variáveis de ambiente
@cindex Variáveis de ambiente
@cindex Ladspa, caminho

Nos derivativos de UNIX, variáveis de ambiente são variáveis globais no terminal ("shell") que todas as aplicações são capazes de ler. Elas são configuradas com um comando como @command{set VARIABLE=value}. Todas as variáveis de ambiente podem ser vistas com um comando tipo @command{env}. O Cinelerra reconhece as seguintes variáveis de ambiente:

@itemize @bullet
@item @b{LADSPA_PATH} @*
Se você quer usar plugins LADSPA, isto deve ser definido: uma lista separada por vírgula de diretórios onde serão buscados os plugins LADSPA. Estes não são plugins nativos do Cinelerra.  @xref{Efeitos ladspa}.

@item @b{GLOBAL_PLUGIN_DIR} @*
O diretório onde o Cinelerra deve procurar por plugins nativos. O padrão é @file{/usr/lib/cinelerra}, mas você pode precisar de um diretório alternativo se você compartilha o mesmo diretório executável entre várias máquinas via NFS@. Plugins de diferentes formatos binários precisam estar em diretórios diferentes.

@item @b{LANG e LANGUAGE} @*
O Cinelerra está traduzido em várias línguas. As configurações de língua do Cinelerra normalmente são lidas a partir de suas configurações de língua no Linux. Para rodar o Cinelerra em uma língua diferente da selecionada em seu sistema, mude as variáveis de ambiente LANG e LANGUAGE. @*
Por exemplo, abra um terminal e digite: @command{export LANG=es_ES LANGUAGE=es_ES}, e depois rode o Cinelerra a partir do mesmo terminal. Ele abrirá com os textos dispostos em espanhol. @*
Línguas disponíveis são:
@itemize @bullet
@item en_EN - English
@item es_ES - Espanhol
@item sl_SI - Esloveno
@item fr_FR - Francês
@item eu_ES - Euskera (Basco)
@item de_DE - Alemão
@item pt_BR - Português do Brazil
@item it_IT - Italiano
@end itemize
Em alguns casos (por exemplo, se você compilou o Cinelerra especificando uma opção @option{--prefix=} diferente do arquivo @file{/usr/local}), os arquivos .po traduzidos não são instalados. Se você não consegue rodar o Cinelerra em sua língua escolhida, tente rodar os seguintes comandos antes de mudar as variáveis de ambiente LANG e LANGUAGE:@*
@command{cd hvirtual}@*
@command{./configure prefix=/usr}@*
@command{cd po}@*
@command{sudo make install}@*
@end itemize

@c cincvdoc_node_number_26
@node Drivers de Áudio
@section Drivers de Áudio
@cindex Drivers de Áudio

Os drivers de áudio são usados tanto para gravação quanto para reprodução para gerar dados para o e a partir do hardware. Uma vez que os mesmos drivers são usados tanto para gravação quanto para reprodução, sua funcionalidade está descrita aqui em uma seção separada.

@menu
* Atributos do Driver de Som::
* OSS:: Notas sobre o driver OSS
* OSS Envy24:: Notas sobre o driver OSS do chip Envy24
* Alsa:: Notas sobre o driver ALSA
* Esound:: Notas sobre o driver ESound
* Raw 1394:: Notas sobre o driver Raw1394
* DV 1394:: Notas sobre o driver DV1394
* IEC 61883:: Notas sobre o driver IEC 61883
@end menu

@c cincvdoc_node_number_27
@node Atributos do Driver de Som
@subsection Atributos do Driver de Som
@cindex Atributos do Driver de Som

@itemize @bullet
@item @b{Caminho do dispositivo}  @*
Normalmente um arquivo no diretório @file{/dev/} que controla o dispositivo.

@item @b{Bits} @*
O número de precisão de bits que o Cinelerra deve configurar o dispositivo para usar. Isso às vezes possui um significado figurativo. Alguns drivers de com precisam ser configurados para 32
bits para performar uma reprodução de 24 bits e não tocarão nada quando configurados para 24 bits.
Alguns drivers de som precisam ser configurados para 24 bits para reproduzirem em 24 bits.

@item @b{Porta}@*
O padrão IEEE1394 especifica algo conhecido como @b{porta}. Isso provavelmente será o número de sua placa firewire.

@item @b{Canal}@*
O padrão IEEE1394 especifica algo conhecido como canal. Para câmeras DV ele sempre será 63. 

@item @b{Dispositivo}@*
O dispositivo escolhido.

@item @b{Parar exibição trava}@*
Esta caixa de habilitação esclusiva para ALSA é requerida se, ao se parar a reprodução, o software trava.
@end itemize

@c cincvdoc_node_number_28
@node OSS
@subsection OSS
@cindex OSS

Este foi o primeiro driver de som GNU/Linux. Ele possuía uma implementação open source e uma implementação comercial com mais cartões de áudio suportados. Era o driver padrão de som até o GNU/Linux 2.4. Ainda é o único driver de som que um binário i386 pode usar quando rodando em um sistema x86_64.

@c cincvdoc_node_number_29
@node OSS Envy24
@subsection OSS Envy24
@cindex OSS Envy24
@cindex Envy24

A versão comercial do OSS possuía uma variante para cartões 24 bits / 96 KHz. Esta variante requeria mudanças significativas no modo como os drivers de som eram usados, sendo para isto que o OSS Envy24 foi criado.

@c cincvdoc_node_number_30
@node Alsa
@subsection Alsa
@cindex Alsa

ALSA é o driver de som mais comum no GNU/Linux 2.6. Ele suporta a maioria das placas de som agora. Ele usa as vantagens das características de latência baixa do GNU/Linux 2.6 para obter uma performance melhor do que o OSS possuía no 2.4, mas marginalmente a mesma performance que o OSS tinha no 2.0. Infelizmente, o ALSA está constantemente mudando. Um programa que funcione com ele um dia pode não funcionar no dia seguinte. Novos "wrappers" estão sendo desenvolvidos pelo ALSA no presente momento; planejamos suportá-los em intervalos regulares, não a cada novo lançamento de um novo "wrapper". @*
O ALSA não é mais portável entre i386 e x86_64. Se um binário i386 tenta fazer uma reprodução num kernel x86_64, ele não funciona. Para este cenário, use o OSS@.

@c cincvdoc_node_number_31
@node Esound
@subsection Esound
@cindex Esound

ESOUND era um servidor de som que estava acima do OSS@. Ele era escrito para um gerenciador de janelas chamado Enlightenment, suportando um número limitado de bits e possuía latência alta se comparado aos tempos modernos, mas multiplexava fontes de áudio múltiplas. É desconhecido se este driver ainda funciona.

@c cincvdoc_node_number_32
@node Raw 1394
@subsection Raw 1394
@cindex Raw 1394

Esta era a primeira interface entre softwares GNU/Linux e as câmeras firewire. Era o modo menos confiável de tocar áudio para uma câmera. Consistia numa biblioteca acima dos comandos de kernel.

@c cincvdoc_node_number_33
@node DV 1394
@subsection DV 1394
@cindex DV 1394

A segunda re-escritura do suporte a câmeras DV no GNU/Linux. Este era o modo mais confiável de se tocar áudio para uma câmera, pois consistia em comandos diretos do kernel.

@c cincvdoc_node_number_34
@node IEC 61883
@subsection IEC 61883
@cindex IEC 61883

A terceira re-escritura do suporta a câmeras DV no GNU/Linux. Esta é uma biblioteca acima da RAW 1394, que é uma biblioteca acima dos comandos de kernel. É menos confiável que a DV 1394, mas mais confiável que a RAW 1394. A próxima re-escritura deve corrigir isso.

@c cincvdoc_node_number_35
@node Drivers de Vídeo
@section Drivers de Vídeo
@cindex Drivers de Vídeo

Os drivers de vídeo são usados para reprodução ("playback") de vídeo nas janelas de composição e visualização.

@menu
* Atributos do Driver de Vídeo::
* X11::
* X11-XV::
* X11-OpenGL::
* Buz::
* Reprodução do vídeo por Raw 1394::
* Reprodução do vídeo por DV 1394::
* Reprodução do vídeo por IEC 61883::
@end menu

@c cincvdoc_node_number_36
@node Atributos do Driver de Vídeo
@subsection Atributos do Driver de Vídeo
@cindex Atributos do Driver de Vídeo

@itemize @bullet
@item @b{Exibição} @*
@cindex Sistemas com dois monitores
A interface é voltada para sistemas com dois monitores. Dependendo do valor para "Display", a Janela de Composição aparecerá em um monitor diferente do resto das janelas.

@item @b{Caminho do dispositivo} @*
Normalmente um arquivo no diretório @file{/dev/}, que controla o dispositivo.

@item @b{Trocar campos} @*
Faz das linhas pares ímpares e das linhas ímpares pares mesmo quando enviando ao dispositivo. Em um monitor NTSC ou 1080i, os campos podem precisar ser trocados para que não haja tremor nos movimentos.

@item @b{Canal de saída} @*
Dispositivos com múltiplas saídas podem precisar de um conector específico para enviar o vídeo.

@item @b{Porta} @*
O padrão IEEE1394 especifica algo conhecido como a @b{porta}. Este é provavelmente o número da placa firewire do sistema.

@item @b{Canal} @*
O padrão IEEE1394 especifica algo conhecido como @b{canal}. Para câmeras DV, este valor é sempre @b{63}.
@end itemize

@c cincvdoc_node_number_37
@node X11
@subsection X11
@cindex X11

Este era o primeiro método de reprodução de vídeo em qualquer sistema UNIX, válido até 1999. Ele simplesmente escreve a tríade RGB para cada pixel diretamente na janela. É o método mais lento de reprodução. Ainda é útil como recurso caso o hardware de gráfico não consegue lidar com quadros ("frames") muito largos.

@c cincvdoc_node_number_38
@node X11-XV
@subsection X11-XV
@cindex X11-XV

Este era o segundo grande método de reprodução de vídeo do UNIX, começando em 1999. Ele converte YUV para RGB no hardware por escala ("scaling"). É o método preferível de reprodução, mas não consegue lidar com tamanhos de quadro grandes. O tamanho máximo de vídeo para o XV é normalmente 1920x1080.

@c cincvdoc_node_number_39
@node X11-OpenGL
@subsection X11-OpenGL
@cindex X11-OpenGL
@cindex OpenGL

O método mais poderoso de reprodução de vídeo é o OpenGL@. Com este driver, a maioria dos efeitos é feita no hardware. O OpenGL permite tamanhos de vídeo até o máximo do tamanho de textura, que é normalmente mais largo do que o XV suporta, dependendo do driver de gráfico. Para habilitá-lo, você precisa de um binário construído com suporte a OpenGL. A opção @command{configure} (de configuração) para habilitar o OpenGL é @option{--enable-opengl}. Você precisa de uma placa que suporte OpenGL 2.0. Placas de vídeo nVidia recentes devem funcionar. Você também precisa de um driver de vídeo que suporte OpenGL 2.0, como o driver binário da Nvidia. Para saber se seu driver de vídeo suporta OpenGL 2.0, digite o seguinte comando: @command{glxinfo | grep "OpenGL version"}.

@itemize @bullet
@item Driver de vídeo que suporta renderização de hardware OpenGL 2.0: @*
@command{OpenGL version string: 2.0.2 NVIDIA 87.74}
@item Driver de vídeo que não suporta renderização de hardware OpenGL 2.0: @*
@command{OpenGL version string: @b{1.4} (2.0.2 NVIDIA 87.74)}
@end itemize

O OpenGL utiliza PBuffers e shaders para fazer a renderização de vídeo. A placa de gráfico deve suportar OpenGL 2 e o Cinelerra deve ser necessariamente compilado com suporte a OpenGL 2. Isso requere uma compilação em um sistema com os headers ("cabeçalhos") do OpenGL 2. PBuffers são conhecidos por serem volúveis. Se a placa de gráfico não possui memória suficiente ou não tem os visuais corretos, os PBuffers não funcionarão. Tente buscar vários quadros ("frames") ou reiniciar o Cinelerra se o OpenGL não funcionar.

@b{Limitações:}
@itemize @bullet
@item OpenGL não afeta a renderização. Ele apenas acelera a reprodução ("playback") do vídeo.
@item X11-OpenGL processa tudo em modelos de cor 8 bits, embora a diferença entre YUV e RGB seja mantida.
@item OpenGL não trabalha com quadros de tamanho maior que 4096x4096. @*
Aqui está o que aparece escrito no console quando ele trabalha com quadros largos: @*
@code{BC_Texture::create_texture frame size <frame_width>x<frame_height> bigger
than maximum texture 4096x4096.}
@item A equação de escala configurada na janela de preferências é ignorada pelo OpenGL@.
OpenGL sempre utiliza escalamento linear.
@item Tamanhos de project e trilha devem ser múltiplos de 4 para que o OpenGL funcione.
@item Para obter a aceleração máxima, efeitos de OpenGL-habilitado devem ser colocados após os efeitos que usam somente o software. Toda a renderização feita antes do último efeito apenas-software é feita em software. As operações de núcleo do Cinelerra, como câmera e projetor são obviamente OpenGL@.
@item Nem todos os efeitos suportam aceleração OpenGL. Os seguintes efeitos suportam OpenGL: Brilho ("Brightness"), Chromakey, Chromakeyhsv, Balanceamento de Cor ("Color balance"), Desentrelaçamento ("Deinterlace"), Diffkey, Dissolução ("Dissolve"), Inversão ("Flip"), Quadros para Campos ("Frames to fields"), Congelar quadro ("Freeze frame"), Gama ("Gamma"),
Gradiente ("Gradient"), Histograma ("Histogram"), Hue saturation, Interpolar Pixels ("Interpolate Pixels"), Inverter Vídeo ("Invert video"), Linear blur, Overlay, Perspectiva ("Perspective"), Radial blur, RGB601, Rotacionar ("Rotate"), Scale, Threshold, Zoomblur.
@end itemize

@c cincvdoc_node_number_40
@node Buz
@subsection Buz
@cindex Buz
@cindex Video4Linux

Este é um método para reproduzir arquivos "motion JPEG-A" diretamente para um sinal analógico composite. Ele utiliza um hack popular do driver Video4Linux 1 de 2000 para descomprimir o JPEG em hardware. Infelizmente, ainda que saída analógica seja obsoleta, novos drivers substituíram o BUZ@.

@c cincvdoc_node_number_41
@node Reprodução do vídeo por Raw 1394
@subsection Reprodução do vídeo por Raw 1394
@cindex Raw 1394

Esta era a primeira interface entre softwares GNU/Linux e câmeras firewire. Era a forma menos confiável de enviar vídeo para uma câmera. Consistia em uma biblioteca acima dos comandos de kernel.

@c cincvdoc_node_number_42
@node Reprodução do vídeo por DV 1394
@subsection Reprodução do vídeo por DV 1394
@cindex DV 1394

A segunda re-escritura do suporte a câmeras DV no GNU/Linux. Era a forma mais confiável de reproduzir vídeo em uma câmera. Consistia em comandos diretos do kernel.

@c cincvdoc_node_number_43
@node Reprodução do vídeo por IEC 61883
@subsection Reprodução do vídeo por IEC 61883
@cindex IEC 61883

A terceira re-escritura do suporte a câmeras DV no GNU/Linux. Esta é uma biblioteca acima do RAW 1394, que é uma biblioteca acima dos comandos de kernel. É menos confiável que o DV 1394, mas mais confiável que o RAW 1394. A próxima re-escritura deve consertar isso.

@c cincvdoc_node_number_44
@node Reprodução 
@section Reprodução
@cindex Reprodução

@menu
* Saída de Áudio::
* Saída de Vídeo::
@end menu

@c cincvdoc_node_number_45
@node Saída de Áudio
@subsection Saída de Áudio
@cindex Saída de Áudio
@cindex Amostragem de áudio

Determinam o que acontece quando você reproduz som a partir da Linha do Tempo.

@cindex Tamanho do buffer de reprodução
@cindex Console, amostras a serem enviadas
@itemize @bullet
@item @b{Tamanho do buffer de reprodução} @*
Para reproduzir áudio, pequenos fragmentos de som são lidos no disco e processados em um console virtual seqüencialmente. Um valor mais alto aqui causa uma latência maior quando você muda os parâmetros de mixagem, mas resulta em uma reprodução mais confiável. @*
Algumas placas de áudio não permitem modificar a mudança do fragmento de console. Assim, a latência permanece sem modificações, não importa qual seja este valor. @*
Anteriormente, uma boa forma de assegurar uma reprodução de alta qualidade era ler fragmentos maiores a partir do disco e quebrá-los em fragmentos menores para a placa de som. Isso mudou quando o console virtual mudou do modelo de empurrar ("push model") para o modelo de puxar ("pull model"). Uma vez que diferentes estágios do pipeline de renderização podem mudar a taxa da informação que chega, seria agora muito difícil desconectar pedaços dos fragmentos do console dos pedaços dos fragmentos lidos do disco.

@cindex Deslocamento de áudio
@item @b{Deslocamento de áudio} @*
A habilidade de informar a posição exata de reprodução nos drivers de áudio GNU/Linux é bastante ruim, se é que é disponível. Uma vez que esta informação é requerida para uma sincronia decente de vídeo, ela precisa ser acurada. O parâmetro @b{Deslocamento de áudio} permite aos usuários ajustar a posição que retorna do driver de áudio para refletir a realidade. O deslocamento de áudio ("audio offset") não afeta a reprodução de áudio ou a renderização. Ele simplesmente muda a sincronia da reprodução de vídeo. @*
O jeito mais fácil de configurar o deslocamento de áudio é criar uma Linha do Tempo com 1 trilha de vídeo e 1 trilha de áudio. Expanda a tilha de áudio e centre o pan de áudio. A taxa de quadros ("frame rate") deve ser algo acima de 24 fps e a taxa de amostragem deve ser acima de 32000. O tamanho do quadro deve ser pequeno o suficiente para que seu computador o renderize à taxa de quadros inteira. Selecione uma região da Linha do Tempo começando aos 10 segundos e terminando aos 20 segundos. Coloque um efeito de @b{gradiente} na trilha de vídeo e configure-o para estar claramente visível. Coloque um efeito de @b{sintetizador} no áudio e configure-o para estar claramente audível. @*
Toque a Linha do Tempo a partir do 0 e observe para ver se o efeito de gradiente começa exatamente quando o áudio começa. Se não, expanda a trilha de áudio e ajuste o deslocamento ("nudge"). Se o áudio começar antes do vídeo, diminua o valor do deslocamento. Se o áudio começar após o vídeo, aumente o valor do deslocamento. Uma vez que a reprodução das trilhas toque sincronizada, copie o valor do deslocamento ("nudge") para o valor de @b{Deslocamento de áudio} nas preferências. @*
@b{Observação:} se você mudar os drivers de áudio ou se você mudar o valor de @b{Usar software para posicionar informação}, você deverá mudar o deslocamento de áudio porque os drivers de áudio são inequalmente inacurados.

@cindex Visão segue a reprodução
@item @b{Visão segue a reprodução} @*
Isso faz com que a janela da Linha do Tempo ande quando o cursor de reprodução se movimenta. Isso pode travar o servidor X ou fazer a janela da Linha do Tempo ficar presa por longos períodos de tempo conforme se desenham os blocos de vídeo("assets").

@cindex Usar software para posicionar informação
@item @b{Usar software para posicionar informação} @*
A maioria das placas de som e drivers de som não dão uma informação confiável sobre o número de amostras que a placa acabou de reproduzir. Quando se está reproduzindo vídeo, você precisa desta informação para a sincronização. Esta opção faz com que o driver de som seja ignorado e um software marcador de tempo seja usado para a sincronização.

@cindex Reprodução de áudio em tempo real
@item @b{Reprodução de áudio em tempo real} @*
De volta aos tempos em que 150 MHz era o máximo, isso permitia reprodução ininterrupta de cargas pesadas. Esta opção força a reprodução de áudio para a prioridade máxima do kernel. Hoje, isso é mais útil para atingir latências muito baixas entre as movimentações no console e a saída da placa de áudio. Você dever ser super-usuário ("root") para obter prioridade de tempo real.

@cindex Driver de áudio
@item @b{Driver de áudio} @*
Existem vários drivers de áudio para GNU/Linux. Esta opção permite selecionar um driver de áudio e configurar parâmetros específicos para ela. Os drivers de som e seus parâmetros estão descritos na seção de drivers de som. @xref{Drivers de Áudio}.
@end itemize

@c cincvdoc_node_number_46
@node Saída de Vídeo
@subsection Saída de Vídeo
@cindex Saída de Vídeo

Determina como o vídeo sai da Linha do Tempo e chega a seus olhos.

@cindex Reproduzir todos os quadros
@cindex Quadros, reproduzir todos
@itemize @bullet
@item @b{Reproduzir todos os quadros} @*
Faz com que todos os quadros do vídeo sejam reproduzidos, mesmo que isso signifique que eles fiquem para trás da reprodução do áudio. Esta opção deve estar sempre habilitada, a não ser que você use codecs sem compressão em sua maioria. A maioria dos codecs comprimidos não suportam mais que quadros sejam pulados ("frame dropping").

@cindex Taxa de quadros alcançada
@item @b{Taxa de quadros alcançada} @*
O número de quadros por segundo sendo exibidos durante a reprodução. Este número só é atualizado durante a exibição.

@cindex Decodificar quadros de forma assíncrona
@item @b{Decodificar quadros de forma assíncrona} @*
Se você possui bastante memória e mais de uma CPU, esta opção pode melhorar a performance de reprodução decodificando o vídeo em uma CPU o mais rápido possível enquanto dedica a outra CPU apenas para reproduzir vídeo. Ela assume que todas as operações de reprodução estejam à frente ("forward") e que nenhum quadro seja saltado ("dropped"). Operações envolvendo reprodução reversa ("reverse playback") ou salto de quadros são impactadas negativamente. @*
Uma vez que esta opção requere enormes quantidades de memória, ela pode dar pau caso os quadros de entrada sejam muito grandes.

@cindex Equação de escala
@item @b{Equação de escala} @*
Quando a reprodução do vídeo envolve qualquer tipo de escalamento ou translação, este algoritmo é utilizado. Ele não afeta reprodução 1:1.
@itemize @bullet
@item @b{Vizinho mais próximo aumento e redução} @*
qualidade pior, mas mais rápido. Produz bordas desiguais e movimentação desigual.
@item @b{Aumento bicúbico e redução bilinear} @*
qualidade mais alta, mas mais lento. Para aumento, interpolação bicúbica é utilizada, o que desfoca um pouco mas não revela passos de escada. Para redução, uma interpolação bilinear é usada, o que produz imagens bastante acuradas e reduz o ruído. As imagens bilineares reduzidas podem ser aguçadas ("sharpened") com um efeito de aguçar ("sharpen") com menos ruído do que uma imagem em tamanho normal.
@item @b{Aumento bilinear e redução bilinear} @*
Quando se precisa fazer um aumento leve, um aumento bilinear fica melhor do que um aumento bicúbico.
@end itemize

@cindex Pré-carregar buffer para Quicktime
@cindex Quicktime, pré-carregar buffer para
@item @b{Pré-carregar buffer para Quicktime} @*
O decodificador Quicktime/AVI consegue lidar com fontes DVD melhor quando está por volta de 10000000. Isso reduz a quantidade de busca ("seeking") requerida. Infelizmente, quando se lê fontes com taxas de bits altas a partir de um disco rígido, esta opção tende a deixar o processo mais lento. Para uso normal, ela deve estar em 0.

@cindex DVD, legenda
@item @b{Legenda do DVD a ser exibida} @*
Arquivos DVD IFO normalmente contém trilhas de legendas. Estas devem ser decodificadas pelo decodificador MPEG. Selecione @b{Habilitar legendas} para habilitar a decodificação de legendas. Normalmente, há várias trilhas de legendas, começando do 0. A trilha de legenda a ser decodificada para todas as faixas de MPEG vai na legenda do DVD para reproduzir uma caixa de texto. Vá para o bloco de vídeo ("asset") correspondente ao arquivo MPEG na Janela de Recursos e clique nele com o botão direito do mouse. Escolha "Info". O número de trilhas de legendas aparece na parte de baixo.

@cindex Imagens CR2
@item @b{Interpolar imagens CR2} @*
Habilita a interpolação de imagens CR2. Esta opção é requerida, uma vez que imagens brutas em arquivos CR2 estão em um padrão Bayer. A interpolação usa a interpolação interna ("built-in") do dcraw e é muito lenta. Esta operação pode ser desabilitada e o efeito @b{Interpolar Pixels} usado ao invés dela para pré-visualização rápida.

@cindex Balancear Branco Imagens CR2
@item @b{Balancear Branco Imagens CR2} @*
Habilita o balanceamento de branco para imagens CR2 se a interpolação também estiver habilitada. Ela usa a matriz de câmera que está contida no arquivo CR2. O balanceamento de branco não é feito se a interpolação não for feita, já que o balanceamento de branco requere uma mescla ("blending") de todas as três cores primárias. @*
Desabilitar o balanceamento de branco é útil para operações envolvendo subtração de quadros escuros. O quadro escuro e a longa exposição precisam ter a mesma matriz de cor. @*
Se você desabilitar o @b{Interpolar imagens CR2} e usar o efeito @b{Interpolar Pixels}, saiba que o efeito @b{Interpolar Pixels} sempre faz tanto a interpolação quanto o balanceamento de branco usando a matriz de câmera, independentemente das configurações nas Preferências. A subtração de quadros escuros precisa ser realizada antes do @b{Interpolar Pixels}.

@cindex Driver do dispositivo de vídeo
@item @b{Driver de Vídeo} @*
Normalmente, o vídeo na Linha do Tempo vai para a Janela de Composição durante a reprodução contínua e quando o ponto de inserção é reposicionado. Ao invés de enviar o vídeo para a Janela de Composição, o driver pode ser configurado para enviar o vídeo para outro dispositivo de saída durante a reprodução contínua. Entretanto, isso não afeta onde o vídeo vai quando o ponto de inserção é reposicionado. @*
Os drivers de vídeo e seus parâmetros estão descritos na seção de drivers de vídeo.  @xref{Drivers de Vídeo}.
@end itemize

@c cincvdoc_node_number_47
@node Gravação
@section Gravação
@cindex Gravação

Os parâmetros aqui influenciam no que acontece quando você vai para @b{Arquivo->Gravar...}. A intenção era fazer o @b{Arquivo->Gravar...} ir o mais rápido possível para a Janela de Monitoramento de Gravação, sem uma caixa de diálogo extensa para configurar o formato de arquivo. Ao invés disso, o formato de arquivo para gravação é configurado aqui e é aplicado a todas as gravações. Também configurado aqui é o hardware para gravação, já que o hardware determina os formatos de arquivo suportados na maioria dos casos.

@menu
* Formato de arquivo::
* Entrada de Áudio::
* Entrada de Vídeo::
@end menu

@c cincvdoc_node_number_48
@node Formato de arquivo
@subsection Formato de arquivo
@cindex Formato de arquivo

Determina o formato de arquivo de saída para gravações. Depende muito do tipo de driver usado. A interface é a mesma que a intercafe de renderização. A opção @b{Gravar trilhas de áudio} deve estar habilitada para gravar áudio. A opção @b{Gravar trilhas de vídeo} deve estar habilitada para gravar vídeo. O botão de ferramenta à esquerda de cada opção abre um diálogo de configuração para configurar o codec correspondente para áudio de vídeo. O áudio e o vídeo são empacotados em um contâiner definido pelo menu @b{Formato de arquivo}. Contâiners diferentes podem gravar apenas áudio, apenas vídeo ou ambos.

Alguns drivers de vídeo só conseguem gravar em determinados contâiners. DV, por exemplo, consegue apenas gravar para Quicktime com DV como compressão de vídeo. Se o driver de vídeo é modificado, o formato de arquivo pode ser atualizado para dar a saída suportada. Se você mudar o formato de arquivo para um formato não suportado, ele pode não funcionar com o driver de vídeo.

@c cincvdoc_node_number_49
@node Entrada de Áudio
@subsection Entrada de Áudio
@cindex Entrada de Áudio

Determina o que acontece quando você grava o áudio.

@cindex Driver de gravação
@cindex Caminho do dispositivo
@cindex Bits
@itemize @bullet
@item @b{Driver de Gravação} @*
Usado para a gravação de áudio na Janela de Gravação. Pode ser compartilhado com o driver de gravação para vídeo se o áudio e o vídeo estiverem empacotados na mesma faixa. Leva parâmetros variáveis dependendo do driver. Note que os drivers são os mesmos que os disponíveis em Preferências->Reprodução. @xref{Drivers de Áudio}.

@cindex Amostras para gravar no disco por vez
@item @b{Amostras para gravar no disco por vez} @*
O áudio é primeiramente lido em pequenos fragmentos a partir do dispositivo. Muitos pequenos fragmentos são combinados em um grande fragmento antes de ser escrito no disco. O processo de gravação no disco é feito em uma etapa diferente. O valor aqui determina quão grande será a combinação de fragmentos para cada gravação no disco.

@cindex Taxa de amostragem para gravação
@item @b{Taxa de amostragem para gravação} @*
Independentemente de quais sejam as configurações do projeto, esta é a taxa de amostragem usada para gravação. Deve ser o mais alto que o dispositivo de áudio suporta.
@end itemize

@c cincvdoc_node_number_50
@node Entrada de Vídeo
@subsection Entrada de Vídeo
@cindex Entrada de Vídeo

Determina o que acontece quando você grava o vídeo.

@cindex Driver de gravação
@itemize @bullet
@item @b{Driver de Gravação} @*
É usado para a gravação de vídeo na Janela de Gravação. Pode ser compartilhada com o driver de gravação de áudio se o áudio e o vídeo estiverem empacotados em uma mesma faixa. Leva parâmetros variáveis dependendo do driver. Note que os drivers são os mesmos que os disponíveis em Preferências->Reprodução. @xref{Drivers de Vídeo}.

@cindex Quadros a serem gravados no disco por vez
@item @b{Quadros a serem gravados no disco por vez} @*
Quadros são gravados em um pipeline. Primeiro, os quadros são bufferizados no dispositivo. Eles então são lidos em um buffer mais largo para serem escritos no disco. A gravação no disco é feita em uma etapa diferente da leitura do dispositivo. Para certos codecs, a gravação no disco usa múltiplos processadores. Este valor determina quantos quadros serão gravados no disco por vez.

@cindex Quadros a serem bufferizados no dispositivo
@item @b{Quadros para bufferizar no dispositivo} @*
O número de quadros a serem armazenados no dispositivo antes de serem lidos. Determina quanto de latência pode existir em um sistema antes que se salte quadros ("frames dropping").

@cindex Usar software para posicionar informação
@item @b{Usar software para posicionar informação} @*
Vídeo usa áudio para a sincronização, mas a maioria das placas de som não dão informações acuradas de posição. Esta opção calcula uma estimativa da posição de áudio no software ao invés do hardware para a sincronização.

@cindex Sincronizar drives automaticamente
@item @b{Sincronizar drives automaticamente} @*
Para gravação de taxas de bits altas,os drives devem ser rápidos o suficiente para armazenar a informação, mas o GNU/Linux pode esperar vários minutos e atrasar, conforme escreve vários minutos de informação de uma vez. Esta opção força o GNU/Linux a descarregar seus buffers a cada segundo ao invés de a cada alguns minutos e produz um comportamento levemente mais tempo-real.

@cindex Tamanho do quadro capturado
@item @b{Tamanho do quadro capturado} @*
Este é o tamanho dos quadros gravados. É independente do tamanho de quadro do projeto, já que a maioria dos dispositivos de vídeo gravam apenas um tamanho fixo de quadro. Se o tamanho de quadro informado aqui não for suportado pelo dispositivo, o Cinelerra pode dar pau.

@cindex Taxa de quadros para gravação
@item @b{Taxa de quadros para gravação} @*
A taxa de quadros gravada é diferente da configuração do projeto. Esta opção configura a taxa de quadros a ser gravada.
@end itemize

@c cincvdoc_node_number_51
@node Performance
@section Performance
@cindex Performance

Você passará amaior parte do tempo configurando esta seção. O foco principal da performance são os parâmetros de renderização que não estão disponíveis no diálogo de renderização.

@cindex Itens de cache
@itemize @bullet
@item @b{Itens de cache} @*
Para aumentar a velocidade do render, vários blocos de vídeo ("assets") são mantidos abertos simultaneamente. Este parâmetro determina quantos são mantidos abertos. Um número muito alto pode exaurir sua memória bem rápido e resultar no programa dando pau. Um número muito baixo pode resultar em uma reprodução ("playback") lenta uma vez que os blocos de vídeo ("assets") precisam ser reabertos mais freqüentemente.

@cindex Segundos para renders preroll
@item @b{Segundos para renders preroll} @*
Alguns efeitos requerem um certo período de tempo para se ajustarem. Este parâmetro configura um número de segundos a serem renderizados sem que sejam escritos no disco antes que a região selecionada seja renderizada. Quando usando a fazenda de renderização ("renderfarm"), você precisará às vezes fazer um "preroll" para conseguir transições tranquilas entre os trabalhos. Cada trabalho em uma fazenda de renderização faz um "preroll" levando este valor em consideração. Ele não afeta, entretanto, a renderização de fundo ("background rendering"). Renderizações de fundo usam um valor diferente de "preroll".

@cindex Forçar uso de processador único
@cindex SMP, forçar uso de processador único
@item @b{Forçar uso de processador único} @*
O Cinelerra tenta usar todos os processadores do sistema por padrão, mas às vezes ele quererá usar apenas um processador, como em um cliente de uma fazenda de renderização ("renderfarm"). Este parâmetro força o uso de apenas um processador. O sistema operacional, entretanto, normalmente usará o segundo processador de qualquer forma para acessar o disco rígido, então esta opção é na verdade um modo de 1.25 processador.  O valor deste parâmetro é usado em clientes de fazendas de renderização.
@end itemize

@menu
* Renderização de fundo::
* Fazenda de renderização::
@end menu

@c cincvdoc_node_number_52
@node Renderização de fundo
@subsection Renderização de fundo
@cindex Renderização de fundo

A renderização de fundo ("background rendering") foi originalmente concebida para permitir que efeitos HDTV fossem exibidos em tempo-real. A renderização de fundo faz com que a saída temporária seja constantemente renderizada enquanto a Linha do Tempo está sendo modificada. A saída temporária é exibida durante a reprodução sempre que possível. É bastante útil para transições e previsões de efeitos que são muito lentos para serem reproduzidos em uma quantia razoável de tempo. Se a fazenda de renderização ("renderfarm") estiver habilitada, a fazenda é usada para a renderização de fundo, dando-lhe o potencial para efeitos em tempo-real caso haja banda ou nódulos de CPU suficientes.

A renderização de fundo é habilitada na aba @b{Performance} da Janela de @b{Preferências}. Ela possui uma função interativa @b{Menu configurações -> Ajustar renderização de fundo}. Isso marca onde a renderização de fundo começa para onde o ponto de entrada estiver. Se algum vídeo existe, uma barra vermelha aparece na barra de tempo, mostrando o que foi renderizado ao fundo.

É normalmente útil inserir um efeito ou uma transição e selecionar @b{Menu configurações -> Ajustar renderização de fundo} logo antes do efeito para pré-visualizá-lo a taxas de quadros inteiras.

@cindex Quadros por trabalho de renderização ao fundo
@itemize @bullet
@item @b{Quadros por cada trabalho de renderização ao fundo} @*
Este parâmetro só funciona caso a fazenda de renderização ("renderfarm") estiver sendo usada.Do contrário, a renderização de fundo criará um trabalho único para toda a Linha do Tempo. O número de quadros especificado aqui é escalado para a valocidade relativa de CPU dos nódulos de renderização e usado em um único trabalho de fazenda de renderização. O número ótimo está entre 10 - 30, já que a banda de rede é usada para iniciar cadatrabalho.

@cindex Quadros para preroll ao fundo
@item @b{Quadros para preroll ao fundo} @*
Este é o número de quadros a serem renderizados à frente de cada trabalho de renderização de fundo. A renderização de fundo é degradada quando o "preroll" é utilizado, já que os trabalhos são pequenos. Quando estiver usando renderização de fundo ("background rendering"), este número é idealmente 0. Alguns efeitos podem requerer 3 quadros de "preroll".

@cindex Saída para a renderização de fundo
@item @b{Saída para renderização ao fundo} @*
A renderização de fundo gera uma seqüência de arquivos de imagem em um certo diretório. Este parâmetro determina o prefixo do nome de arquivo dos arquivos de imagem. Deve ser configurado para um disco rápido, acessível a cada nódulo da fazenda de renderização ("renderfarm") pelo mesmo caminho. Uma vez que centenas de milhares de arquivos de imagem serão normalmente criados, comandos @command{ls} não funcionarão no diretório de renderização de fundo. O botão @image{manual_images_intl/magnify,7mm} para esta opção também normalmente não funcionará, mas o botão de configuração @image{manual_images_intl/wrench,4.33mm} para esta opção funcionará.

@cindex Formato de arquivo
@item @b{Formato de arquivo} @*
O formato de arquivo para a renderização de fundo deve ser uma seqüência de imagens. O formato da seqüência imagens determina a qualidade e a velocidade da reprodução. JPEG costuma ser uma boa opção na maioria das vezes.
@end itemize

@c cincvdoc_node_number_53
@node Fazenda de renderização
@subsection Fazenda de renderização
@cindex Fazenda de renderização

Para usar a fazenda de renderização, configure estas opções. Ignore-as no caso de um sistema único.

@cindex Usar a fazenda de renderização para renderizar
@itemize @bullet
@item @b{Usar a fazenda de renderização para renderizar} @*
Quando selecionada, todas as operações de @b{arquivo->render} usarão a fazenda de renderização.

@cindex Nódulos
@item @b{Nódulos} @*
Exibe todos os nódulos da fazenda de renderização e quais estão ativos. Nódulos são adicionados ao se informar o nome do hospedeiro ("host name") do nódulo, verificando o valor da @b{porta} e clicando em @b{adicionar nódulo}. Nerds de computador ficarão mais contentes editando o arquivo @file{~/.bcast/.Cinelerra_rc} ao invés deste caso tenham centenas de nódulos. Lembre-se que o arquivo @file{.Cinelerra_rc} é sobrescrito sempre que uma cópia do Cinelerra sair do programa. @*
Selecione a coluna @b{Ligado} para ativar e desativar nódulos uma vez que sejam criados. Os nódulos podem ser editados selecionando uma fileira e clicando em @b{Aplicar Mudanças}.

@cindex Hostname, fazenda de renderização
@item @b{Hostname} @*
Edite o nome de hospedeiro ("hostname") de um nódulo existente ou informe o nome de hospedeiro de um novo nódulo aqui.

@cindex Porta, fazenda de renderização
@item @b{Porta} @*
Edite a porta ("port") de um nódulo existente ou informe a porta de um novo nódulo aqui.

@cindex Mudanças, aplicar
@item @b{Aplicar mudanças} @*
Quando editando um nódulo existente, clique aqui para enviar ("commit") as mudanças para o @b{hostname} e a @b{porta}. As mudanças não serão enviadas ("committed") se você não apertar este botão.

@cindex Nódulo, adicionar um
@item @b{Adicionar nódulo} @*
Cria um novo nódulo com as configuarções de @b{hostname} e @b{porta}.

@cindex Nódulo, apagar um
@item @b{Apagar nódulo} @*
Apaga quaisquer nódulos que estejam selecionados na lista de @b{nódulos}.

@cindex Ordenar nódulos
@cindex Nódulos, ordenar
@item @b{Ordenar nódulos} @*
Ordena a lista de @b{nódulos} baseado no nome de hospedeiro ("hostname").

@cindex Taxas, zerar
@item @b{Zerar taxas} @*
Zera a taxa de quadros de todos os nódulos. Taxas de quadros são usadas para escalar os tamanhos de trabalhos baseados na velocidade de CPU do nódulo. Taxas de quadros são calculadas apenas quando a fazenda de renderização ("renderfarm") está habilitada.

@cindex Total de trabalhos a serem criados
@cindex Trabalhos, número total a ser criado
@item @b{Total de trabalhos a serem criados} @*
Determina o número de trabalhos a serem despachados para a fazenda de renderização ("renderfarm"). Quanto mais trabalhos você criar, melhor balanceada a fazenda de renderização se tornará. @*
Você pode determinar o total de trabalhos a ser criado multiplicando o número de nódulos incluindo o nódulo-mestre por algum número. Multiplique-os por 1 para ter um trabalho despachado para cada nódulo. Multiplique-os por 3 para ter três trabalhos despachados para cada nódulo. Se você tem 10 nódulos-escravos e um nódulo-mestre, especifique 33 para ter uma fazenda de renderização balanceada.
@end itemize

@c cincvdoc_node_number_54
@node Interface
@section Interface
@cindex Interface

Estes parâmetros afetam unicamente como a interface do usuário funcionará.

@cindex Representação de tempo
@itemize @bullet
@item @b{Formato de Tempo}@*
Várias representações de tempo são fornecidas. Selecione a mais conveniente. A representação de tempo também pode ser mudada pela tecla @key{CTRL} clicando na barra de tempo.

@cindex Arquivos de índice, localização
@cindex Arquivos de índice

@item @b{Arquivos de índice vão aqui} @*
De volta aos tempos em que 4 MB/seg era uma velocidade extra-terrestre para um disco rígido, arquivos de índice foram introduzidos para aumentar a velocidade do desenho das trilhas de áudio. Esta opção determina onde os arquivos de índice serão criados no disco rígido.

@cindex Arquivo de índice, tamanho de
@item @b{Tamanho do arquivo de índice} @*
Determina o tamanho de um arquivo de índice. Tamanhos grandes de índice permitem que arquivos menores sejam desenhados mais repidamente, enquanto deixam mais lentos os desenhos para arquivos grandes. Tamanhos menores de índices permitem que arquivos grandes sejam desenhados mais rápidos enquanto diminuem a velocidade para arquivos pequenos.

@cindex Arquivos de índice, número a serem mantidos
@item @b{Número de arquivos de índice para manter} @*
Para evitar que o diretório dos arquivos de índice se torne sem regras, arquivos de índice antigos são apagados. Este parâmetro determina o número máximo de arquivos de índice a serem mantidos no diretório.

@cindex Arquivos de índice, apagar todos
@item @b{Apagar índices existentes} @*
Quando você muda o tamanho de índice ou quando você quer limpar arquivos excessivos de índice, esta opção apaga todos os arquivos de índice.

@cindex Pré-visualizações
@item @b{Usar miniaturas} @*
A Janela de Recursos exibe pré-visualizações em miniatura ("thumbnails") dos blocos de vídeo ("assets") por padrão. Isso pode levar bastante tempo para acontecer. Esta opção desabilita as pré-visualizações.

@cindex Bordas de edição, arrastar faz o quê
@item @b{Arrastar as bordas de edição faz} @*
O Cinelerra não permite apenas que você faça edições arrastando as bordas de
edição, mas também define três operações separadas que podem acontecer quando
você arrasta uma borda de edição. Para cada botão de mouse, você pode selecionar
um comportamento nesta janela. O uso de cada modo de edição está descrito na
seção de edição. @xref{Redimensionando ("trimming")}.


@cindex Medidor, dB mín
@item @b{DB Mín para medidor} @*
Algumas fontes de som possuem uma entrada de ruído mais baixa do que outras. Tudo abaixo da entrada de ruído é não-significativo. Esta opção configura o medidor para fazer um recorte abaixo de um certo nível. Placas de som de nível consumidor normalmente chegam até -65. Placas de som profissionais chegam a -90.  @xref{Janela de medidores de nível de som}.

@cindex Medidor, dB máx
@item @b{DB Máx para medidor} @*
Configura o nível máximo de som representado pelos medidores de som. Independentemente de qual seja este valor, nenhuma placa de som consegue reproduzir som acima de 0 dB@. Este valor é apresentado meramente para mostrar quão fora do limite uma onda sonora pode estar. @xref{Janela de medidores de nível de som}.

@cindex Tema
@item @b{Tema} @*
O Cinelerra suporta temas variáveis. Selecione um aqui e reinicie o Cinelerra para vê-lo.
@end itemize

@c cincvdoc_node_number_55
@node Sobre
@section Sobre, janela

Esta seção te dá informações sobre direitos autorais, quando o build presente foi criado, a falta de uma garantia e as versões de algumas bibliotecas. Esteja certo de concordar com os termos de falta de garantia.

@c cincvdoc_node_number_56
@node Atributos do projeto
@chapter Atributos do projeto
@cindex Atributos do projeto

@menu
* Janela de configuração de formato::
* Pré-configurações::
* Atributos de áudio::
* Atributos de vídeo::
@end menu

@c cincvdoc_node_number_57
@node Janela de configuração de formato
@section Janela de configuração de formato
@cindex Janela de configuração de formato

Quando você reproduz arquivos de mídia no Cinelerra, os arquivos de mídia possuem um certo número de trilhas, uma certo tamanho de quadro, um certo tamanho de amostragem e assim por diante. Não importa o que o arquivo de mídia possui; entretanto, ele ainda será reproduzido de acordo com os atributos do projeto. Se uma taxa de amostragem de áudio for diferente dos atributos do projeto, ela será refeita. Se o tamanho do quadro de um arquivo de vídeo for diferente dos atributos do projeto, ele será composto a um quadro preto, ou recortado ou encaixado dentro de bordas pretas.

Os atributos do projeto são ajustados em @b{Configurações->Ajustar Formato} e, de uma forma algo mais limitada, em @b{Arquivo->Novo}. Quando você ajusta as configurações do projeto em @b{Arquivo->Novo}, uma nova linha do tempo é criada sem informações. Cada linha do tempo criada a partir deste ponto usará as mesmas configurações. Quando você ajusta asconfigurações em @b{Configurações->Formato}, a linha do tempo não é recriada sem informações, mas cada linha do tempo criada a partir deste ponto usará as mesmas configurações.

@center @image{manual_images_intl/format,70mm}
@center @b{Janela de configuração de Formato}

Além das configurações tradicionais de taxa de amostragem, taxa de quadros e tamanho de imagem, o Cinelerra usa algumas configurações pouco usuais como @b{posições de canais, modelo de cor e razão de aspecto.}

@c cincvdoc_node_number_58
@node Pré-configurações
@section Pré-configurações
@cindex Pré-configurações

Selecione uma opção deste menu para ter todas as configurações de projeto marcadas para um dos padrões conhecidos.

@c cincvdoc_node_number_59
@node Atributos de áudio
@section Atributos de áudio
@cindex Atributos de áudio

@itemize @bullet
@item @b{Trilhas} @*
Marca o número de trilhas de áudio que o novo projeto deverá ter. Trilhas podem ser adicionadas ou apagadas depois, mas opções são dadas aqui por uma conveniência.

@item @b{Taxa de amostagem} @*
Marca a taxa de amostragem do áudio. A taxa de amostragem do projeto não tem que ser a mesma da taxa de amostragem das mídias que você carregar. A mídia terá sua taxa de amostragem refeita para se adequar à do projeto.

@item @b{Canais} @*
Marca o número de canais de áudio que o novo projeto deverá ter. O número de canais de áudio não precisa ser o mesmo do número de trilhas.

@item @b{Posições dos canais} @*
Os canais de áudio atualmente habilitados e suas posições são exibidos no desenho de posições de canais.
@end itemize

@center @image{manual_images_intl/channelpositions,40mm}
@center @b{A ferramenta de posição do canal}

Os canais são numerados. Quando renderizados, a saída do canal 1 é renderizada para a primeira trilha de saída no arquivo ou para o primeiro canal da placa de áudio. Outros canais serão renderizados para suas trilhas sucessivamente numeradas.

Os locais dos canais de áudio correspondem a onde na panorâmica cada saída de áudio está. Quão mais perto a posição da panorâmica estiver se uma das saídas de áudio, mais sinal o falante obterá. Clique em um ícone de falante e arraste para mudar a localização do canal de áudio.

Os falantes podem estar em qualquer orientação. Um arranjo diferente de falantes é armazenado para cada número de canais de áudio já que normalmente você não quer que o mesmo arranjo de falantes para números diferentes de canais.

As posições de canais são a única configuração que não afetam a saída necessariamente. É simplesmente uma conveniência, então quando mais de dois canais são usados, os controles de panorâmica na linha do tempo podem distinguir entre eles. Isso não tem nada a ver com o arranjo real dos falantes.

Mas canais diferentes podem ser posicionados muito próximos um ao outro para fazer com que tenham a mesma saída.

@xref{Fazendo um pan nas trilhas de áudio}.

@c cincvdoc_node_number_60
@node Atributos de vídeo
@section Atributos de vídeo
@cindex Atributos de vídeo

@itemize @bullet
@item @b{Trilhas} @*
Marca o número de trilhas de vídeo que o novo projeto deve ter. Trilhas podem ser adicionadas ou apagadas mais tarde, mas opções são dadas aqui por uma conveniência.

@item @b{Taxa de quadros} @*
Marca a taxa de quadros do vídeo. A taxa de quadros do projeto não precisa ser a mesma das mídias que você vai carregar para dentro dele. Elas terão as suas reajustadas para se adequar à do projeto.

@item @b{Tamanho da tela} @*
Marca o tamanho da saída de vídeo. Cada trilha também possui seu próprio tamanho de quadro. Inicialmente, o diálogo @b{Novo Projeto} cria trilhas de vídeo cujos tamanhos todos se adequam à saída de vídeo, mas os tamanhos de trilha de vídeo podem ser mudados mais tarde sem que se mude a saída de vídeo.

@item @b{Razão de aspecto} @*
Marca a razão de aspecto. A razão de aspecto é aplicada à saída de vídeo. A razão de aspecto pode ser diferente do número de pixels horizontais / pixels verticais. Marcar uma razão de aspecto diferente do que o número de pixels resulta em pixels não-quadrados.

@item @b{Razão de aspecto automática} @*
Caso esteja habilitado, o diálogo @b{Novo Projeto} sempre recalculará a configuração de @b{Razão de aspecto} quando o @b{Tamanho da tela} for mudado. Isso assegura que os pixels sempre sejam quadrados.

@item @b{Modelo de Cor} @*
Marca o modelo de cor para os quais os intermediários de vídeo no projeto vão ser armazenados. @* O modelo de cor é importante para a reprodução do vídeo já que o vídeo possui a desvantagem de ser muito lento. Embora não seja notável, intermediários de áudio contêm muito mais informação que o áudio no disco e que o áudio que está sendo reproduzido. O áudio sempre usa o intermediário de banda mais alto porque é rápido. @*
Intermediários de vídeo devem usar a menor quantidade de informação para a qualidade requerida porque ele é lento, mas os intermediários de vídeo ainda usam um modelo de cor com uma banda mais alta do que o vídeo que está armazenado ou que está sendo reproduzido. Isso permite que mais processamento seja feito com menos destruição da informação original. @*
O vídeo é armazenado no disco em um modelo de cor, normalmente comprimido usando um derivativo YUV. Quando reproduzido, o Cinelerra o descomprime do formato de arquivo diretamente no formato do dispositivo de saída. Caso efeitos sejam processados, a descompressão é em um modelo de cor intermediário primeiro e o modelo de cor intermediário é então convertido no formato do dispositivo de saída. A seleção do modelo de cor intermediário determina quão preciso e rápido serão os efeitos. @*
Os modelos de cor do Cinelerra são descritos usando uma certa ordem de empacotamento de componentes e um certo número de bits para cada componente. A ordem de empacotamento é impressa à esquerda e a alocação de bit é impressa à direita.
@cindex RGB-888
@itemize @bullet
@item @b{RGB-888} @*
Aloca 8 bits para os canais R, G e B e nenhum alfa. É normalmente usado para mídia descomprimida com abrangência dinâmica baixa.
@cindex RGBA-8888
@item @b{RGBA-8888} @*
Aloca um canal alfa ao modelo de cor RGB de 8 bits. É usado para sobrepor múltiplas trilhas.
@cindex YUV-888
@item @b{YUV-888} @*
Aloca 8 bits para Y, U e V@. É usado para operações de abrangência dinâmica baixa nas quais a mídia é comprimida no espaçamento de cor YUV. A maioria das mídias comprimidas está em YUV e isso permite que elas sejam processadas rapidamente com a menor degradação de cor.
@cindex YUVA-8888
@item @b{YUVA-8888} @*
Aloca um canal alfa ao modelo de cor YUV de 8 bits para transparência.
@cindex RGB-Float
@item @b{RGB-Float} @*
Aloca um float 32 bit para os canais R, G e B e nenhum alfa. É usado para processamento de abrangência dinâmica alta sem transparência.
@cindex RGBA-Float
@item @b{RGBA-Float} @*
Adiciona um float 32 bit para alfa ao RGB-Float. É usado para processamento de abrangência dinâmica alta com transparência.
@end itemize
@b{Para fazer efeitos que envolvem um canal alfa, um modelo de cor com canal alfa deve ser selecionado}. Esses são RGBA8888, YUVA8888 e RGBA Float. Os modelos de cor de 4 canais são notoriamente mais lentos do que os de 3 canais, sendo o mais lento o RGBA Float. Alguns efeitos como fade conseguem trabalhar sem a necessidade de um canal alfa, enquanto outros como o chromakey requerem um canal alfa para fazer qualquer coisa, então é uma boa idéia tentar o efeito sem canais alfa para ver se ele funciona antes de configurar o projeto com um canal alfa e deixá-lo mais lento. @*
Os modelos de cor YUV são normalmente mais rápidos do que os modelos de cor RGB quando se usa material comprimido. Eles também destróem menos cores do que os modelos RGB. Se um material armazenado como JPEG ou MPEG for processado muitas vezes em RGB, as cores vão esvanecer enquanto isso não acontecerá caso sejam processadas em YUV@. @*
Anos trabalhando com material com abrangência dinânica alta mostraram que o RGB com ponto flutuante ("floating point RGB") é o melhor formato para abrangência dinâmica alta. Enquanto os integradores ("integers") de 16 bit eram usados no passado, eles tinham muita perda ("lossy") e eram muito lentos para a quantidade de melhorias. @*
O RGB float não destrói a informação quando usado com um material fonte YUV. Ele também suporta brilho acima de 100%. Saiba que alguns efeitos, como o Histograma, ainda recortam acima de 100% quando usados com ponto flutuante.
@end itemize

@c cincvdoc_node_number_61
@node Carregando e salvando arquivos
@chapter Carregando e salvando arquivos
@cindex Carregando e salvando arquivos
@cindex Arquivos, carregando e salvando

@menu
* Formatos de arquivo suportados::     Quais formatos o Cinelerra consegue importar e exportar
* Carregando arquivos::                Carregando todos os tipos de arquivos
* Carregando o backup::                Recuperando uma sessão de antes de um pau
* Salvando arquivos de projeto::       Salvando e editando listas de decisão
* Fundindo projetos::
@end menu

@c cincvdoc_node_number_62
@node Formatos de arquivo suportados
@section Formatos de arquivo suportados
@cindex Formatos de arquivo suportados
@cindex Formatos de arquivo

Aqui está a maioria dos formatos de arquivo suportados e notas sobre sua compressão. Você pode ser capaz de conseguir carregar outros formatos não descritos aqui. @*
O formato do arquivo afeta o que o Cinelerra faz com ele. Editar as Listas de Decisão de Edição (EDL) substitui as configurações do projeto. Formatos que contêm mídia mas não edições de decisões apenas adicionam informações às trilhas. Se a taxa de amostragem de seu projeto é 48 kHz e você carregar um arquivo de áudio a 96khz, você ainda o estará reproduzindo a 48 kHz. Se você carregar um arquivo EDL a 96khz e a taxa de amostragem do projeto atual for de 48 kHz, você o mudará para 96 kHz. @*
Alguns formatos de arquivo são exibidos muito lentamente na Linha do Tempo. Normalmente, eles possuem vídeos que estão altamente comprimidos. Desenhar nos vídeos altamente comprimidos pode ser muito lento - desabilite o desenho ("picon drawing") para estes arquivos com a opção @b{Desenhar mídia} para aumentar a velocidade das operações.

@center @image{manual_images_en/track_attributes}
@center @b{Atributos de trilha}

Atualmente, são suportados os seguintes formatos:
@itemize @bullet
@item WAV
@item PCM
@item AIFF
@item áudio AC3
@end itemize

@menu
* Quicktime::
* Áudio MPEG-4::
* Seqüência de imagens::
* Imagens estáticas::
* AVI::
* Arquivos MPEG contendo vídeo::
* Vídeos de DVD::
* Áudio MPEG 1::
* Ogg Theora/Vorbis::
* Listas de decisões de edição::
@end menu

@c cincvdoc_node_number_63
@node Quicktime
@subsection Quicktime
@cindex Quicktime

Quicktime não é o padrão para UNIX, mas nós o usamos porque ele é bem documentado. Todos os vídeos Quicktime na internet são comprimidos. O Cinelerra não suporta a maioria dos vídeos Quicktime comprimidos, mas suporta alguns. Se o programa der pau quando tentar carregar um vídeo Quicktime, isso significa que o formato provavelmente não era suportado. @*
O Quicktime é um contâiner para 2 codecs, um codec de vídeo e um codec de áudio. Os codecs de vídeo e áudio são pegos separadamente. A codificação preferível de saída para Quicktime é vídeo em MPEG-4 e áudio em MPEG-4. Este formato toca nos reprodutores comerciais do Windows e possui uma boa qualidade de compressão. Para uma melhor compressão, use vídeo em H-264. Infelizmente, a decodificação do H-264 é tão lenta que ele não consegue reproduzir tamanhos de quadros muito grandes. @*
O Cinelerra suporta 2 codecs não-padrão: vídeo em Dual MPEG-4 e vídeo em Dual H.264. Eles não tocarão em nada além do Cinelerra e do XMovie. Eles são desenhados para vídeos nos quais os quadros foram divididos em 2 campos ("fields"), cada campo sendo exibido sequencialmente. Os codecs Dual sobrepõem ("interleave") as duas faixas de vídeo para melhorar a eficiência sem requerer mudanças maiores no reprodutor ("player").

@c cincvdoc_node_number_64
@node Áudio MPEG-4
@subsection Áudio MPEG-4
@cindex Áudio MPEG-4

É o mesmo que o Quicktime com MPEG-4 como codec de áudio.

@c cincvdoc_node_number_65
@node Seqüência de imagens
@subsection Seqüência de imagens
@cindex Seqüência de imagens

Renderizar uma seqüência de imagens não é o mesmo que renderizar uma única imagem. Quando se renderiza uma seqüência de imagens, o Cinelerra gera um arquivo de tabela de conteúdos ("TOC") para a seqüência de imagens e faz uma imagem diferente para cada posição da Linha do Tempo. A tabela de conteúdos pode ser carregada ao invés das imagens individuais para obter uma performance melhor. Para aprender mais sobre os diferentes formatos de imagens suportados em uma seqüência de imagens, leia sobre imagens estáticas (a seguir).

Para evitar importar no Cinelerra uma seqüência de imagens como uma série de quadros únicos e para configurar manualmente sua duração na linha do tempo, (o que seria muito lento e consumiria muitos recursos do sistema), você pode usar um "arquivo de lista". Um "arquivo de lista" é um arquivo de texto com um formato específico contendo caminhos absolutos para todos os quadros da seqüência mais informações adicionais como resolução da imagem, formato de arquivo e taxa de quadros da seqüência. Esta lista pode ser escrita manualmente (não muito agradável, especialmente quando se lida com longos caminhos de arquivo e muitos quadros) ou com a ajuda do IMG2LIST 0.1.5., um pequeno aplicativo escrito por Claudio "malefico" @sc{Andaur}. Este script gera uma lista a partir de um quadro de uma seqüência de imagens e auto-detecta todos os parâmetros dela, incluindo o número de quadros, formato de arquivo e resolução de imagem. Para saber mais sobre este Gerador de Listas do Cinelerra e para baixá-lo, veja @uref{http://argoslabs.com/~malefico/software/img2list.html}.

@c cincvdoc_node_number_66
@node Imagens estáticas
@subsection Imagens estáticas
@cindex Imagens estáticas
@cindex Imagens, estáticas

@menu
* Carregando imagens estáticas::
* Tamanho de imagens estáticas::
* Abrindo imagens EXR::
* Imagens brutas de câmeras digitais::
@end menu

@c cincvdoc_node_number_67
@node Carregando imagens estáticas
@subsubsection Carregando imagens estáticas
@cindex Carregando imagens estáticas
@cindex Imagens estáticas, carregando

Renderizar uma única imagem faz com que o arquivo de imagem seja sobrescrito para cada posição da Linha do Tempo. Nenhuma tabela de conteúdos é criada. Quando carregada na linha do tempo, a imagem ocupa a duração de um quadro ("frame"). Aproxime a Linha do Tempo para vê-la. Para extender sua duração, arraste suas bordas como você faria com recortes de vídeo. Você pode arrastar as bordas de uma imagem estática tanto quanto quiser. Imagens no Cinelerra possuem duração infinita. @*
O Cinelerra permite que você defina a duração inicial dos recortes carregados. O parâmetro para isto está na seção @b{Imagens} da janela @b{Configurações->Preferências->Janela de gravação}. @*
A menos que seu material original venha de uma fonte digital (como uma câmera de fotografia digital), a primeira coisa que você deve fazer antes de usá-la é de alguma forma capturar os blocos ("assets") em um meio digital utilizável. @*
Para fotos antigas, mapas em papel, desenhos ou diagramas, você pode querer usar um scanner para lê-los e transformá-los em arquivos PNG, TIF, TGA ou JPG. Você pode querer usar o programa Gimp para pós-processar as imagens, limpar áreas danificadas ou corrigir sua coloração. @*
Se suas imagens vêm de uma fonte digital como uma câmera digital ou uma captura de tela, assegure-se de capturar o material usando a melhor resolução possível. Isso te ajudará quando estiver trabalhando com o material dentro do Cinelerra.

@c cincvdoc_node_number_68
@node Tamanho de imagens estáticas
@subsubsection Tamanho de imagens estáticas
@cindex Tamanho de imagens estáticas
@cindex Imagens estáticas, tamanho

@b{Importante:} Imagens importadas sempre ficam em seu tamanho original. Assim, você deve levar em consideração a razão de aspecto de seu vídeo no Cinelerra e eventualmente redimensionar suas imagens antes de importá-las no Cinelerra. @* Por exemplo, a razão de aspecto de imagens PAL é 4:3, mas 720x576 é 5/4. Para que suas imagens importadas sejam exibidas corretamente, você precisa redimensionar o tamanho horizontal:
@*
Novo tamanho horizontal=@math{(5 / 4) / (4 / 3)} x Tamanho horizontal original @*
Para vídeos PAL, você tem que multiplicar o tamanho horizontal das imagens que você quer importar por um fator de 0.9375. @*
Aqui está um pequeno script shell que, quando rodado a partir de uma pasta contendo imagens jpg, redimensiona essas imagens e as coloca em uma nova pasta chamada @file{redimensionadas}:
@verbatim
#/bin/sh
mkdir redimensionadas
for element in `ls . | grep jpg`;
do
    size=`identify ${element}`
    width=`echo ${tamanho} | sed '+s+.*JPEG ++' | sed '+s+x.*++'`
    height=`echo ${tamanho} | sed '+s+.*JPEG [0-9]*x++' | sed '+s+DirectClass.*++'`
    let new_width=${largura}*9375/10000
    convert -resize "${nova_largura}x${altura}!" -quality 100 ${element} resized/${element}
done
@end verbatim

@c cincvdoc_node_number_69
@node Abrindo imagens EXR
@subsubsection Abrindo imagens EXR
@cindex Abrindo imagens EXR
@cindex Imagens, EXR

Você pode não conhecer o Open EXR@. Este formato armazena imagens de pontos flutuantes RGB ("floating point RGB images"). Ele também suporta um pequeno grau de compressão. Projetos que renderizam para EXR devem estar em um modelo de cor de ponto flutuante para obter vantagem dele @xref{Atributos do projeto}. Várias opções de compressão estão disponíveis para EXR@.

@cindex Compressão
@cindex Compressão PIZ
@itemize @bullet
@item @b{PIZ:} Compressão "lossless wavelet". Esta é a melhor compressão.
@cindex Compressão ZIP
@item @b{ZIP:} Algoritmo gzip "lossless".
@cindex Compressão RLE
@item @b{RLE:} Codificação "lossless run length". Esta é a compressão mais rápida e pior.
@cindex Compressão PXR24
@item @b{PXR24:} Compressão "lossy", na qual os números de pontos flutuantes são convertidos para 24 bits e comprimidos com gzip.
@end itemize

Selecione @b{Usar alfa} se o modelo de cor do projeto possui um canal alfa e você quer mantê-lo no arquivo. De outro modo, as cores primárias serão multiplicadas pelo canal alfa.

@c cincvdoc_node_number_70
@node Imagens brutas de câmeras digitais
@subsubsection Imagens brutas de câmeras digitais
@cindex Imagens brutas de câmeras digitais
@cindex Imagens de câmeras

Imagens brutas ("RAW") de câmeras digitais são um tipo especial de arquivo de imagem que o Cinelerra apenas importa. Elas devem ser processadas em um espaço de cor de ponto flutuante uma vez que estejam na Linha do Tempo. Imagens brutas de câmeras Canon são as únicas que foram testadas. Elas precisam que lhes seja aplicado o efeito @b{Gama} para corrigir o gama. Uma vez que imagens brutas levam um bom tempo para interpolar, elas normalmente são vistas primeiro em um arquivo proxy e depois tocadas.

Primeiro aplique o efeito Gama em uma trilha de imagens brutas e configure-o para @b{Automático} com gama em @b{0.6}. Depois, renderize a Linha do Tempo para um arquivo Quicktime JPEG. Apenda ("Append") o arquivo Quicktime JPEG em uma nova trilha e desabilite a reprodução ("playback") da trilha antiga. Agora, a cópia de cada imagem bruta com o gama corrigido pode ser pré-visualizada relativamente rápido na mesma posição da Linha do Tempo da imagem original.

@c cincvdoc_node_number_71
@node AVI
@subsection AVI
@cindex AVI

AVI com codecs de áudio e vídeo variados. Uma vez que o AVI é tão fragmentado, sua sorte vai variar.

@c cincvdoc_node_number_72
@node Arquivos MPEG contendo vídeo
@subsection Arquivos MPEG contendo vídeo
@cindex Arquivos MPEG contendo vídeo
@cindex mpeg3toc

Arquivos MPEG contendo vídeo podem ser carregados diretamente no Cinelerra. Se o arquivo for suportado, uma tabela de conteúdos (TOC) será construída. Se o arquivo não for suportado, o programa normalmente dá pau ou mostra trilhas muito pequenas. Infelizmente, este método de carregar arquivos MPEG não é bom o suficiente se você pretende usar uma fazenda de renderização ("renderfarm"). @*
Para usar arquivos MPEG em uma fazenda de renderização, você precisa rodar o mpeg3toc para gerar uma tabela de conteúdos (TOC) para o arquivo e então carregar a tabela de conteúdos. O mpeg3toc requere o caminho completo do arquivo MPEG. Se você não usar o caminho completo, ele assume que o arquivo MPEG está no mesmo diretório de onde o Cinelerra está sendo rodado. @*
Faixas de MPEG são estruturadas em várias trilhas. Cada trilha pode ser vídeo ou áudio. Cada trilha de áudio pode ter de 1-6 canais. O Cinelerra converte cada canal de áudio em uma trilha.

@cindex mpeg2enc
@b{Notas sobre codificação de vídeo em mpeg:} @*
A codificação de vídeo MPEG é feita separadamente da codificação de áudio MPEG. Em vídeos MPEG, há 2 modelos de cor. O modelo YUV 4:2:0 é codificado por uma versão altamente otimizada do mpeg2enc com pré-configurações para eletrônicos padrão de cosumidores. No processo de otimizar o mpeg2enc, eles se livraram da codificação YUV 4:2:2. O modelo de cor YUV 4:2:2 é codificado por uma versão menos otimizada do mpeg2enc. @*
A codificação YUV 4:2:2 foi mantida porque a versão NTSC do vídeo DV perde muita qualidade quando transferida para YUV 4:2:0. Este vídeo DV deve ser transferido para YUV 4:2:2. @*
Quando codificando para YUV 4:2:0, o parâmetro de taxa de bits possui um significado diferente dependendo de se a taxa de bits ou a quantização é mantida fixa. Se a taxa de bits for mantida fixa, significa a taxa de bits-alvo. Se a quantização e mantida fixa, significa o máximo permitido como taxa de bits. Esta é uma coisa estranha da versão do mpeg2enc.

@c cincvdoc_node_number_73
@node Vídeos de DVD
@subsection Vídeos de DVD
@cindex Vídeos de DVD
@cindex Arquivo IFO

O DVD é dividido em um número de programas, cada um identificado por um arquivo @file{IFO} singular. Se você quiser carregar um DVD, ache o arquivo @file{IFO} correspondente para o programa de interesse. Carregue o arquivo IFO diretamente e uma tabela de conteúdos (TOC) será construída. Alternativamente, para o uso de fazenda de renderização ("renderfarm"), a tabela de conteúdos pode ser criada separadamente. @*
@cindex mpeg3toc
Rode: @command{mpeg3toc -v /cdrom/video_ts/vts_01_0.ifo dvd.toc} @*
ou algo similar. Então carregue o @file{dvd.toc}.

@c cincvdoc_node_number_74
@node Áudio MPEG 1
@subsection Áudio MPEG 1
@cindex Áudio MPEG 1

Estes são arquivos .mp2 e .mp3. Se possuírem taxa de bits fixa, eles podem ser carregados diretamente sem nenhuma tabela de conteúdos (TOC). Faixas com taxas de bits variáveis precisam ter uma tabela de conteúdos criada com o mpeg3toc.

@c cincvdoc_node_number_75
@node Ogg Theora/Vorbis
@subsection Ogg Theora/Vorbis
@cindex Ogg Theora/Vorbis

O formato OGG é uma forma antiquada mas supostamente não patenteada de comprimir áudio e vídeo. A qualidade não é tão boa quanto o H.264 ou o áudio MPEG-4. Na realidade, qualquer pessoa com dinheiro e desejo suficiente pode achar uma violação de patente, então a justificativa para o OGG é questionável.

@c cincvdoc_node_number_76
@node Listas de decisões de edição
@subsection Listas de decisões de edição
@cindex EDL

Listas de decisões de edição são geradas pelo Cinelerra para armazenar projetos. Elas possuem como extensão o .xml. Elas mudam os atributos do projeto quando carregadas. Uma vez que listas de decisões de edição consistem em um texto, elas podem ser editadas por um editor de texto.

@c cincvdoc_node_number_77
@node Carregando arquivos
@section Carregando arquivos
@cindex Carregando arquivos
@cindex Arquivos, carregando

Toda informação que você trabalhar com o Cinelerra é adquirida tanto por @b{gravar de um dispositivo} ou por @b{carregar a partir do disco}. Esta seção descreve a opção de carregar arquivos a partir do disco. @*
O carregamento e a reprodução dos arquivos é justo como você poderia esperar. Apenas vá para @b{arquivo->Carregar}, selecione um arquivo para carregar e pressione @b{ok}. Dependendo da configuração da lista da Estratégia de Inserção, seu arquivo ou será carregado na janela de Recursos de mídia ou diretamente na janela de Programa. Neste último caso, clique no botão de reprodução e ele deve começar a ser reproduzido, independentemente de se uma barra de progresso apareceu ou não.

@center @image{manual_images_intl/load, 80mm}
@center @b{A janela de carregar arquivos}

Se o arquivo é uma imagem estática, os atributos do projeto não serão modificados e o primeiro quadro de cada trilha se torna a imagem. Se o arquivo possui áudio, o Cinelerra pode construir um arquivo de índice para ele para aumentar a velocidade de desenho. Você pode editar e reproduzir o arquivo enquanto o arquivo de índice vai sendo criado.

@menu
* Estratégia de inserção::
* Carregando múltiplos arquivos::
* Carregando arquivos a partir de um terminal::
* Filtrando arquivos por extensão::
* Carregando outros formatos::
@end menu

@c cincvdoc_node_number_78
@node Estratégia de inserção
@subsection Estratégia de inserção
@cindex Estratégia de inserção

Normalmente três coisas acontecem quando você carrega um arquivo. 
@enumerate 1
@item o projeto existente é limpado da tela
@item depois, os atributos do projeto são modificados para se ajustarem aos do arquivo
@item as novas trilhas dos arquivos são criadas na Linha do Tempo
@end enumerate
Mas o Cinelerra permite que você mude o que acontece quando você carrega um arquivo. @*
Na janela de diálogo @b{Carregar}, vá para a caixa @b{Estratégia de inserção} e selecione uma das opções do menu. Cada uma das opções carrega o arquivo de uma forma diferente.

@itemize @bullet
@item @b{Substituir projeto atual} @*
Todas as trilhas do projeto atual são apagadas e um conjunto de novas trilhas são criadas para se ajustarem à fonte. Os atributos do projeto só são mudados se um arquivo XML for carregado@. Se múltiplos arquivos forem selecionados para serem carregados, um conjunto de novas trilhas são adicionadas para cada arquivo. Novos recursos são criados na Janela de Recursos, substituindo os atuais.

@item @b{Substituir projeto atual e concatenar trilhas} @*
O mesmo que "substituir projeto atual", exceto que, se múltiplos arquivos forem selecionados, as trilhas de cada arquivo serão concatenadas após a primeira, inserindo diferentes arquivos de fonte no mesmo conjunto de trilhas, um após o outro, em ordem alfanumérica, iniciando do 0. Novos recursos são criados na Janela de Recursos, substituindo os atuais.

@item @b{Adicionar em trilhas novas} @*
O projeto atual não é apagado e novas trilhas são criadas para a fonte, um conjunto de trilhas para cada arquivo. Novos recursos são criados na Janela de Recursos.

@item @b{Concatenar às trilhas existentes} @*
O projeto atual não é apagado e novos arquivos são concatenados nas trilhas armadas existentes, inseridos no mesmo conjunto de trilhas do projeto atual, um após o outro, em ordem alfanumérica, iniciando ao final das trilhas. Se o projeto atual possui mais trilhas do que a fonte, o arquivo de fonte será inserido no primeiro conjunto de trilhas armadas. Caso não haja trilhas armadas, nenhum arquivo será inserido. Novos recursos são criados na Janela de Recursos.

@item @b{Colar no ponto de inserção} @*
O arquivo é inserido na linha do tempo, no ponto de inserção, no primeiro conjunto de trilhas armadas. Caso múltiplos arquivos sejam selecionados para serem carregados, eles serão inseridos no mesmo conjunto de trilhas, um após o outro. Novos recursos são criados na Janela de Recursos.

@item @b{Somente criar novos recursos} @*
A Linha do Tempo não é modificada e novos recursos são criados apenas na Janela de Recursos.
@end itemize

Ao usar essas opções, você consegue fazer praticamente toda a edição carregando os arquivos.@*
A estratégia de inserção é uma opção recorrente em várias funções do Cinelerra. Em cada função, as opções fazem as mesmas coisas. @*
Se você carregar os arquivos passando argumentos de linha de comando ao Cinelerra, os arquivos são carregados com as regras de @b{Substituir projeto atual}.

@c cincvdoc_node_number_79
@node Carregando múltiplos arquivos
@subsection Carregando múltiplos arquivos
@cindex Carregando múltiplos arquivos
@cindex Arquivos, carregando múltiplos

Na caixa de seleção de arquivos, vá para a lista de arquivos. Selecione um arquivo. Vá para outro arquivo e selecione-o enquanto deixa pressionada a tecla @key{CTRL}. Isso faz com que o arquivo adicional seja selecionado. Vá para outro arquivo e selecione-o enquanto mantém a tecla @key{SHIFT} pressionada. Isso selecionará todos os arquivos que estiverem entre os dois. Este comportamento também funciona na maioria das caixas de listas. @*
Use este método e a estratégia de inserção @b{Concatenar às trilhas existentes} para criar um slideshow de imagens ou uma lista de reprodução de músicas.

@c cincvdoc_node_number_80
@node Carregando arquivos a partir de um terminal
@subsection Carregando arquivos a partir de um terminal
@cindex Carregando arquivos a partir de um terminal

Outro meio de carregar arquivos é informar os nomes de arquivos como argumentos por linha de comando. @*
@command{cinelerra meuvideo.mov videodaminhamae.mov} @*
Isso cria novas trilhas para cada arquivo e inicia o programa com todos os argumentos carregados.

@c cincvdoc_node_number_81
@node Filtrando arquivos por extensão
@subsection Filtrando arquivos por extensão
@cindex Filtrando arquivos por extensão
@cindex Arquivos, extensão
@cindex Extensão, arquivos

Caso existam muitos arquivos em sua pasta de mídia, pode ser difícil achar o arquivo que você quer no meio dos outros. Para isso, a @b{janela de carregar arquivos} permite que você filtre quais arquivos são exibidos na lista de acordo com sua extensão. @*
Clique na seta-para-baixo do campo seletor de extensões de arquivos (logo abaixo da caixa de nomes de arquivos) e selecione a extensão do arquivo de sua mídia (por exemplo, mpg, mov, mp3, avi, etc). A lista de arquivos agora mostra apenas arquivos que possuem a extensão selecionada.

@c cincvdoc_node_number_82
@node Carregando outros formatos
@subsection Carregando outros formatos
@cindex Carregando outros formatos

Se você não consegue carregar um tipo particular de vídeo e não possui seu arquivo fonte original, você terá de convertê-lo para um formato suportado pelo Cinelerra. Converter seu arquivo para mpeg2 é uma boa solução, já que o Cinelerra carrega este tipo de arquivo sem nenhum problema. Neste caso, você deve usar o ffmpeg para fazer a conversão. Entretanto, os formatos mpeg2 requerem que o vídeo possua tamanhos de imagem e taxas de quadros específicos:
@itemize @bullet
@item @b{PAL} é 720x576 a 25 fps
@item @b{NTSC} é 720x480 a 29.97 (=30000/1001) fps
@end itemize
Para arquivos de entrada que não possuam essas propriedades, você deve usar o mencoder para convertê-los para MPEG4@. Você pode identificar os codecs e o container de qualquer vídeo usando o comando:@*
@command{mplayer -identify <seu_arquivo_de_vídeo.xyz>}

@itemize @bullet
@item @b{Convertendo com o ffmpeg:}@*
@command{ffmpeg -sameq -i vídeo_original.xyz vídeo_convertido.mpeg}@*
A opção @option{-sameq} mantém a qualidade original.

@item @b{Convertendo com o mencoder:}@*
@command{mencoder vídeo_original.xyz -ovc lavc -lavcopts vcodec=mpeg4:\}@*
@command{vhq:vbitrate=6000 -oac mp3lame -lameopts br=256:vol=1 \}@*
@command{-ffourcc DIVX -o vídeo_convertido.avi}
@end itemize

@c cincvdoc_node_number_83
@node Carregando o backup
@section Carregando o backup
@cindex Carregando o backup
@cindex Backup, carregando o

Existe um arquivo XML especial no disco rígido a todo momento. Após cada operação de edição, o Cinelerra salva o projeto atual para um arquivo de backup em @file{$HOME/.bcast/backup.xml}. Caso o programa dê algum pau, vá para @b{arquivo->carregar backup} para carregar o backup. É importante após um pau (o programa fechar) reiniciar o Cinelerra sem fazer nenhuma outra operação de edição. Carregar o backup deve ser a primeira operação, ou você sobrescreverá o arquivo.

@c cincvdoc_node_number_84
@node Salvando arquivos de projeto
@section Salvando arquivos de projeto
@cindex Salvando arquivos de projeto
@cindex Arquivos de projeto, salvando
@cindex Arquivos, salvando
@cindex Arquivos, XML
@cindex Arquivos XML

O Cinelerra salva projetos como arquivos XML. Vá para @b{Arquivo->salvar como...}. Selecione um arquivo para ser sobrescrito ou informe um novo nome de arquivo. O Cinelerra automaticamente concatenará o @samp{.xml} ao nome de arquivo caso uma extensão @samp{.xml} não seja dada.

Quando o Cinelerra salva um arquivo, ele salva uma lista de decisões de edição (EDL) do projeto atual, mas não salva nenhuma mídia. O arquivo consiste em um texto. Ele contém todas as configurações do projeto e localizações de cada recorte, mas ao invés de mídia, ele contém apontadores para os arquivos originais de mídia no disco rígido.

Para cada arquivo de mídia, o arquivo XML grava ou um caminho completo ou apenas um caminho relativo a ele. Se a mídia estiver no mesmo diretório do arquivo XML, um caminho relativo será salvo. Se ela estiver em uma pasta diferente, um caminho completo será salvo.

Você deve ter cuidado quando movimentar seus arquivos por aí: você está se arriscando a quebrar as ligações de mídia. Você pode manter as mídias e o arquivo XML na mesma pasta para sempre e mover livremente toda a pasta, uma vez que os caminhos relativos serão salvos. De um modo alternativo, você pode salvar o arquivo XML em uma pasta diferente das de mídia, mas não poderá mover as mídias nunca mais. Neste caso, você poderá mover seu arquivo XML por aí livremente, já que os caminhos absolutos estão salvos. Se você salvou o seu projeto XML na mesma pasta que suas mídias mas gostaria de movê-lo para outro lugar, você pode modificar os caminhos de relativos para absolutos indo em @b{Arquivo->Salvar como...} e informar a nova localização.

Se você quiser criar uma lista de reprodução de áudio e queimá-la em um CD-ROM, salve o arquivo XML na mesma pasta dos arquivos de áudio e queime todo o diretório. Isso manterá os caminhos de mídia relativos.

Deve ser dito que, sendo o arquivo XML um arquivo de texto, você sempre poderá reparar as ligações quebradas de mídia editando o arquivo XML em um editor de texto. Para cada mídia que você moveu, busque o caminho antigo e substitua-o pelo atual. Não esqueça de fazer uma cópia de backup de seu arquivo XML antes de fazer qualquer edição!

Os arquivos XML são úteis para salvar o estado atual do Cinelerra antes de sair de uma sessão de edição.@*
Os arquivos XML são específicos do Cinelerra. Você não conseguirá 'tocar' arquivos XML em um reprodutor de vídeos. @* 
Efeitos tempo-real em um arquivo XML devem ser re-sintetizados a cada vez que você os reproduzir.@*
O arquivo XML também requere que você mantenha cópias de todas as suas fontes no disco rígido, o que pode ocupar espaço e custar bastante eletricidade para rodar. Para um armazenamento mais persistente da saída, existe o render.

@c cincvdoc_node_number_85
@node Fundindo projetos
@section Fundindo projetos
@cindex Fundindo projetos

Para fundir vários projetos separados em um grande projeto:
@enumerate 1
@item Abra o Cinelerra
@item Carregue o projeto A
@item Abra um segundo Cinelerra
@item Carregue o projeto B
@item Recorte e cole de A para B
@end enumerate

@c cincvdoc_node_number_86
@node Janela de Programa
@chapter Janela de Programa
@cindex Janela de Programa

@menu
* Navegando na janela de programa::
@end menu

Esta janela contém a Linha do Tempo e o ponto de entrada para todas as operações baseadas em menu. A Linha do Tempo consiste em um conjunto vertical de trilhas com representação horizontal de tempo. Define a saída das operações de render e o que é salvo quando você salva arquivos. À esquerda de Linha do Tempo está o patchbay, que contém opções que afetam cada trilha.

@center @image{manual_images_intl/program_insertion_point,120mm}
@center @b{A linha do tempo}

Abaixo da @b{Janela} de menu, você encontrará operações que afetam as janelas principais. A opção @b{posições padrão} reposiciona todas as janelas para uma configuração de edição em quatro janelas. Em configurações com dois monitores, a operação @b{posições padrão} preenche apenas um monitor com janelas.

@c cincvdoc_node_number_87
@node Navegando na janela de programa
@section Navegando na janela de programa
@cindex Navegando na janela de programa
@cindex Janela de programa

A janela de programa contém várias funções para navegação e exibe a Linha do Tempo conforme está estruturada na memória: trilhas juntas verticalmente e se extendendo por sobre o tempo na forma horizontal. A barra de rolagem horizontal permite que você busque pelo tempo. A barra de rolagem vertical permite que você busque pelas trilhas.

@menu
* Trilhas de vídeo e áudio::
* Navegação por trilhas::
* O painel de aproximação::
* O menu relacionado às trilhas::
* O ponto de inserção::
* Modos de edição::
* Os pontos de entrada/saída::
* Usando marcadores na janela de programa::
@end menu

@c cincvdoc_node_number_88
@node Trilhas de vídeo e áudio
@subsection Trilhas de vídeo e áudio
@cindex Trilhas de vídeo
@cindex Trilhas de áudio
@cindex Trilhas, vídeo e áudio

@center @image{manual_images_intl/track_video,120mm}
@center @b{Uma trilha de vídeo}

Trilhas de vídeo representam a Linha do Tempo de seus vídeos, como se você efetivamente despusesse um filme fotográfico real horizontalmente em uma mesa. As imagens individuais que você vê na trilha são uma amostra do que está localizado naquele momento particular da Linha do Tempo.

@center @image{manual_images_intl/track_audio,120mm}
@center @b{Uma trilha de áudio}

Trilhas de áudio representam a sua mídia de áudio como uma onda sonora; seguindo a analogia do filme, seria como se você "visse" a fita magnética horizontalmente na sua mesa.
Você pode ajustar o aumento ou diminuição vertical ou horizontal das trilhas e da exibição da "onda sonora" usando os controles da @b{barra de aproximação de painel}. @*
Cada trilha na linha do tempo possui um conjunto de atributos à esquerda, chamado de @b{patch bay}. Eles é usado para controlar o comportamento das trilhas. O atributo mais importante é o de @b{armar trilha}.

@c cincvdoc_node_number_90
@node Navegação por trilhas
@subsection Navegação por trilhas
@cindex Navegação por trilhas

A navegação por trilhas envolve tanto chegar a uma trilha específica (áudio ou vídeo) quanto chegar a um certo momento no tempo da trilha. A janela de programa contém várias funções para navegação e exibe a Linha do Tempo conforme ela está estruturada na memória.

A barra de rolagem horizontal permite que você faça buscas pelo tempo. Para rolagem vertical, você também pode usar a rodinha do mouse.

A barra de rolagem horizontal permite que você busque pelo tempo. Para rolagem horizontal você também pode usar a rodinha do mouse com a tecla @key{CTRL} pressionada.

Além das ferramentas gráficas, você provavelmente vai usar mais o teclado para navegar. Use @key{PAGE UP} e @key{PAGE DOWN} para rolar para cima e para baixo nas trilhas.

Você freqüentemente terá de rolar para além do final da Linha do Tempo, mas as barras de rolagem não permitirão que você faça isso. Ao invés, use a SETA-PARA-A-DIREITA para rolar para além do final da linha do tempo.

Use as teclas @key{HOME} e @key{END} para chegar instantaneamente para o início ou final da linha do tempo. No modo @b{barra}, mantenha a tecla @key{SHIFT} pressionada enquanto pressiona o @key{HOME} ou @key{END} para selecionar a região da linha do tempo entre o ponto de inserção e a tecla pressionada.

@c cincvdoc_node_number_352
@node O painel de aproximação
@subsection O painel de aproximação
@cindex Painel de aproximação

Abaixo da linha do tempo, você encontrará o painel de aproximação. O painel de aproximação contém valores para @b{aproximação de amostra} (duração visível na linha do tempo), @b{amplitude} (escala da onda sonora), @b{aproximação de trilha} (altura das trilhas na linha do tempo), e @b{aproximação de curva} (abrangência da automação).  Em adição às barras de rolagem, essas aproximações são as ferramentas principais para posicionar a linha do tempo.

@center @image{manual_images_en/zoompanel,100mm}

@cindex Aproximação de amostra
Mudar o @b{aproximação de amostra} faz mudar a quantidade de tempo visível. Isso permite que você veja sua mídia desde a partir de uma configuração quadro a quadro quanto uma disposição completa de toda a linha do tempo. Quanto mais alta a configuração, mais quadros você poderá ver por tela. @*
Use as setas @kbd{PARA-CIMA} e @kbd{PARA-BAIXO} para mudar a aproximação de amostra por uma razão de dois.@*
@b{Caso seu mouse possua uma rodinha e ela funciona no X11, vá para as pré-vizualizações em miniatura e use a rodinha para aproximar ou afastar.}

@cindex Amplitude
A @b{amplitude} afetará apenas o áudio. Ela determina quão grande será a onda sonora. @*
@kbd{CTRL-PARACIMA} e @kbd{CTRL-PARABAIXO} fazem a aproximação de amostra mudar.

@cindex Aproximação de trilha
A @b{aproximação de trilha} afeta todas as trilhas. Ela determina a altura de cada trilha. Se você mudar a aproximação da trilha, a aproximação de amplitude será compensada, de forma que as ondas sonoras pareçam proporcionais. @*
@kbd{CTRL-PGUP} e @kbd{CTRL-PGDOWN} fazem a aproximação de trilha mudar.

@cindex Aproximação de curvas
A @b{Aproximação de curvas} afeta as curvas em todas as trilhas do mesmo tipo. Ela determina a abrangência de valor para as curvas. Primeiro selecione o tipo de automação (fade de áudio, fade de vídeo, aproximação, X ou Y) e então use os valores à esquerda como mínimos e os da direita como máximos; ou informe manualmente os valores na caixa de texto. Normalmente, você usará -40.0 a 6.0 para fade de áudio e 0.0 a 100.0 para fade de vídeo. @xref{O patchbay}.@*
Esses valores mudam a amplitude da curva, mas o único modo de deslocar as curvas é usar o botão @b{Enquadrar autos à exibição}.
@image{manual_images_intl/fit_curves}.@*
@kbd{ALT-PARACIMA} e @kbd{ALT-PARABAIXO} fazem a amplitude de curvas mudar.

@c cincvdoc_node_number_91
@node O menu relacionado às trilhas
@subsection O menu relacionado às trilhas
@cindex O menu relacionado às trilhas

Cada trilha possui um menu relacionado a ela. Para ativar o @b{menu da trilha}, clique com o botão direito do mouse na trilha (o menu relacionado afeta a trilha caso ela esteja armada no @b{patch bay} ou não). O menu de trilha contém um número de opções para lidar com várias trilhas simultaneamente:
@itemize @bullet
@item Adicionar efeito
@item Mover para cima move a trilha selecionada um passo acima no conjunto.
@item Mover para baixo move a trilha selecionada um passo abaixo no conjunto.
@item Apagar trilha remove a trilha da linha do tempo.
@item Adicionar trilha adiciona uma trilha do mesmo tipo de mídia (áudio/vídeo) a partir do qual o menu foi ativado.
@item Redimensionar trilha redimensiona a trilha.
@item Ajustar ao Tamanho de Saída redimensiona a trilha para se ajustar ao tamanho de saída atual.
@end itemize

@c cincvdoc_node_number_92
@node O ponto de inserção
@subsection O ponto de inserção
@cindex O ponto de inserção

O ponto de inserção é esse fio branco piscante que aparece se estendendo verticalmente na linha do tempo. Análogo ao cursor de seu editor de texto, o ponto de inserção marca o lugar na linha do tempo onde a próxima atividade do programa será iniciada. É o ponto onde ocorre uma operação de colar. Quando se renderiza um arquivo, ele define o início da região da linha do tempo a ser renderizada. Ele também é o ponto de início de todas as operações de reprodução.

@center @image{manual_images_intl/program_insertion_point,100mm}
@center @b{O ponto de inserção na janela principal,}
@center @b{representado como um fio branco vertical no ponto 00:00.500}

O ponto de inserção normalmente é movido ao se clicar no interior da barra de tempo principal. Qualquer região da linha do tempo não obscurecida por marcadores e pontos de entrada ou saída é uma região válida para se reposicionar o ponto de inserção. No modo de recortar e colar somente, o ponto de inserção também pode ser movido ao se clicar na linha do tempo.

@center @image{manual_images_intl/main_timebar,160mm}
@center @b{A barra de tempo principal}

Quando se move o ponto de inserção, a posição será ou alinhada aos quadros ou alinhada às amostragens ("samples"). Quando se edita um vídeo, é melhor alinhá-lo aos quadros. Quando se edita um áudio, é melhor alinhá-lo às amostragens. Selecione sua preferência em @b{Configurações->Alinhar cursor aos quadros}.

@c cincvdoc_node_number_353
@node Modos de edição
@subsection Modos de edição
@cindex Modos de edição
@cindex Edição, modos

Modos de edição são dois métodos diferentes de operação que afetam o ponto de inserção e a edição na linha do tempo.@*
São eles:@*
@itemize @bullet
@item modo de arrastar e soltar
@item modo de recortar e colar
@end itemize

O modo de funcionamento é determinado ao se selecionar a seta ou a barra ("i-beam") na barra de botões. Alternativamente, você pode usar a tecla @key{e} como um atalho de teclado para alternar entre os modos.

@center @image{manual_images_intl/editing_mode,15mm}
@center @b{Os botões do modo de edição}

@cindex Modo de arrastar e soltar
Se a seta estiver selecionada, ela habilita o modo @b{arrastar e soltar}. @*
No modo arrastar e soltar, clicar na linha do tempo não reposiciona o ponto de inserção. @*
Um duplo-clique na linha do tempo seleciona todo o bloco de edição em cima do qual o mouse estiver posicionado. @* 
Arrastar na linha do tempo reposiciona o bloco de edição para onde o apontador do mouse estiver passando. Isto é útil para reordenar as listas de reprodução de áudio, ordenar cenas de vídeos, mover efeitos por aí.@*
Para recortar e colar no modo de arrastar e soltar, você precisa marcar @b{pontos de entrada/saída} para definir uma região a ser afetada. @xref{Os pontos de entrada/saída}. @*
@xref{Edição de arrastar e soltar}. 

@cindex Modo de recortar e colar
Se a barra ("i-beam") estiver selecionada, ela habilita o @b{modo recortar e colar}. @*
No modo de recortar e colar, clicar na linha do tempo reposiciona o ponto de inserção. @*
Dar um duplo-clique na linha do tempo seleciona todo o bloco de edição por sobre o qual o cursor estiver sobre. @*
Arrastar na linha do tempo seleciona uma região. A região em destaque se torna a região afetada pelas operações de recortar e colar e a abrangência da reprodução durante a próxima operação de exibição. Clicar com a tecla @key{SHIFT} pressionada na linha do tempo estende a região em destaque.

@center @image{manual_images_intl/program_highlight,100mm}
@center @b{Trilhas com área destacada, mostradas dentro do contorno verde}

Quando se destaca uma região, os pontos de início e fim são ou alinhados aos quadros ou a amostras. Quando você estiver editando vídeo, você provavelmente vai querer que este alinhamento seja feito aos quadros. Quando editar áudio, você quererá alinhá-los a amostras. Isso pode ser configurado em @b{configurações->Alinhar cursor aos quadros}. @*
@xref{Edição de recortar e colar}.

@anchor{r943_r944_modos_de_edição}@b{Observação:} As revisões do Cinelerra CV 943 e 944 (checkouts do SVN de 19 a 21 de outubro de 2006) não possuíam botões de modos de edição. Os modos de ediçaõ "Copiar e colar" e "Arrastar e soltar" estavam unidos em um só, sendo a tecla shift a diferenciação entre eles. Este é o caso do ebuild do Gentoo media-video/cinelerra-cvs-20061020.

@c cincvdoc_node_number_93
@node Os pontos de entrada/saída
@subsection Os pontos de entrada/saída
@cindex Pontos de entrada/saída

Em ambos os modos de edição, você pode marcar pontos de entrada e saída. Os pontos de entrada/saída definem a região afetada. No modo arrastar e soltar, eles são o único meio de definir uma região afetada. Nos dois modos, de recortar e colar e arrastar e soltar, a área em destaque sobrescreve os pontos de entrada/saída. Se uma área em destaque e pontos de entrada/saída estiverem marcados, a área selecionada é afetada pelas operações de edição e os pontos de entrada/saída são ignorados. Se nenhuma região estiver em destaque, os pontos de entrada/saída são usados.

Normalmente, os pontos de entrada/saída não afetam a região de reprodução. Apenas se você manter a tecla @key{CTRL} pressionada enquanto envia um comando de reprodução é que os pontos de entrada/saída determinam a região de reprodução.

Para marcar os pontos de entrada/saída, vá para a barra de tempo e posicione o ponto de inserção em algum lugar. Pressione o @image{manual_images_intl/in_point_button,5mm} @b{botão de ponto de entrada}. Mova o ponto de inserção para uma posição depois do ponto de entrada e pressione o @image{manual_images_intl/out_point_button,5mm} @b{botão do ponto de saída}.

@center @image{manual_images_intl/inout_points,160mm}
@center @b{Barra de tempo com pontos de entrada/saída marcados}.

Se você selecionar o ponto de entrada ou o ponto de saída, o ponto de inserção pulará para aquela localização. Depois de selecionar um ponto de entrada, se você pressionar o @b{botão de ponto de entrada}, o ponto de entrada será apagado. Depois de selecionar um ponto de saída, se você pressionar o @b{botão de ponto de saída}, o ponto de saída será apagado. 

@b{Dica:} Para se livrar rapidamente dos pontos de entrada/saída, sem se preocupar onde eles estão ou se eles estão marcados ou não, simplesmente dê um duplo-clique nos botões [ e ]. O primeiro clique posicionará um novo ponto ou reposicionará um existente no ponto de inserção; o segundo clique o apagará. Obviamente, este truque não funcionará se o ponto de entrada ou de saída já estiverem marcados no ponto de inserção.

Se você selecionar uma região em algum outro lugar quando pontos de entrada/saída já existirem, os pontos existentes serão reposicionados quando você clicar nos botões de entrada/saída.

Clicar deixando o @key{SHIFT} pressionado em um ponto de entrada/saída destaca a região entre o ponto de inserção e aquele ponto de entrada/saída.

Ao invés de usar a barra de botões, você pode usar as teclas @key{[} e @key{]} para inserir/retirar pontos de entrada/saída.

Em ambos os modos de recortar e colar quanto de arrastar e soltar, pontos de entrada/saída sobrescrevem a área em destaque. Se uma área em destaque e pontos de entrada/saída estiverem marcados, a área em destaque afeta a reprodução enquanto os pontos de entrada/saída afetam operações de edição. Para evitar confusão, é melhor usar ou o método de deixar em destaque ou os pontos de entrada/saída, mas não ambos simultaneamente.

O ponto de inserção e os pontos de entrada/saída permitem que você defina uma região afetada mas eles não permitem que você salte para pontos exatos na linha do tempo tão facilmente. Para essa função, use os marcadores.

@c cincvdoc_node_number_94
@node Usando marcadores na janela de programa
@subsection Usando marcadores na janela de programa
@cindex Marcadores, usando na janela de programa

Marcadores são um jeito fácil de marcar localizações exatas na linha do tempo para onde você quer chegar. Quando você posiciona um ponto de inserção em algum lugar e pressiona o @image{manual_images_intl/label_button,5mm} @b{botão de marcador}, um novo marcador aparece na linha do tempo.

@center @image{manual_images_intl/timebar_label,160mm}
@center @b{Barra do tempo com um marcador nela}

Independentemente de quais forem as configurações de aproximação, clicar no marcador o coloca em evidência e posiciona o ponto de inserção exatamente onde você havia colocado o marcador. Apertar o botão de marcador novamente quando um marcador estiver selecionado remove-o.

Marcadores podem reposicionar o ponto de inserção quando forem selecionados, mas também pode haver uma navegação entre eles com os botões de @image{manual_images_intl/label_traversal,15mm} @b{marcador traversal}. Quando um marcador estiver fora de visão, os botões de movimentação entre marcadores reposicionam a linha do tempo de modo que o marcador fique visível. Há atalhos de teclado para movimentação entre marcadores também.

@kbd{CTRL-ESQUERDA} reposiciona o ponto de inserção no marcador anterior.

@kbd{CTRL-DIREITA} reposiciona o ponto de inserção no próximo marcador.

Com a movimentação entre marcadores, você pode rapidamente buscar pontos anteriores e posteriores na linha do tempo, mas você também pode selecionar regiões.

@kbd{SHIFT-CTRL-ESQUERDA} destaca a região entre o ponto de inserção e o marcador anterior.

@kbd{SHIFT-CTRL-DIREITA} destaca a região entre o ponto de inserção e o próximo marcador.

Um @b{duplo-clique} na barra de tempo entre dois marcadores evidencia a região entre os marcadores.

Clicar com o @b{SHIFT} em um marcador coloca em evidência a região entre aquele marcador e o ponto de inserção. Se uma região já estiver em destaque, isso estenderá a região em evidência para até aquele marcador.

Se você pressionar o botão de marcador quando uma região estiver em evidência, os marcadores serão criados ao final de cada região em destaque. Entretanto, se um final já tiver um marcador, então o marcador existente será apagado.

Pressionar o botão de marcador novamente quando um marcador estiver selecionado o apaga.
Pressionar o botão de marcador manualmente ou a tecla @key{l} de novo e de novo para apagar uma série de marcadores pode ser bastante tedioso. Para apagar um conjunto de marcadores, primeiro selecione a região e depois use a função @b{Editar...->Limpar marcadores}. Se pontos de entrada/saída existirem, os marcadores entre os pontos de entrada/saída serão limpos e a região destacada ignorada.

Apenas no modo de edição @b{Recortar e Colar}, ao habilitar "Editar marcadores" no menu de configurações, ou ao desabilitar o botão @image{manual_images_intl/locklabels_unlocked,5mm} @b{"Lock labels from moving"} na barra de ferramentas do programa, os marcadores serão recortados, copiados ou colados ao londo da área selecionada da primeira trilha armada. @*
De forma similar, se uma área selecionada de um recurso for dividida do Visor para a linha do tempo em uma posição antes dos marcadores, estes marcadores serão empurrados para a direita na linha do tempo conforme a duração da área selecionada. @*
Para manter presos os marcadores em suas posições na barra de tempo, desabilite a opção "Editar marcadores" ou habilite o botão @image{manual_images_intl/locklabels_unlocked,5mm} @b{"Impedir marcadores de se mover"}. @*
No modo de edição @b{Arrastar e soltar}, os marcadores sempre ficarão presos à barra de tempo, mesmo com a opção "Editar marcadores" habilitada.

@c cincvdoc_node_number_95
@node Editando
@chapter Editando
@cindex Editando

Editar envolve tanto o domínio das trilhas quanto do tempo. Uma vez que a linha do tempo consiste em um conjunto de trilhas, você precisa se preocupar em como criar e ordenar trilhas além de quando certas mídias aparecem em uma trilha.

No domínio de tempo, o Cinelerra oferece muitas abordagens para o processo de edição. Os três métodos principais são edição com dois monitores, edição de arrastar e soltar e edição de recortar e colar.

Há vários conceitos que o Cinelerra usa quando edita que se aplicam a todos os métodos. 

A @b{linha do tempo} é onde todas as decisões de edição são representadas. Ela é um conjunto de trilhas no meio da janela principal. Ela pode ser rolada para cima e para baixo, esquerda e direita com as barras de rolagem à direita e abaixo dela. Ela também pode ser rolada para cima e para baixo com a rodinha do mouse, ou para a esquerda e direita, com a rodinha do mouse e a tecla @key{CTRL}.

A @b{região ativa} é a abrangência de tempo que será afetada pelos comandos de edição na linha do tempo. A região ativa é determinada primeiro pela presença de pontos de entrada/saída na linha do tempo. Caso eles não existam, a área em destaque será usada. Caso não exista uma área destacada, o ponto de inserção será usado como o início da região ativa. Alguns comandos tratam todo o espaço à direita do ponto de inserção como ativo enquanto outros tratam a abrangência ativa como 0 se nenhum ponto de término para a região ativa for definido.

Finalmente, decisões de edição nunca afetam o material fonte. Isso chama-se @b{edição não-destrutiva} e tornou-se popular com o áudio porque era muito mais rápida do que se você tivesse que copiar toda a mídia afetada por uma edição. Editar afeta apenas apontadores para o material fonte, então se você quiser ter um arquivo de mídia ao final de sua sessão de edição que represente suas decisões de edição, você precisa fazer um @b{render}.  @xref{Renderizando arquivos}. @xref{Salvando arquivos de projeto}.

@menu
* O patchbay::                   	Habilitando diferentes funções em trilhas diferentes
* Empurrando trilhas::           	Mudando trilhas inteiras horizontalmente
* Fazendo um pan nas trilhas de áudio:: Mudando os canais de saída de áudio
* Pan automático de trilhas de áudio::  Fazendo um pan nas trilhas para configurações comuns de falantes
* Mapeamentos padrão de áudio::  	Fazendo um pan de áudio que funcione em outros reprodutores
* Manipulando trilhas::          	Movendo trilhas inteiras por aí
* Edição em duas janelas::       	Usando duas janelas de vídeo para editar
* Edição de arrastar e soltar::  	Arrastando objetos para editar
* Edição de recortar e colar::   	Editando mídia como texto
* Redimensionando ("trimming"):: 	Mudando pontos as bordas dos blocos de edição
@end menu

@c cincvdoc_node_number_96
@node O patchbay
@section O patchbay
@cindex Patchbay

À esquerda de linha do tempo está uma região afetuosamente conhecida como o patchbay. O patchbay habilita funções específicas para cada trilha. 

Todas as trilhas têm uma @b{área de texto} para nomear a trilha.

Todas as trilhas possuem um @b{expandidor} @image{manual_images_intl/expandpatch_checked,5mm} para ver mais opções no patchbay e para ver os efeitos representados na trilha. Clique na seta para expandir ou encolher o patchbay e a trilha. Caso esteja apontando para o lado, a trilha está encolhida. Caso esteja apontando para baixo, a trilha está expandida. Efeitos existentes aparecem abaixo da mídia daquela trilha, caso existam.

Todas as trilhas possuem a seguinte lista de habilitações para várias funções.

@center @image{manual_images_en/track_attributes}
@center @b{Atributos de trilha}

Se o botão que habilita a função estiver colorido, a função estará habilitada. Se ele estiver com a mesma cor do fundo da maioria das janelas, ele está desabilitado. Clique no botão para habilitar ou desabilitar a função. Várias operações de mouse aceleram a configuração de várias trilhas ao mesmo tempo.

Clique em um atributo e arraste o cursor por trilhas adjacentes para copiar o mesmo atributo para essas trilhas.

Mantenha o @key{SHIFT} pressionado enquanto clica em um atributo de uma trilha para habilitá-lo na trilha atual e desabilitá-lo em todas as outras trilhas.

Mantenha o @key{SHIFT} pressionado enquanto clica em um atributo. Clique até que todas as outras trilhas que não a selecionada estejam desabilitadas. Arraste então o cursor por sobre a trilha adjacente para habilitar o atributo na trilha adjacente.

Atributos que afetam a saída da trilha:
@cindex Reproduzir trilha
@itemize @bullet
@item @b{Reproduzir trilha} @*
Determina se a trilha será renderizada ou não. Se estiver desligado, a trilha não será renderizada. Por exemplo, se você desligá-lo em todas as trilhas de vídeo, a mídia renderizada terá apenas trilhas de áudio. Entretanto, se a trilha estiver amarrada ("chained") a outras trilhas por meio de um efeito compartilhado, as outras trilhas executarão todos os efeitos nesta trilha amarrada, independentemente do status de reprodução da trilha amarrada, que neste caso em particular afeta a saída de mídia mas não os fades ou efeitos. @xref{Tipos de efeitos tempo-real}.

@cindex Armar trilha
@item @b{Armar trilha} @*
Determina se a trilha está armada ou não. Apenas as trilhas armadas são afetadas por operações de edição. Assegure-se de ter trilhas de destino armadas o suficiente quando for colar ou dividir material ou algumas trilhas do projeto ficarão de fora. @*
Além de restringir operações de edição, as trilhas armadas em combinação com a região ativa determinam onde o material será inserido quando arquivos forem carregados. Se os arquivos forem carregados com uma das estratégias de inserção que não apagam o projeto atual, as trilhas armadas serão usadas como destino. @*
Pressione @key{TAB} enquanto o cursor estiver em qualquer lugar por sobre uma trilha para armar ou desarmar aquela trilha. @*
Pressione @kbd{SHIFT-TAB} enquanto o cursor estiver por sobre uma trilha para mudar o status de armação de todas as outras trilhas.

@cindex Fader grupal
@item @b{Fader grupal} @*
Faz o fader rastrear o movimento de quaisquer outros faders que você estiver ajustando arrastando ou o fader ou a curva na trilha. Isso não afeta a edição feita com controles de menu. Um fader só será agrupado - estar relacionado a outros faders - se a função @b{armar trilha} também estiver ligada. Isso normalmente é usado para ajustar os níveis de áudio de todas as trilhas simultaneamente. Agrupar também faz com que os parâmetros de @b{Deslocar} sejam sincronizados por todas as trilhas agrupadas.

@cindex Desenhar mídia
@item @b{Desenhar mídia} @*
Determina se haverá pré-visualização de ícones e ondas sonoras na trilha. Por padrão, alguns formatos de arquivos são carregados com esta função desligada enquanto outros formatos carregam com ela habilitada. Isso dependerá de se o formato de arquivo leva muito tempo para ser desenhado na linha do tempo. Apenas ajuste-o para 'habilitado' se você quer ver a pré-visualização para qualquer tipo de formato.

@cindex Mutar trilha
@item @b{Mutar trilha} @*
Faz com que a saída seja descartada quando a trilha estiver completamente renderizada. Isso acontece independentemente de se a função @b{reproduzir trilha} estiver ou não ligada. Por exemplo, se você mutar todas as trilhas de vídeo, a mídia renderizada possuirá uma trilha de vídeo em branco. Se uma trilha for parte de uma trilha com efeito compartilhado, a saída da trilha com o efeito compartilhado de trilha será sobreposta na saída final, mesmo sendo roteada de volta para outra trilha (a trilha compartilhada). 
Mutar trilha é usado para evitar que a trilha com o efeito compartilhado de trilha se sobreponha à saída da trilha de origem (a trilha compartilhada), onde o efeito de compartilhamento de trilha não está presente. @xref{Tipos de efeitos tempo-real}.

@cindex Fader
@item @b{Fader} @*
Todas as trilhas possuem um fader, mas as unidades de cada fader dependem de se ele é relacionado a um áudio ou a um vídeo. @*
Valores de fade de áudio estão em dB. Eles representam níveis relativos, onde o 0 é o nível de som original não alterado, -40 é silêncio, -80 o valor mínimo configurado por padrão. Você pode mover os faders e os quadros-chave para abaixo de -80, mas a curva dos parâmetros não passará de -40. Para a sua conveniência, você pode configurar uma abrangência de fader diferente com a aproximação de curva. @xref{O painel de aproximação}. O propósito principal dos faders de áudio é o de esvanecer o com ou abaixar seu volume suavemente até o silêncio, ou fazê-lo aparecer suavemente ao invés de abruptamente. @*
Os valores de fade de vídeo são a porcentagem da opacidade da imagem no modo de sobreposição normal, a porcetagem da camada que for mixada na fila ("pipeline") de renderização nos outros modos de sobreposição. @xref{Modos de sobreposição}. @*
Clique e arraste o fader para reduzir ou aumentar a saída (de imagem ou de som). Se ele estiver agrupado a outras trilhas do mesmo tipo de mídia com a função @b{armar} habilitada, os outros faders devem segui-lo. Mantenha o @key{SHIFT} pressionado e arraste um fader para centralizá-lo em seu valor original (0 para áudio, 100 para vídeo).
@end itemize

@c cincvdoc_node_number_97
@node Empurrando trilhas
@section Empurrando trilhas
@cindex Empurrando trilhas
@cindex Trilhas, empurrando

Cada trilha possui uma caixa de texto de deslocamento ("nudge") em seu patchbay. Você deve ter que expandir a trilha para vê-la. Essas são as imagens do patchbays quando expandido.

@center @image{manual_images_en/apatches}
@center @b{Fazendo panorâmica e deslocamento para uma trilha de áudio}

@center @image{manual_images_en/vpatches}
@center @b{Modo de sobreposição e deslocamento para uma trilha de vídeo}

O valor do deslocamento ("nudge") é o quanto a trilha é empurrada para a esquerda ou direita durante a reprodução. A trilha não é disposta deslocada na linha do tempo, mas é deslocada quando é reproduzida. Isso é útil para sincronizar áudio com vídeo, criar um falso estéreo ou compensar um efeito que modifica o tempo, tudo sem modificar os blocos de edição.

Apenas informe a quantidade de tempo para ser deslocada para deslocar imediatamente a trilha. Números negativos fazem a trilha ser reproduzida com atraso. Números positivos fazem com que seja reproduzida com antecedência. As unidades de deslocamento ("nudge") são tanto @b{segundos} ou as unidades nativas para a trilha (@b{quadros} ou @b{amostragem}). Selecione as unidades @b{clicando com o botão direito do mouse} na caixa de texto de deslocamento e selecione a partir do menu.

Configurações de deslocamento são agrupadas com a função @b{Agrupar faders} e a função @b{Armar trilha}.

Use a rodinha do mouse por sobre a caixa de texto de deslocamento para aumentar ou diminuir o número ali.

@c cincvdoc_node_number_98
@node Fazendo um pan nas trilhas de áudio
@section Fazendo um pan nas trilhas de áudio
@cindex Fazendo um pan nas trilhas de áudio
@cindex Trilhas, fazendo pan
@cindex Trilhas de áudio, fazendo pan

Trilhas de áudio possuem uma caixa de pan em seu patchbay. Você pode ter que expandir a trilha para vê-la. A caixa de pan é mostrada aqui.

@center @image{manual_images_en/apatches}
@center @b{Fazendo panorâmica e deslocamento para uma trilha de áudio}

Posicione o apontador na caixa de pan e clique/arraste-o para reposicionar a saída de áudio conforme o arranjo dos falantes. A altura de cada falante é impressa em seu ícone respectivo durante a operação de arraste. A caixa de pan usa um algoritmo especial para tentar permitir que o áudio seja focado através de um falante ou dividido entre os falantes mais próximos quando mais de 2 falantes estiverem sendo usados.

@c cincvdoc_node_number_99
@node Pan automático de trilhas de áudio
@section Pan automático de trilhas de áudio
@cindex Pan de trilhas, automático
@cindex Pan de trilhas de áudio, automático

Várias funções de conveniência são dadas para configurar automaticamente o pan para vários padrões comuns. Elas estão listadas no menu de @b{Áudio}. Estas funções afetam apenas as trilhas de áudio armadas. Elas são:

@itemize @bullet
@item @b{Áudio->Mapear 1:1} @*
Mapeia cada trilha para seu próprio canal e espera ("wraps around") até que todos os canais sejam alocados. É útil principalmente para fazer 2 trilhas com 2 canais mapearem para estéreo e para fazer 6 trilhas com 6 canais mapearem para uma placa de áudio de 6 canais.

@item @b{Áudio->Mapear 5.1:2} @*
Mapeia 6 trilhas para 2 canais. O projeto deve ter 2 canais quando esta função for usada. Vá para @b{Configurações->formato} para configurar a saída dos canais para 2. Isso é útil principalmente para fazer um down-mix de áudio 5.1 para estéreo.
@end itemize
@xref{Atributos de áudio}.

@c cincvdoc_node_number_100
@node Mapeamentos padrão de áudio
@section Mapeamentos padrão de áudio
@cindex Mapeamentos padrão de áudio
@cindex Mapeamentos de áudio, padrão

Embora o Cinelerra permita que você mapeie qualquer trilha de áudio para qualquer falante, existem mapeamentos padrão que você pode usar para ter certeza de que a mídia possa ser reproduzida em outros lugares. Além disso, a maioria dos transcodificadores de áudio requerem que as trilhas de áudio sejam mapeadas para números padrão de falantes ou elas não funcionarão.

@cindex Posição do canal
@cindex Posição, canal
Na opção @b{Posições dos canais} de @xref{Atributos de áudio}, os canais são numerados para corresponder às trilhas de saída para onde são renderizados. Para estéreo, a fonte do canal 1 requere ser a trilha da esquerda e a fonte do canal 2 precisa ser a trilha da direita.

Para som surround 5.1, as fontes dos 6 canais precisam estar na ordem centro, esquerda-frente, direita-frente, esquerda-trás, direita-trás, efeitos de baixa freqüência. Se as trilhas certas não forem mapeadas para os falantes certos, a maioria dos transcodificadores de áudio não codificarão a informação certa, se é que codificarão alguma coisa. A trilha para efeitos de baixa freqüência especificamente não pode armazenar freqüências altas na maioria dos casos.

@c cincvdoc_node_number_101
@node Manipulando trilhas
@section Manipulando trilhas
@cindex Manipulando trilhas
@cindex Trilhas, manipulando

As trilhas no Cinelerra contêm ou áudio ou vídeo. Não há designações especiais para trilhas além do tipo de mídia que contêm. Quando você cria um projeto, ele contém três trilhas padrão: uma trilha de vídeo e duas trilhas de áudio. Você ainda pode adicionar ou apagar trilhas a partir dos menus. O menu de Trilhas contém um número de opções para lidar com múltiplas trilhas simultaneamente. Cada trilha possui um menu que afeta apenas ela mesma. @xref{O menu relacionado às trilhas}.

@cindex Menu de trilhas
Operações no menu de @b{Trilhas} afetam apenas as trilhas que estiverem armadas:
@itemize @bullet
@item @b{Mover trilhas para cima} e @b{Mover trilhas para baixo} mudam todas as trilhas armadas para cima ou para baixo no conjunto.
@cindex Apagar trilhas
@cindex Trilhas, apagar
@item @b{Apagar trilhas} apaga as trilhas armadas.
@item @b{Apagar última trilha} apaga a última trilha, caso esteja armada ou não. Pressionar a tecla @key{d} rapidamente apaga todas as trilhas.
@cindex Concatenar trilhas
@cindex Trilhas, concatenar
@item @b{Concatenar trilha} é mais complexo. Esta operação copia todos os blocos de edição de todas as trilhas desarmadas mas reproduzíveis e as concatena colando aqueles blocos de edição ao final do primeiro conjunto de trilhas armadas. Eles são colados um após o outro, mantendo a mesma ordem que possuem na pilha. Caso haja duas trilhas armadas seguidas de duas trilhas desarmadas, a operação de concatenação copia os blocos de edição das duas trilhas desarmadas e os cola após os blocos de edição das duas trilhas armadas. Caso haja três trilhas desarmadas ao invés disso, os blocos de edição das duas trilhas serão colados após os blocos de edição das trilhas armadas e os blocos de edição da terceira trilha serão colados após o fim da primeira trilha armada. A trilha de destino entra em espera até que todas as trilhas desarmadas sejam concatenadas. Trilhas desarmadas que não estejam reproduzíveis não são concatenadas.
@end itemize

Finalmente, você vai querer criar novas trilhas. Os menus de @b{Áudio} e @b{Vídeo} contêm uma opção cada para adicionar uma trilha daquele tipo específico. No caso de áudio, a nova trilha é colocada ao final da linha do tempo e o canal de saída da trilha de áudio é aumentado por um. No caso de vídeo, a nova trilha é colocada ao topo da linha do tempo. Desta forma, o vídeo possui uma ordem natural de composição. Novas trilhas de vídeo são sobrepostas ao topo das trilhas antigas.

@c cincvdoc_node_number_102
@node Edição em duas janelas
@section Edição em duas janelas
@cindex Edição em duas janelas

Este é o jeito mais rápido de construir um programa a partir de arquivos de vídeo. A idéia consiste em ver um arquivo de vídeo em uma janela e ver o programa em outra janela. Subseções do arquivo de vídeo são definidas em uma janela e transferidas para o final do programa na outra janela.

O jeito de começar uma sessão de edição em duas janelas é carregar alguns recursos. Em @b{arquivo->carregar}, carregue alguns vídeos com o modo de inserção @b{criar novos recursos}. Você vai querer que a linha do tempo permaneça sem modificações quando os novos recursos forem carregados. Vá para a Janela de Recursos e selecione a pasta @b{mídia}. Os novos recursos, recém-carregados, devem aparecer. Arraste um recurso para a janela de Visualização.

Deve haver trilhas armadas o suficiente na linha do tempo para colocar as subseções do material-fonte que você quiser. Caso não haja, crie novas trilhas ou arme mais trilhas.

Na janela de Visualização, defina um recorte de seu arquivo de vídeo: @*

@itemize @bullet
@item Marque o ponto de início com o @image{manual_images_intl/in_point_button,5mm} @b{botão do ponto de entrada}.
@item Busque o ponto de término do recorte que você quer usar.
@item Marque o ponto de término com o @image{manual_images_intl/out_point_button,5mm} @b{botão do ponto de saída}. 
@end itemize

Os dois pontos devem agora aparecer na barra de tempo e definir um recorte.@*
Há várias coisas que você pode fazer com o recorte agora:

@itemize @bullet
@item @b{Separar} @*
@image{manual_images_intl/splice_button,5mm} Insere o recorte na linha do tempo, após o ponto de inserção.@*
Após o Separar fazer efeito, o ponto de inserção se move para o fim da edição, pronto para ser usado como o próximo local de separação. Desta forma, você pode construir o programa continuamente por meio de divisões.@*
Se um @b{ponto de entrada} ou @b{ponto de saída} existe na linha do tempo, o recorte será inserido após o ponto de entrada ou após o ponto de saída. @*
Se há tanto pontos de entrada como de saída marcados na linha do tempo, o recorte é inserido após o ponto de entrada.@*
Se há edições após o local escolhido para a separação na linha do tempo, eles serão empurrados para a direita.
@item @b{Sobrescrever} @*
@image{manual_images_intl/overwrite_button,5mm} Sobrescreve a região da linha do tempo com o recorte. @*
Se um @b{ponto de entrada} ou @b{ponto de saída} existir na linha do tempo, ele será sobrescrito ali; de outra forma, ele será sobrescrito após o ponto de inserção.@*
Se uma região houver sido destacada ou tanto pontos de entrada quanto de saída existam, eles limitam a região da sobrescrição e o recorte pode ser diminuído. Isso é tão sutil que vale a pena uma descrição detalhada.@*
@b{DICA: Para sobrescrever exatamente em uma região precisa da linha do tempo:}@*
- Deixe armadas apenas as trilhas a serem modificadas.@*
- Defina o destino da região na linha do tempo com [ e ].@*
- Defina o recorte que você quer usar no visor com [ e ].@*
- Sobrescreva a partir do Visor para a linha do tempo.@* Se a região de destino for menor que o recorte definido no Visor, a porção do recorte que for maior que a região de destino não será copiada. Na linha do tempo os blocos de edição seguintes não serão movidos.@*
Aviso: Se a região de destino for maior que o recorte definido no Visor, a região de destino se encolherá. Na linha do tempo, os blocos de edição seguintes se moverão para a esquerda.
@item @b{Criar um recorte} @*
@image{manual_images_intl/toclip_button,5mm} Gera um novo recorte para a janela de recursos contendo a região afetada mas não modifica a linha do tempo. Cada recorte possui um título e uma descrição, ambos opcionais.
@item Copiar se comporta da mesma forma que a edição através de recortar e colar.
@end itemize
A edição em duas janelas pode ser feita inteiramente através de atalhos de teclado. Quando você move o apontador sobre qualquer botão, uma caixa de dica deve aparecer, mostrando qual tecla está relacionada àquele botão. Na janela de Visualização, as teclas do teclado numérico controlam o transporte e as teclas @kbd{[} @kbd{]} @kbd{v} executam pontos de entrada/saída e divisão.

@c cincvdoc_node_number_103
@node Edição de arrastar e soltar
@section Edição de arrastar e soltar
@cindex Edição de arrastar e soltar

@b{Edição de arrastar e soltar} é uma forma simples e rápida de trabalhar com o Cinelerra, usando apenas o mouse. A idéia básica é criar um punhado de recortes e então arrastá-los na ordem para a linha do tempo, construindo um protótipo de filme que você possa assistir na janela de composição. Se após assisti-lo você decidir re-arranjar seus recortes, marcar efeitos, adicionar transições ou inserir/apagar material, só arraste-os e solte-os na linha do tempo.

@enumerate 1
@item Carregue alguns arquivos usando @b{arquivo->carregar}.
@item Marque o modo de inserção para @b{Criar novos recursos}. Isso carregará os arquivos na Janela de Recursos.
@item Crie algumas trilhas de áudio e vídeo na linha do tempo usando os menus de áudio e vídeo.
@item Abra a pasta @b{Mídia} na janela de recursos.
@item Certifique-se que as trilhas necessárias estejam armadas e arraste o arquivo de mídia da janela de recursos para a linha do tempo. Se a mídia possui vídeo, arraste-a para uma trilha de vídeo. Se a mídia for apenas áudio, arraste-a para uma trilha de áudio.

@center @image{manual_images_intl/drag_to_program,70mm}

@end enumerate
O Cinelerra preenche as trilhas de áudio e vídeo abaixo do cursor que estiver arrastando as mídias com informações sobre o arquivo. Isso afeta que trilhas você deve criar inicialmente e para qual trilha você arrastará a mídia. Se a mídia possui uma trilha de vídeo e duas trilhas de áudio, você precisará de uma trilha de vídeo e duas de áudio na linha do tempo e a mídia deve ser arrastada para a primeira trilha de vídeo. Se a mídia possui apenas áudio, você precisará de uma trilha de áudio na linha do tempo para cada trilha de áudio na mídia e a mídia deve ser arrastada para a primeira trilha de áudio.

Quando você arrasta sua mídia escolhida da pasta de mídias para a linha do tempo, o apontador de seu mouse arrastará uma imagem miniatura e, uma vez sobre a linha do tempo, o contorno de um retângulo branco do tamanho do bloco de edição que você terá aparecerá.@*

Arraste a mídia para a posição desejada de uma trilha da linha do tempo e solte-a. Caso haja outros blocos de edição naquela trilha, quando você mover o contorno branco por sobre um bloco, você verá um símbolo de gravata-borboleta >< aparecendo nas bordas do bloco. Se você soltar a mídia ali, o novo bloco será iniciado a partir da borda indicada ao centro da gravata-borboleta ><. 

Uma vez que o apontador do mouse estiver no meio do contorno branco, quando este retângulo for maior que a parte visível da linha do tempo, é bem difícil inseri-lo de modo preciso. (Isso provavelmente acontecerá a mídias grandes). Diminuir a duração visível da linha do tempo modificando a amostragem de aproximação no painel de aproximação reduzirá o tamanho do retângulo branco, fazendo com que uma inserção precisa seja possível. 

Você também pode arrastar vários arquivos da janela de recursos. Ou desenhe uma caixa em volta dos arquivos com o mouse, use @key{SHIFT}, ou use @key{CTRL} quando estiver selecionando os arquivos. Quando você soltar os arquivos na linha do tempo, eles são concatenados. O comportamento de @key{SHIFT} e @key{CTRL} muda dependendo de se os recursos estão sendo dispostos como texto ou como ícones.

Para exibir os recursos como textos ou ícones, clique com o botão direito do mouse dentro da lista de mídia. Selecione ou @b{exibir ícones} ou @b{exibir texto} para mudar o formato de listagem.

Quando os recursos estiverem sendo exibidos como texto na janela de recursos, @b{clicar + usar o botão SHIFT} nos arquivos de mídia extende o número de seleções em destaque. @b{clicar + usar o botão CTRL} nos arquivos de mídia no modo texto seleciona arquivos adicionais um por vez.

Quando os recursos estiverem sendo exibidos como ícones na janela de recursos, @b{clicar + usar o botão SHIFT} ou @b{clicar + usar o botão CTRL} seleciona os arquivos de mídia um por vez.

Além de arrastar arquivos de mídia, se você criar recortes e abrir a pasta @b{recortes} você pode arrastar recortes para a linha do tempo.

Na linha do tempo há funções extras de arraste. Arrastar blocos de edição pela linha do tempo permite que você ordene listas de reprodução de músicas, cenas de vídeos e gere demos do NAB melhores, mas não muito mais que isso. Para habilitar a função de arraste na linha do tempo, selecione o ícone de flecha @image{manual_images_intl/arrow,2.67mm}. Mova o cursor para um bloco de edição e arraste-o. Durante a operação de arraste, o bloco de edição se colará à borda mais próxima.

@center Selecione uma trilha com várias cenas.

@center @image{manual_images_intl/drop_before}

@center Trilha original com três cenas.

@center Vá para a cena #3, clique e arraste-a para o meio.

@center @image{manual_images_intl/drag_track}

@center Quando você soltar a cena #3

@center @image{manual_images_intl/drop_concept}

@center a cena #2 muda para a direita.

@center @image{manual_images_intl/drop_after}

@center Assim é como a seqüência terminada fica.

Se mais de uma trilha estiver armada, o Cinelerra arrastará todos os blocos de edição que começam na mesma posição que o bloco onde o cursor está posicionado. Em outras palavras, você pode arrastar e soltar um grupo de blocos de edição. O  Cinelerra reconhece como um grupo os blocos de trilhas diferentes armadas que possuem inícios alinhados, sejam eles da mesma fonte ou não, tendo finais alinhados ou não. 

Quando você arrasta e solta blocos de edição dentro da linha do tempo:@*

Se você soltar um bloco quando as gravatas-borboletas >< estiverem sendo mostradas, o recorte será recortado e colado iniciando na borda de edição indicada ao centro da gravata ><. Os blocos de edição seguintes se moverão. Se você soltar um bloco quando não há gravatas-borboleta >< sendo mostradas, o recorte original será mutado e colado onde você o largou. Nenhum bloco de edição se moverá. Um silêncio aparecerá no lugar de seu recorte original. 

No modo de edição Arrastar e Soltar, você não pode arrastar e soltar marcadores. Eles estarão sempre presos à barra de tempo, mesmo com a opção "Editar marcadores" habilitada. Ainda assim, com a opção "Editar marcadores" habilitada, se uma área selecionada de um recurso for dividida do Visor para a linha do tempo em uma posição antes de marcadores, esses marcadores serão empurrados para a direita pela duração da área selecionada.

Com pontos de entrada/saída, você pode fazer operações de Recortar e Colar no modo Arrastar e Soltar do mesmo modo que no modo Recortar e Colar. Vá para o Menu de Edição para ver a lista e os atalhos de teclado.

@c cincvdoc_node_number_104
@node Edição de recortar e colar
@section Edição de recortar e colar
@cindex Edição de recortar e colar

Este é o método tradicional de edição nos editores de áudio. No caso do Cinelerra, você precisa iniciar uma segunda cópia do Cinelerra e copiar e uma cópia a outra, copiar a partir de trilhas diferentes na mesma cópia ou carregar um arquivo de mídia na janela de visualização e copiá-la dali.

Carregue alguns arquivos na linha do tempo. Para fazer a edição por recorte e cola, selecione o @image{manual_images_intl/ibeam,1.67mm} ícone da barra. Selecione a região da linha do tempo e selecione o @image{manual_images_intl/cut,5.67mm} botão de recorte para cortá-lo. Mova o ponto de inserção para outro ponto da linha do tempo e selecione @image{manual_images_intl/paste,5mm} o botão de colar. Assumindo que não haja pontos de entrada/saída definidos na linha do tempo, isso faz a operação de recortar e colar.

Se pontos de entrada/saída estiverem definidos, o ponto de inserção e a região em destaque serão sobrescritas pelos pontos de entrada/saída para as operações de prancheta ("clipboard"). Assim, com pontos de entrada/saída você pode fazer recorte e cola no modo de arrastar e soltar tanto quanto no modo de recortar e colar.

Quando estiver editando áudio, é comum recortar uma área da onda sonora para uma mesma área de outra onda sonora. Os pontos de início e final do recorte são idênticos em cada onda sonora e podem ser deslocados levemente caso a informação de onda seja diferente. Seria bem difícil destacar uma onda sonora e recortá-la e destacar a segunda onda sonora e colá-la sem mudar as posições relativas de início e final.

Uma alternativa para simplificar isso é abrir uma segunda cópia do Cinelerra, recortar e colar para transportar mídia entre as duas cópias. Desta forma, duas regiões destacadas podem existir simultaneamente.

Outra opção é marcar pontos de entrada/saída para a região fonte da onda sonora fonte e colocar marcadores para a região de destino da onda sonora de destino. Faça um recorte, limpe os pontos de entrada/saída, selecione as regiões entre os marcadores e faça a cola.

A operação final na edição por recorte e cola é a operação @b{editar->limpar}. Se uma região é destacada ou pontos de entrada/saída existem, a região afetada pode ser limpa por @b{editar->limpar}. Mas se o ponto de inserção estiver sobre uma borda de um bloco de edição e os blocos a cada lado das bordas forem da mesma fonte, os blocos são combinados em um bloco. O início deste bloco de edição é o início do primeiro bloco e o final deste bloco é o final do segundo bloco. Isso resulta em um bloco se expandindo ou diminuindo.

@c cincvdoc_node_number_105
@node Redimensionando ("trimming")
@section Redimensionando ("trimming")
@cindex Redimensionando ("trimming")

Com alguns bloco de edição na linha do tempo, é possível fazer o redimensionamento. Por redimensionamento, você encolhe ou estica as bordas do bloco de edição ao arrastá-las. No modo de arrastar e soltar ou no modo de recortar e colar, mova o cursor para sobre a borda de um bloco de edição até que ele mude de forma. O cursor se tornará uma forma para expandir para a esquerda ou para a direita. Se o cursor for para expandir para a esuqerda, a operação de arrastar afeta o início do bloco de edição. Se o cursor for para expandir para a direita, a operção de arraste afeta o final do bloco de edição.

Quando você clica na orda de um bloco de edição para começar a arrastá-la, o número do botão do mouse determina qual o comportamento de arraste será usado. 3 comportamentos possíveis estão relacionados aos botões do mouse nas preferências de interface.
@xref{Interface}.

O efeito de cada operação de arraste não depende somente no comportamento do botão, mas se o começo ou final do bloco de edição é que está sendo arrastado. Quando você solta o botão do mouse, a operação de redimensionamento acontece.

Na operação @b{Arrastar todas as edições seguintes}, o começo do bloco de edição ou recorta informação do bloco se você movê-lo para frente ou cola nova informação de antes do recorte se você movê-lo para trás. O final do bloco cola informação no recorte se você movê-lo para frente ou corta informação do final do recorte se você movê-lo para trás. Todos os recortes a partir dali mudam. Finalmente, se você arrastar o final do recorte passando pelo começo do recorte, o bloco de edição é apagado.

Na operação @b{Arrastar somente uma edição}, o comportamento é o mesmo quando você arrasta o começo ou o final de um bloco de edição. Aúnica diferença é que nenhum dos outros blocos são mudados. Ao invés disso, tudo adjacente ao bloco atual expande ou encolhe para preencher buracos deixados pela operação de arraste.

Em uma operação @b{Arrastar fonte somente}, nada é recortado ou colado. Se você mover o início ou o final do bloco de edição para a frente, a fonte de referência no recorte é modificada para frente. Se você mover o início ou o final do bloco de edição para trás, a fonte de referência muda para trás. O lugar onde o recorte aparece na linha do tempo permanece o mesmo, mas a fonte muda.

Para todos os formatos exceto imagens estáticas, a extensão da operação de redimensionamento é limitada pela duração do arquivo de origem. Tentar arrastar o início de um recorte para além do início do material fonte não resultará em nada.

Em todas as operações de redimensionamento, todos os recortes que começam na mesma posição que o cursor quando a operação de arraste começar serão afetados. Desarme as trilhas para prevenir que os recortes sejam afetados.

A maioria dos efeitos do Cinelerra podem ser entendidos simplesmente usando-os e mexendo em suas propriedades. Aqui estão algumas breves descrições de efeitos que você pode não usar inteiramente simplesmente experimentando-os.

@c cincvdoc_node_number_106
@node Janela de composição
@chapter Janela de composição
@cindex Janela de composição

Esta janela exibe a saída da linha do tempo. É a interface para a maioria das operações de composição e operações que afetem a aperência da saída da linha do tempo. Operações realizadas no Compositor afetam a linha do tempo mas não afetam os recortes.

@menu
* Controles do compositor::
* Composição::
@end menu

@c cincvdoc_node_number_107
@node Controles do compositor
@section Controles do compositor
@cindex Controles do compositor

A saída do vídeo possui várias funções de navegação. O tamanho de saída do vídeo está ou ligado ao tamanho da janela ou desligado, com barras de rolagem para navegação. A saída do vídeo pode ser aproximada ou afastada e/ou vista de uma forma panorâmica. Navegar pela saída de vídeo desta forma não afeta a saída renderizada; isso apenas muda o ponto de vista na janela de composição.

Caso o vídeo esteja desligado do tamanho da janela, clicar com o botão do meio do mouse e arrastar para qualquer lugar no vídeo faz uma panorâmica pelo ponto de vista.

Pressionar as teclas @kbd{+} e @kbd{-} aproxima e afasta a saída de vídeo.

Abaixo da saída de vídeo há cópias de várias das funções disponíveis na janela principal. Além delas, há um @image{manual_images_intl/cwindow_zoom,30mm} menu de aproximação e uma @image{manual_images_intl/cwindow_light,8mm} luz em forma de losango.

O menu de aproximação pula para todas as configurações possíveis de aproximação e, por meio da opção @b{Auto}, trava o ajuste de visualização do vídeo ao tamanho da janela. O menu de aproximação não afeta do tamanho da janela.

A luz em forma de losango fica vermelha quando estiver acontecendo uma renderização. Isso é útil para saber se a saída é atual.

Clicar com o botão direito do mouse em qualquer lugar da saída de vídeo traz um meni com todos os níveis de aproximação e algumas outras opções. Neste caso em particular, os níveis de aproximação redimensionam toda a janela e não apenas o vídeo.

As opções @b{Zerar câmera} e @b{Zerar projetor} centralizam a câmera e o projetor @xref{Composição}.

@cindex Esconder controles
@cindex Controles, esconder
A opção @b{Esconder controles} esconde tudo exceto o vídeo.

À esquerda da saída de vídeo há uma barra de ferramentas específica da janela de composição. Aqui estão as funções da janela de ferramentas:

@menu
* Proteger vídeo::
* Lente de aumento::
* Ferramenta de máscaras::
* Câmera::
* Projetor::
* Ferramenta de recorte::
* Conta-gotas::
* Informações da ferramenta::
* Ferramenta de áreas de segurança::
@end menu

@c cincvdoc_node_number_108
@node Proteger vídeo
@subsection Proteger vídeo
@cindex Proteger vídeo

Desabilita as mudanças para a saída do compositor a partir de cliques feitos nela. É uma camada extra acima da armação/desarme de trilhas para prevenir mudanças não desejadas.

@c cincvdoc_node_number_109
@node Lente de aumento
@subsection Lente de aumento
@cindex Lente de aumento

Esta ferramenta @image{manual_images_intl/magnify,7mm} aproxima e afasta a saída do compositor sem redimensionar a janela. Se a saída do vídeo for atualmente ligada ao tamanho da janela, clicar no vídeo com a lente de aumento desliga-o e cria barras de rolagem para navegação.

Clicar com o botão esquerdo do mouse no vídeo aproxima. @*
Clicar com a tecla ctrl no vídeo aproxima. @*
Rodar a rodinha do mouse aproxima ou afasta.

@c cincvdoc_node_number_110
@node Ferramenta de máscaras
@subsection Ferramenta de máscaras
@cindex Ferramenta de máscaras

Esta ferramenta @image{manual_images_intl/mask} traz a ferramenta de edição de máscaras @xref{Máscaras}. Habilite a @image{manual_images_intl/toolwindow,2.67mm} janela de ferramentas para ver as opções para esta ferramenta.

@c cincvdoc_node_number_111
@node Câmera
@subsection Câmera
@cindex Câmera

Esta ferramenta @image{manual_images_intl/camera,4.67mm} traz a ferramenta de edição de câmera @xref{A câmera e o projetor}. Habilite a @image{manual_images_intl/toolwindow,2.67mm} janela de ferramentas para ver as opções para esta ferramenta.

@c cincvdoc_node_number_112
@node Projetor
@subsection Projetor
@cindex Projetor

Esta ferramenta @image{manual_images_intl/projector,4.67mm} traz a ferramenta de edição do projetor @xref{A câmera e o projetor}. Habilite a @image{manual_images_intl/toolwindow,2.67mm} janela de ferramentas para ver as opções para esta ferramenta.

@c cincvdoc_node_number_113
@node Ferramenta de recorte
@subsection Ferramenta de recorte
@cindex Ferramenta de recorte

Esta ferramenta @image{manual_images_intl/crop,4.33mm} traz a ferramenta de recorte @xref{Recorte}. A @image{manual_images_intl/toolwindow,2.67mm} janela de ferramentas deve estar habilitada para que esta ferramenta possa ser usada.

@c cincvdoc_node_number_114
@node Conta-gotas
@subsection Conta-gotas
@cindex Conta-gotas

Traz o conta-gotas. O conta-gotas detecta qualquer cor que estiver abaixo dele e a armazena em uma área temporária. Habilitar a @image{manual_images_intl/toolwindow,2.67mm} ferramenta de informação exibe a cor selecionada atualmente. Clique em qualquer lugar da saida de vídeo para selecionar a cor daquele ponto. @* O conta-gotas não apenas permite que você veja áreas recortadas como seu seu valor pode ser aplicado a vários efeitos. Diferentes efeitos lidam com o conta-gotas de diferentes maneiras.

@c cincvdoc_node_number_115
@node Informações da ferramenta
@subsection Informações da ferramenta
@cindex Informações da ferramenta

Este botão de ferramenta @image{manual_images_intl/toolwindow,2.67mm} trabalha apenas em conjunto com outros controles no compositor. Baseado em qual controle do compositor estiver ativo, o botão ativará/desativará a caixa de diálogo de controle apropriada.

Controles com caixas de diálogos são:
@itemize @bullet
@item Editar máscara
@item Automação de câmera
@item Automação de  projetor
@item Controle de recorte
@end itemize

@c cincvdoc_node_number_116
@node Ferramenta de áreas de segurança
@subsection Ferramenta de áreas de segurança
@cindex Ferramenta de áreas de segurança

Esta ferramenta @image{manual_images_intl/titlesafe} desenha as áreas de segurança na saída do vídeo. Isso não afeta a saída renderizada @xref{Margens de segurança}.

@c cincvdoc_node_number_117
@node Composição
@section Composição
@cindex Composição

Grande quantidade do tamanho binário do Cinelerra é dirigido para a composição. Quando você remove as legendas ("letterbox") de um programa em widescreen, você está compondo. Mudar a resolução de um programa, fazer uma divisão de telas, fades de entrada ou saída, entre outras coisas, todas são operações de composição no Cinelerra. O Cinelerra detecta quando está em uma operação de composição e somente aí faz a reprodução pelo engine de composição. De outra forma, ele usa o decodificador mais rápido disponível no hardware.

Operações de composição são feitas na linha do tempo e na Janela de Composição. Há atalhos na Janela de Recursos para mudar alguns dos atributos de composição. Uma vez que alguns arquivos de vídeo estejam na linha do tempo, a janela de composição é um bom lugar para tentar fazer a composição.

@menu
* A câmera e o projetor::
* Máscaras::
* Recorte::
* Margens de segurança::
* Modos de sobreposição::
* Tamanhos de trilha e saída::
@end menu

@c cincvdoc_node_number_118
@node A câmera e o projetor
@subsection A câmera e o projetor
@cindex Câmera
@cindex Projetor

@menu
* O temporário::
* Controles de composição do projetor::
* Controles de composição de câmera::
* Menu de opções::
* A janela de ferramentas de câmera e projetor::
@end menu

@c cincvdoc_node_number_119
@node O temporário
@subsubsection O temporário
@cindex O temporário

Na janela de composição, as funções mais importantes são o @image{manual_images_intl/camera,4.67mm} botão de câmera e o @image{manual_images_intl/projector,4.67mm} botão de projetor. Eles controlam a operação da câmera e do projetor. Dentro da linha de composição do Cinelerra, a câmera determina de onde no vídeo fonte o temporário será copiado. O projetor determina para onde na saída o temporário será copiado. O temporário é um quando de vídeo na memória do Cinelerra onde todo o processamento gráfico é realizado.

@center @image{manual_images_en/temporary_explained,140mm}

O processo é bem como se escaneássemos um rolo de filme a um quadro por vez e alterássemos, por exemplo usando o Gimp, digitalmente a imagem escaneada com vários filtros. Uma vez que a imagem tenha sido transformada pelos filtros - de correção de cor, por exemplo -, nós então projetamos a imagem acabada de novo em um novo rolo de filme, criando assim uma nova versão "modificada" do original.

Cada trilha possui um temporário diferente que é definido pelo tamanho da trilha. Ao redimensionar as trilhas, você pode criar telas divididas, panorâmicas e aproximações.

@center @image{manual_images_en/compositing_pipeline,140mm}
@center @b{Representação visual da cadeia de composição}

Quando se edita a câmera e o projetor na janela de composição, a primeira trilha com o @b{gravar} habilitado é a trilha afetada. Mesmo se a trilha estiver completamente transparente, ela ainda será a afetada. Caso várias trilhas de vídeo existam, o jeito mais fácil de selecionar uma delas para ser editada é pressionar @b{clicar + usar o botão SHIFT} no ícone de gravação daquela trilha. Isso a isolará.

@center @image{manual_images_en/projector_concept,120mm}

O propósito do projetor é colocar os conteúdos do temporário na saída do projeto. A intenção do projetor é compor várias fontes de várias trilhas em uma trilha final de saída.

O quadro de alinhamento do projetor é idêntico à visualização ("viewport") da câmera, exceto que ele guia para onde na tela ("canvas") de saída serão colocados os conteúdos de cada temporário.

@center @image{manual_images_intl/projector_screen}

@c cincvdoc_node_number_120
@node Controles de composição do projetor
@subsubsection Controles de composição do projetor
@cindex Controles de composição do projetor

Quando o botão do @b{projetor} está habilitado na janela de composição, você está no modo de edição do projetor. Uma caixa de guia aparece na janela do vídeo. Arrastar em qualquer lugar da janela de vídeo faz com que a caixa de guia se mova, se tudo der certo junto com o vídeo. @b{arratar-com-o-SHIFT} em qualquer lugar da janela de vídeo faz com que a caixa de guia encolha ou cresça junto com o vídeo. Uma vez que você tenha posicionado o vídeo com o projetor, você está pronta/o para dominar a câmera.

@c cincvdoc_node_number_121
@node Controles de composição de câmera
@subsubsection Controles de composição de câmera
@cindex Controles de composição de câmera

Selecione o @image{manual_images_intl/camera,4.67mm} botão de câmera para habilitar o modo de edição de câmera. Neste modo, a caixa de guia mostrará onde a posição da câmera está em relação às posições passadas e futuras de câmera, mas não onde ela está com relação ao vídeo de origem. Arrastar a caixa da câmera na janela de composição não move a caixa, mas a localização do vídeo dentro dela.

@cindex Viewport ("janela de visualização")
O @b{viewport} é uma janela na câmera que enquadra a área do vídeo-fonte a ser escaneada. O viewport é representado como um quadro vermelho com barras diagonais em cruz.

@center @image{manual_images_en/camera_concept,100mm}
@center @b{O viewport}

@center @image{manual_images_en/viewport_sizes,150mm}
@center @b{Tamanhos de Viewport}

O tamanho do viewport é definido pelo tamanho da trilha atual. Um viewport menor (640x400) captura uma área menor. Um viewport mais largo (800x200) captura uma área mais larga que o vídeo de origem e preenche os espaços vazios com brancos.

Uma vez que temos nosso viewport definido, ainda precisamos colocar a câmera abrangendo a área do vídeo de origem na qual estamos interessados. Para controlar o local da câmera:
@enumerate 1
@item Abra a janela do compositor com uma trilha selecionada.
@item Selecione o botão de câmera para habilitar o modo de edição de câmera.
@item Faça o arraste por sobre a janela de reprodução.
@end enumerate

Quando fazemos o arraste por sobre o viewport na janela de composição (embora inicialmente anti-intuitivo), não é o viewport que se move, mas a área de vídeo que está abaixo da locação da câmera, como quando monitoramos uma câmera em movimento em um monitor.

@center @image{manual_images_intl/viewport_drag,100mm}
@center @b{Na janela de composição, o viewport sempre será exibido}
@center @b{de forma centralizada, o que se move é o vídeo abaixo dele}

Por exemplo, quando você arrasta a câmera para baixo, o viewport de fato estará se movendo para baixo no vídeo, mostrando seu caminho em direção à base do vídeo, mas de nossa perspectiva na tela de composição, vemos o vídeo se movendo para cima. Quando você arrasta a câmera para a direita, o vídeo parece se mover para a esquerda e assim por diante.

@b{Nota:} A caixa guia mostra onde a posição da câmera está com relação às posições passadas e futuras da câmera, não onde ela está com relação ao vídeo de origem.

@c cincvdoc_node_number_122
@node Menu de opções
@subsubsection Menu de opções
@cindex Menu de opções

Na janela de composição, há um menu de opções para a câmera e o projetor. Clique com o botão direito por sobre a porção do vídeo na janela de composição para revelar o menu.

@itemize @bullet
@item Zerar a câmera faz com que a câmera volte à posição central.
@item Zerar o projetor faz com que o projetor volte à posição central.
@end itemize

@c cincvdoc_node_number_123
@node A janela de ferramentas de câmera e projetor
@subsubsection A janela de ferramentas de câmera e projetor
@cindex A janela de ferramentas de câmera e projetor

A câmera e o projetor não têm operações de atalho nem no menu nem representado nas sobreposições de vídeo. Eles estão acessíveis na @b{Janela de ferramentas}. A maioria das operações na janela do Compositor têm uma janela de ferramentas que pode ser habilitada ativando o @image{manual_images_intl/toolwindow,2.67mm} botão de interrogação.

@center @image{manual_images_intl/compositor_campro_tool,40mm}
@center @b{A janela de ferramentas de câmera e projetor}

No caso da câmera e do projetor, a janela de ferramentas mostra as coordenadas x, y e z. Ao se mudar estes valores, a câmera e o projetor podem ser posicionados precisamente. 9 tipos de justificação também estão definidos para acesso fácil. Uma operação popular de justificação é a projeção na parte superior esquerda após a redução da imagem. Isso é usado quando se reduz o tamanho do vídeo com ajuste de razão de aspecto.

@itemize @minus
@item @image{manual_images_intl/button_justify_left} Esquerda
@item @image{manual_images_intl/button_justify_centerH} Horizontal Centro
@item @image{manual_images_intl/button_justify_right} Direita
@item @image{manual_images_intl/button_justify_top} Topo
@item @image{manual_images_intl/button_justify_centerV} Vertical Centro
@item @image{manual_images_intl/button_justify_bottom} Base
@end itemize

O efeito de translação permite a conversão e redução simultânea de razão de aspecto, mas é mais fácil de ser usado se o vídeo reduzido for colocado na parte superior esquerda do temporário ao invés de ao centro. O tamanho da trilha é ajustado para o tamanho original do vídeo e a câmera é centralizada. O tamanho de saída é ajustado para o tamanho reduzido do vídeo. Sem efeitos, isso produz justamente o recorte da porção central do vídeo na saída.

O efeito de translação é jogado na trilha de vídeo. As dimensões de entrada do efeito de translação são ajustadas para o tamanho original e as dimensões são ajustadas para o tamanho reduzido. Para colocar o vídeo reduzido na subseção central que o projetor mostra requereria deslocar @b{o x de saída e o y de saída} por um cálculo complicado. Ao invés disso, deixamos @b{o x de saída e o y de saída} em 0 e usamos a janela de ferramentas do projetor.

Simplesmente ao selecionar @image{manual_images_intl/left_justify} justificar à esquerda e @image{manual_images_intl/top_justify} justificar ao topo, o projetor exibe a imagem reduzida na parte de cima e à equerda do temporário no centro da saída.

@c cincvdoc_node_number_124
@node Máscaras
@subsection Máscaras
@cindex Máscaras

As máscaras selecionam uma região do vídeo para tanto exibi-la quanto para escondê-la. Máscaras também são usadas junto com outro efeito para isolar o efeito a uma certa região do quadro. Uma cópia de uma trilha de vídeo pode ser levemente atrasada e desmascarada em locais onde uma das cópias possui interferência mas a outra não. Correções de cor podem ser necessárias em uma área de um quadro, mas não em outra. Uma máscara pode ser aplicada para apenas uma subseção da trilha com a cor corrigida enquanto e outra trilha pode ser vista nas outras áreas. Remoção de microfones direcionais, aviões e esposas são outros usos das máscaras.

A ordem da linha de composição afeta o que pode ser realizado com as máscaras. Normalmente, as máscaras são feitas no temporário após os efeitos e antes do projetor. Isso significa que várias trilhas podem ser "quicadas" ("bounced") em uma trilha com máscara e projetadas com as mesma máscara.

Nosso gráfico de linha de composição agora possui um estágio de máscara. Há 8 máscaras possíveis por trilha. Cada máscara é definida separadamente, embora cada uma delas executem a mesma operação, seja de adição ou subtração.

@center @image{manual_images_en/compositing_pipeline2,140mm}
@center @b{Linha de composição com máscaras}

Para definir uma máscara, vá para a janela de Composição e habilite a @image{manual_images_intl/mask} @b{máscara}. Agora vá para o vídeo e clique-e-arraste.

@b{IMPORTANTE:} Você deve selecionar @b{quadros-chave automáticos} (@xref{Quadros-chave automáticos},) caso queira mover uma máscara conforme o tempo. Se você não selecionar @b{quadros-chave automáticos}, a posição da máscara será a mesma mesmo se você editá-la em locais diferentes da linha do tempo.

@center @image{manual_images_intl/compositor_mask1,60mm}

Clique-e-arraste de novo em outra parte da imagem para criar um novo ponto de máscara. Embora não seja o comportamento convencional de curva Bezier, esta interface de máscara mostra em tempo-real qual o efeito da máscara será. A cada ponto da máscara criado, uma aba da máscara se expandirá.

Uma vez que os pontos tenham sido definidos, eles podem ser movidos por @b{arrastar-com-o-CTRL} nas proximidades dos cantos.

@center @image{manual_images_en/compositor_mask_drag}
@center @b{arrastar com o CTRL permite que você mova pontos existentes}
@center @b{para novos locais, assim alterando a forma da máscara}

Isso, entretando, não suaviza a curva. Os pontos de entrada-saída da curva Bezier são acessados por @b{arrastar-com-o-SHIFT} na proximidade dos cantos. Então, @b{arrastar-com-o-SHIFT} perto dos pontos de entrada ou saída faz o ponto se mover.

@center @image{manual_images_en/compositor_mask_bezier}
@center @b{arrastar-com-o-SHIFT ativa os controles belzier}

@center @b{para criar curvas entre os pontos de máscara}

Finalmente, uma vez que você tenha uma máscara, ela pode ser transladada como peça única fazendo um @b{arrastar-com-o-ALT} na máscara. A edição de máscaras no Cinelerra é idêntica a como se edita máscaras no Gimp, com exceção que neste caso o efeito de máscaras está sempre ligado.

@center @image{manual_images_en/compositor_mask_translate}
@center @b{arrastar-com-o-CTRL-ALT translada uma máscara inteira}
@center @b{para um novo local na tela}

As máscaras possuem vários outros parâmetros que não puderam ser representados com sobreposição de vídeos. Eles estão representados na janela de ferramentas para máscaras. Selecionar o @image{manual_images_intl/toolwindow,2.67mm} ponto de interrogação quando o botão @image{manual_images_intl/mask} de máscara estiver aceso revela as opções de máscaras.

@center @image{manual_images_intl/mask_dialog,70mm}
@center @b{Janela de opções de máscara}

O @b{modo} de máscara determina se a máscara remove informação ou se faz a informação ficar visível. Se o modo for subtrativo, a máscara faz o vídeo desaparecer. Se o modo for aditivo, a máscara faz o vídeo aparecer e tudo fora da máscara desaparecer.

@center @image{manual_images_en/compositor_mask_mode,160mm}
@center @b{Modo de máscara}

O @b{valor} da máscara determina quão extrema será a adição ou subtração. No modo subtrativo, valores mais altos subtraem mais alfa. No modo aditivo, valores mais altos fazem a região na máscara mais brilhantes enquanto a região fora da máscara estará sempre escondida.

@center @image{manual_images_en/composite_mask_value}
@center @b{Valor de máscara}

O número da máscara determina qual das 8 máscaras possíveis estamos editando. Cada trilha possui 8 máscaras possíveis. Quando você clica-e-arrasta na janela de composição, você está editando apenas uma das máscaras. Mude o valor de @b{número de máscara} para fazer com que a outra máscara seja editada. A máscara prévia ainda está ativa, mas apenas a sobreposição de curva para a máscara atualmente selecionada está visível.

Quando várias máscaras são usadas, seus efeitos são lidos juntos. Cada máscara em uma trilha usará o mesmo valor e modo.

@cindex Suavizar máscara
@cindex Máscara, suavizar
As bordas de uma máscara são duras por padrão, mas isso raramente é desejável. O parâmetro @b{Suavização} determina quantos pixels serão suavizados da máscara. Isso cria bordas mais suaves, mas leva mais tempo para ser renderizado.

@center @image{manual_images_en/compositor_feather,120mm}
@center @b{Parâmetro de Suavização}

Observação: o renderizador de máscaras OpenGL possui uma qualidade ruim e apenas útil como uma previsão ou trabalho inicial. Para um ajuste fino de máscaras (com valores maiores de suavização) o OpenGL deve ser desligado e a renderização por software utilizada.

Finalmente, há parâmetros que afetam apenas um ponto na máscara atual ao invés de em toda ela. Esses são @b{Apagar, x, y}. O ponto ativo é definido pelo último ponto arrastado na janela de composição. Qualquer ponto pode ser ativado simplesmente pressionando @b{clicar-com-o-CTRL} perto dele sem mover o cursor. Uma vez que o ponto esteja ativado, @b{Apagar} apaga-o e @b{x, y} permitem um reposicionamento por entrada numérica.

@c cincvdoc_node_number_125
@node Recorte
@subsection Recorte
@cindex Recorte

Recortar muda o valor das dimensões de saída e o projetor para reduzir a área visível da imagem. Habilite o @image{manual_images_intl/crop,4.33mm} botão de recorte e a @image{manual_images_intl/toolwindow,2.67mm} janela de ferramentas na @b{janela de composição} para exibir a @b{caixa de diálogo de controle de recorte}.

@center @image{manual_images_intl/compositor_crop_tool,60mm}
@center @b{Caixa de diálogo de controle de recorte}

Clique-e-arraste em qualquer lugar do vídeo para definir a área de recorte. Isso desenhará um retângulo por sobre o vídeo. Clique-e-arraste em qualquer lugar do vídeo para começar um novo retângulo. Clique-e-arraste por sobre qualquer canto do retângulo para reposicioná-lo.

@center @image{manual_images_intl/compositor_crop}
@center @b{Área de recorte definida}

@b{clicar-com-o-ALT} no retângulo de recorte para transladá-lo para qualquer posição sem redimensioná-lo.

A janela de ferramentas permite entradas de texto das coordenadas e executa a operação de recorte. Quando o retângulo for posicionado, pressione o botão @b{Fazer} na janela de ferramentas para executar a operação de recorte.

@b{Nota:} As coordenadas X1,Y1 & X2,Y2 no diálogo de controle de recorte permitem entradas de texto das coordenadas dos campos topo-à-esquerda e base-à-direita que definem o retângulo de recorte.

@c cincvdoc_node_number_126
@node Margens de segurança
@subsection Margens de segurança
@cindex Margens de segurança
@cindex Margens, segurança

Em aparelhos de consumidores, as bordas da imagem são cortadas e dentro do ponto de corte está uma região que não é sempre quadrada como ela é na janela de composição. As margens foram pensadas como uma área de rascunho e informação nula vertical ("vertical blanking data"). Você pode mostrar onde essas margens estão habilitando o @image{manual_images_intl/titlesafe} botão de margens de segurança. Mantenha os títulos dentro do retângulo menor e a ação dentro do retângulo de fora.

@c cincvdoc_node_number_127
@node Modos de sobreposição
@subsection Modos de sobreposição
@cindex Modos de sobreposição

Cada trilha de vídeo possui um modo de sobreposição, acessível ao se expandir a trilha. O modo de sobreposição é um menu que desce à esquerda, abaixo do fader. Quando retraído, ele mostra um ícone representando o modo atual de sobreposição.

Selecione o botão de @image{manual_images_intl/expandpatch_checked} expandir trilha para ver todas as opções para uma trilha de vídeo se você não consegue ver o modo de sobreposição. O modo de sobreposição das trilhas de vídeo está em @b{normal} por padrão. Selecione outros modos clicando no botão de sobreposição e selecionando um item do menu que aparecerá.

Modos de sobreposição são processados dentro do estágio de composição do projetor. Os diferentes modos estão resumidos abaixo.

@cindex Modo de sobreposição normal
@itemize @bullet
@item @b{Normal} @*
Este modo usa uma equação Porter-Diff tradicional para mixar ("blend") as trilhas com o alfa. Quando não existe um alfa no modelo de cor do projeto, a nova trilha sempre substitui a saída.

@cindex Modo de sobreposição de adição
@item @b{Adição} @*
Neste modo, o que quer que esteja na saída será adicionado à trilha atual. O resultado é mixado para a saída ("blended") baseado no alfa da trilha atual.

@cindex Modo de sobreposição de subtração
@item @b{Subtração} @*
Neste modo, a trilha atual é subtraída da saída e o resultado é mixado pelo alfa ("alpha blended") na saída.

@cindex Modo de sobreposição de multiplicação
@item @b{Multiplicar} @*
Esta é a operação mais útil. A trilha atual é multiplicada pela saída e o resultado é mixado ("blended") na saída. Normalmente uma imagem em preto e branco sem canal alfa ou um título branco em uma imagem preta é usado como trilha atual. Com a operação de multiplicar, apenas as porções de saída abaixo da área branca são mostradas.

@cindex Modo de sobreposição de divisão
@item @b{Dividir} @*
Este modo divide a trilha atual pela saída e o resultado é mixado ("blended") na saída. Normalmente resulta em níveis excessivos.

@cindex Modo de sobreposição de substituição
@item @b{Substituir} @*
Este modo não faz mixagem ("blending") e sobrescreve a saída com a trilha atual.
@end itemize

@c cincvdoc_node_number_128
@node Tamanhos de trilha e saída
@subsection Tamanhos de trilha e saída
@cindex Tamanhos de trilha e saída
@cindex Tamanhos de saída

@menu
* Tamanho de trilha::
* Tamanho de saída::
@end menu

O tamanho do temporário e o tamanho da saída na sua linha de composição são independentes e variáveis. Isso condiz com tudo o que vimos até agora. O viewport da câmera é o tamanho temporário. Efeitos são processados no temporário e são afetados pelo tamanho do temporário. Projetores são renderizados na saída e são afetados pelo tamanho da saída. Se o temporário for menor que a saída, o temporário será margeado por regiões em branco na saída. Se o temporário for maior que a saída, o temporário será recortado.

@c cincvdoc_node_number_149
@node Tamanho de trilha
@subsubsection Tamanho de trilha
@cindex Tamanho de trilha

O tamanho do temporário é definido como o tamanho da trilha. Cada trilha possui um tamanho diferente. Clique com o botão direito do mouse em uma trilha para revelar o menu da trilha. Selecione @b{Redimensionar trilha} para redimensionar a trilha para qualquer tamanho. Alternativamente, você pode selecionar @b{Ajustar a tamanho da saída} para fazer a trilha ter o mesmo tamanho da saída.

@center @image{manual_images_intl/resize_track,70mm}
@center @b{A janela de redimensionar trilha}

Por exemplo, a próxima imagem mostra como uma trilha de vídeo e a saída de um projeto de tamanhos iguais aparecem diferentes quando mostrados no compositor.

@center @image{manual_images_intl/compositor_output_equal,70mm}
@center @b{Tamanho de saída do projeto e trilha de}
@center @b{vídeo com dimensões iguais (720x480)}

Se você redimensionar a trilha, sua aparência no compositor mudará de acordo.

Reduzir a trilha (para 640 x 400) e deixar o tamanho de saída do projeto sem alterações fará a trilha aparecer menor no compositor e margeada por uma área em branco.

@center @image{manual_images_intl/compositor_output_small,70mm}
@center @b{Nova trilha (640x400), menor que}
@center @b{a saída do projeto (720x480)}

Aumentar a trilha (para 800 x 560) e deixar o tamanho de saída do projeto sem alterações fará a trilha aparecer maior no compositor e recortada na dimensão de saída.

@center @image{manual_images_intl/compositor_output_large,70mm}
@center @b{Nova trilha (800x560), recortada para}
@center @b{o tamanho da saída do projeto (720x480)}

Ao usar esta relação entre a trilha e o tamanho de saída do projeto, você pode efetivamente reduzir ou aumentar o tamanho de uma trilha em particular no que se refere à saída final e portanto criar "efeitos" visuais como telas divididas, panorâmicas e aproximações no compositor.

@c cincvdoc_node_number_129
@node Tamanho de saída
@subsubsection Tamanho de saída
@cindex Tamanho de saída

O tamanho de saída é configurado tanto em @b{Novo} quando se cria um novo projeto quanto em @b{Configurações->Formato}. Na janela de Recursos, há um outro meio de se mudar o tamanho de saída. Clique com o botão direito em um objeto de vídeo e selecione @b{Ajustar ao tamanho do projeto} para ajustar a saída ao objeto de vídeo. Quando novas trilhas forem criadas, o tamanho da trilha sempre se ajustará ao tamanho de saída especificado por estes métodos.

Quando se renderiza, o tamanho de saída do projeto é o tamanho final do vídeo, para onde a linha do temporário será renderizada.

@itemize @bullet
@item Se o tamanho de saída for maior que o do temporário, a imagem transferida a partir do temporário caberá dentro da Trilha de Saída. Qualquer espaço deixado na Saída será deixado em branco.

@center @image{manual_images_intl/output_small}
@center @b{Tamanho da saída (mostrado em verde) é mais largo que o temporário}

@item Se o tamanho de saída for menor que o temporário, então parte do vídeo do temporário será recortada e deixada de fora.

@center @image{manual_images_intl/output_large}
@center @b{Tamanho da saída é muito pequeno para o temporário}

@end itemize

@c cincvdoc_node_number_130
@node Janela de visualização
@chapter Janela de visualização
@cindex Janela de visualização

A janela de visualização é um lugar para carregar e prever suas mídias-fonte e recortes. Aqui você pode dar uma olhada rápida por um bloco de vídeo usando o @b{controle do deslizador}, focar em uma área de trabalho com a @b{região de previsão} ou usar os @b{controles de edição} para recortar e colar segmentos no projeto ou criar um recorte ("clip") para ser usado depois.

@center @image{manual_images_intl/viewer,80mm}
@center @b{A janela de visualização}

Para abrir a janela de visualização, vá para @b{Janela->Mostrar Visor}

A tela é a área do visor onde você vê a mídia sendo reproduzida. Antes de reproduzir qualquer mídia, você primeiro precisa carregá-la no visor.

Para carregar uma mídia no visor:
@enumerate 1
@item Abra a janela @b{gerenciador de recursos} e selecione o @b{gerenciador de recursos} ou a pasta @b{gerenciador de recortes}.
@item Arraste um arquivo do @b{gerenciador de recursos} ou do @b{gerenciador de recortes} para o visor

@center @image{manual_images_intl/drag_to_viewer,101.75mm}
@end enumerate

Você também pode carregar uma mídia no visor clicando com o botão direito do mouse em um arquivo do @b{gerenciador de recursos} e selecionando @b{Ver} do menu que aparecer ou dando um duplo-clique no ícone.

Uma vez que sua mídia seja carregada, você a verá aparecer na tela. Para reproduzi-la, rebobiná-la ou avançá-la, use o @b{controle do deslizador} ou os @b{controles de transporte}.

Você pode mudar o tamanho de exibição da mídia clicando com o botão direito do mouse na tela para ativar o menu de aproximação da tela. Selecione os níveis de aproximação de 50%, 100% ou 200% do tamanho original da mídia.

Quando exibindo a mídia, o visor usa o tamanho de formato de saída definido nas configurações do projeto, não o formato original dos blocos de vídeo. Você pode mudar a saída do projeto para se ajustar ao formato do bloco de vídeo usando a opção @b{Ajustar ao tamanho do projeto} do menu no @b{gerenciador de recursos}.

Aqui, você poderá 'folhear' as fontes de mídia e recortes, selecionando regiões para serem coladas no projeto. Operações feitas no visor afetam um EDL temporário ou um recorte, mas não a Linha do Tempo.

@c cincvdoc_node_number_131
@node Janela de recursos
@chapter Janela de recursos
@cindex Janela de recursos

@menu
* Navegando pelos recursos::
@end menu

Efeitos, transições, recortes e blocos de vídeos são acessados por aqui. A maioria dos recursos são inseridos no projeto arrastando-os para fora da janela de recursos. O gerenciamento da alocação de recursos também é feito aqui.

@c cincvdoc_node_number_132
@node Navegando pelos recursos
@section Navegando pelos recursos
@cindex Navegando pelos recursos

A janela de recursos está dividida em duas áreas. Uma área lista as pastas e a outra área lista os conteúdos das pastas. Indo para a lista de pastas e clicando em uma delas atualiza a área de conteúdo com os conteúdos daquela pasta.

@center @image{manual_images_intl/resources_audio_effects,60mm}
@center @b{A janela de recursos}

Apasta e os conteúdos podem ser dispostos como ícones ou texto.

@b{Clicar com o botão direito do mouse} na pasta ou área de conteúdos revela um menu contendo as opções de formatação. Selecione @b{Exibir texto} para exibir uma listagem em texto. Selecione @b{Ordenar ítens} para ordenar os conteúdos de uma pasta alfabeticamente.

A @b{janela de informação do recurso} exibe informações detalhadas sobre o arquivo de mídia selecionado. Para acessá-la, vá para a pasta de gerenciamento de blocos de vídeo e clique com o botão direito do mouse no título ou ícone do arquivo o qual você tiver interesse. Um menu relacionado ao bloco aparecerá; clique então em Info.

@center @image{manual_images_intl/asset_info,50mm}
@center @b{A janela de informação do recurso}

@c cincvdoc_node_number_133
@node Janela de medidores de nível de som
@chapter Janela de medidores de nível de som
@cindex Janela de medidores de nível de som

Uma janela adicional, a @b{janela de níveis} pode ser trazida a partir do menu @b{Janelas}. A janela de @b{níveis} exibe os níveis de saída de áudio após toda a mixagem ser feita.

@center @image{manual_images_intl/sound_level_meters_window,,80mm}

@center @b{A janela de medidores de nível de som}

Medidores de nível de som aparecem em várias localidades. Eles podem ser colocados ou retirados das janelas de visualização e composição a partir do botão 'exibir medidores'. Eles aparecem no patchbay quando uma trilha de áudio é expandida.  @xref{O patchbay}.  Eles aparecem no monitor de gravação quando áudio estiver sendo gravado.

Os níveis de som em @b{janela de níveis, compositor e visor} correspondem aos níveis de saída final antes que eles sejam recortados para a abrangência da placa de som. No @b{monitor de gravação} eles são os valores de entrada vindos da placa de som. No @b{patchbay}, eles são os níveis de som de cada trilha após todos os efeitos serem processados e antes da mixagem que é jogada para a saída final.

A maioria do tempo, os níveis de áudio possuem marcações numéricas em dB, mas no patchbay não há espaço suficiente.

O nível do som possui um código de cores como um meio extra de determinar o nível do áudio. Mesmo sem as marcações numéricas, a cor do nível de som pode distinguir sentre várias abrangências e níveis excessivos. Olhe para os códigos de cor em um medidor com marcações numéricas para ver quais cores correspondem a qual nível de som. Assim, para os medidores no patchbay com trilhas de áudio expandidas, use os códigos de cor para ver se estão sobrecarregando.

Atente que os níveis de som no Cinelerra podem ir acima de 0 dB@. Isso permite não apenas ver se uma trilha está sendo sobrecarregada mas quanto de informação está sendo perdido pela sobrecarga. Uma sobrecarga de menos de 3 dB normalmente é aceitável. Enquanto uma sobrecarga é tratada como números positivos no Cinelerra, ela é recortada para 0 quando enviada a uma placa de áudio ou arquivo.

A abrangência visível do nível dos medidores de som é configurável em @b{configurações->preferências->interface} (@xref{Interface}.)

@c cincvdoc_node_number_134
@node Controles de transporte
@chapter Controles de transporte
@cindex Controles de transporte

Controles de transporte são tão úteis na navegação quanto o são para reproduzir gravações; por isso são descritos aqui na seção de navegação. Cada uma das janelas de visualização, composição e programa possui um painel de transporte.

@center @image{manual_images_en/transport_panel,130mm}
@center @b{O panel de transporte}.

O painel de transporte é controlado tanto pelo teclado como pela interface gráfica. Para cada uma das operações que ele performa, a posição de início é a posição do ponto de inserção da janela de Programa e o slider na janela de Composição. A posição final é tanto o fim ou começo da Linha do Tempo ou o fim ou começo da região selecionada, caso haja uma.

Aorientação do fim ou início depende da direção da reprodução. Se ela for para a frente, a posição final é o fim da região selecionada. Se é para trás, a posição final é o começo da região selecionada.

O ponto de inserção se move para acompanhar a reprodução. Quando a reprodução pára, o ponto de inserção fica no ponto onde ela parou. Assim, ao reproduzir o vídeo, você muda a posição do ponto de inserção.

A interface de teclado é normalmente a mais rápida e possui mais velocidades. As teclas de transporte estão arranjadas em um @b{T} lateral na área numérica do teclado.

@multitable @columnfractions .08 .17 .08 .17 .08 .17 .08 .17
@item @kbd{4}
@tab Quadro anterior
@tab @kbd{5}
@tab Lento reverso
@tab @kbd{6}
@tab Reverso
@tab @kbd{+}
@tab Reverso rápido
@item @kbd{1}
@tab Quadro à frente
@tab @kbd{2}
@tab Á frente lento
@tab @kbd{3}
@tab Reproduzir
@tab @kbd{Enter}
@tab À frente rápido
@item @kbd{0}
@tab Parar
@tab
@tab
@tab
@tab
@tab
@tab
@end multitable

Pressionando qualquer tecla no teclado duas vezes pausa a exibição.

Quando estiver utilizando funções de avanço de quadros, o comportamento pode parecer estranho. Se você fizer o avanço de um quadro e depois voltar o mesmo quadro, o quadro exibido não mudará. Isso acontece porque a posição de reprodução não é o quadro, mas o tempo entre dois quadros. O quadro renderizado é a área que cruza a posição de reprodução. Quando você aumenta o tempo entre dois quadros por um e o decresce por um, você cruza o mesmo quadro nas duas vezes e portanto o mesmo quadro é exibido.

O comportamento de transporte muda se você mantiver pressionado o @key{CTRL} quando usando qualquer dos comandos de transporte. Isso faz o ponto de início ser o ponto de entrada caso a reprodução seja para frente e o ponto de saída se for reversa. Se for para a frente, o ponto de saída se torna o ponto final e se estiver sendo reversa, o ponto de entrada torna-se o ponto final. Se nenhum ponto de entrada/saída forem especificados, o comportamento volta a ser o de usar o ponto de inserção e limites de trilhas como os pontos de início e término.

É possível usar um hardware JogShuttle@footnote{Ver a mensagem de David Arendt à lista de discussão do Cinelerra CV em 2003-11-11 para mais informações}

@c cincvdoc_node_number_135
@node Barra de tempo
@chapter Barra de tempo
@cindex Barra de tempo

As funções de navegação das janelas de Visualização e Composição comportam-se de maneira muito similar. Cada uma possui uma barra de tempo e um slider abaixo da saída de vídeo. Ambos são críticos para a navegação.

@center @image{manual_images_en/timebarslider,160mm}

@cindex Região de previsão
A barra de tempo representa todo o tempo coberto pelo programa. Quando você define marcadores e pontos de entrada/saída, eles também aparecem nela. Finalmente, a barra de tempo define uma região conhecida como a @b{região de previsão}.

A @b{região de previsão} é a região da Linha do Tempo que é afetada pelo slider. O slider cobre apenas o tempo coberto pela região de previsão. Ao usar uma região de previsão dentro do programa inteiro e usar o slider dentro da região de previsão, você pode buscar rápida e precisamente no Compositor e no Visualizador.

Quando você substitui o projeto atual por um arquivo, a região de previsão automaticamente se redimensiona para cobrir todo o arquivo. Quando você insere novos dados ou muda o tamanho do projeto atual, a região de previsão fica do mesmo tamanho ou encolhe. Portanto, você precisará redimensionar a região de previsão.

Carregue um arquivo e então deslize por ele usando o slider do Compositor. O ponto de inserção na janela principal segue o Compositor. Mova o apontador por sobre a barra de tempo do Compositor até que ele se torne um apontador de redimensionamento à esquerda. Clique nele e arraste-o para a direita. A região de previsão deve ter mudado e o slider redimensionado proporcionalmente.

Vá para a direita da barra de tempo até que um apontador de redimensionamento à direita apareça. Arraste-o para a esquerda de modo que a região de previsão encolha.

Vá para o centro da região de previsão na barra de tempo e arraste-a em volta para se convencer de que ela pode ser movida.

@b{Nota:} Quando você insere coisas ou muda o tamanho do projeto atual, a região de previsão fica do mesmo tamanho e encolhe. Portanto, você precisa redimensioná-la.

@center @image{manual_images_intl/previewregion,160mm}
@center @b{Região de previsão no compositor}

Se você for para o slider e deslizá-lo por sobre a região de previsão diminuída, você verá o que slider afeta apenas a região de previsão. Abarra de tempo e o slider na janela de visualização funcionam exatamente do mesmo modo.

Marcadores e pontos de entrada/saída são totalmente suportados pelo Visualizador e pelo Compositor. A única diferença entre o visualizador e o compositor é que o compositor reflete o estado do programa enquanto o visualizador reflete o estado de um recorte mas não do programa.

Quando você pressiona o @b{botão de marcador} no Compositor, o marcador aparece tanto na barra de tempo do compositor quanto na barra de tempo do programa.

Quando você seleciona um marcador ou ponto de entrada/saída no Compositor, o ponto de inserção na janela de Programa pula para aquela posição. Para "folhear" seu vídeo e então mover o ponto de inserção para a parte visível da linha do tempo, use o botão @b{Ir para manual} do compositor.

@center @image{manual_images_intl/viewer_labels,160mm}
@center @b{Marcadores e pontos de entrada/saída no visor}.

Nas janelas de Visualização e Composição, marcadores e pontos de entrada/saída são dispostos na barra de tempo. Ao invés de exibir apenas uma região do programa, a barra de tempo exibe todo o programa aqui.

Como a janela de programa, o Compositor possui a função de aproximação. Primeiro, o menu que se abre à base da janela de Composição possui um número de opções de aproximação. Quando marcado para @b{Auto}, o vídeo é aproximado para se ajustar o mais próximo possível ao tamanho da Janela de Composição. Quando marcado para qualquer outra porcentagem, o vídeo é aproximado por uma razão de 2 e barras de rolagem podem ser usadas para navegarem pela saída de vídeo. Quando o vídeo for aproximado de modo que fique maior que o tamanho da janela, você pode usar tanto as barras de rolagem quanto o @b{botão do meio do mouse} para navegar pelo vídeo. Isso é exatamente como o programa Gimp faz.

Além disso, o botão de aproximação @image{manual_images_intl/magnify,7mm} faz com que a janela de Composição entre no modo de aproximação. No modo de aproximação, clicar nas aproximações da saída de vídeo enquanto faz um @b{clicar-com-o-ctrl} na saída de vídeo faz o vídeo se afastar. Se você possui uma rodinha no mouse, rodá-la aproxima ou afasta o vídeo também.

Aproximar ou afastar com a ferramenta de aproximação não muda a saída renderizada. Esta função serve apenas para observar detalhes no vídeo ou para redimensioná-lo para caber na área de trabalho.

Reproduzir vídeo no Compositor quando aproximado para qualquer tamanho que não 100% (o tamanho original), faz com que o Cinelerra use mais passos de processamento. Isso pode afetar a performance em sistemas mais lentos.

@c cincvdoc_node_number_136
@node Efeitos tempo-real
@chapter Efeitos tempo-real
@cindex Efeitos tempo-real
@cindex Efeitos, tempo-real

Estes são posicionados abaixo da trilha nas quais estão sendo aplicados. Processam a trilha quando ela estiver sendo reproduzida, sem armazenamento permanente da saída, exceto quando o projeto for renderizado.

Todos os efeitos tempo-real estão listados na Janela de Recursos, divididos em dois grupos: efeitos de áudio e efeitos de vídeo. Efeitos de áudio devem ser arrastados da janela de recursos para as trilhas de áudio. Efeitos de vídeo devem ser arrastados para as trilhas de vídeo.

Se há informação na trilha de destino, o efeito será aplicado em toda a trilha. Se não há informação, o efeito é apagado. Finalmente, se uma região da trilha estiver selecionada, o efeito é colado nesta região, independentemente de se há ou não informação ali.

Alguns dos efeitos não processam informação, mas a sintetizam. No caso de um efeito de síntese, você quererá selecionar uma região da trilha de forma que a operação de arraste o cole sem que ele seja apagado.

Quando se arrasta mais de um efeito para uma trilha, você verá os efeitos sendo dispostos da base para o topo, na base da trilha. Quando a trilha for reproduzida, os efeitos são processados do topo para a base. A saída do efeito do topo torna-se a entrada do efeito da base e assim por diante.

Além de poderem ser arrastados a partir da janela de recursos, efeitos podem ser aplicados a uma trilha a partir de um menu. Clique com o botão direito do mouse em uma trilha e selecione @b{adicinar efeito} do menu. O diálogo adicionar efeito dá mais controle do que o simples arrastar e soltar - a caixa de diálogo permite que você adicione mais dois tipos de efeitos: efeitos compartilhados e trilhas compartilhadas. Selecione um plugin da coluna de @b{Plugins} e pressione @b{Adicionar...} abaixo da coluna de plugins para adicioná-lo. O resultado é o mesmo de como se o efeito houvesse sido arrastado da janela de recursos.

Quando um efeito existe embaixo de uma trilha, ele normalmente precisa ser configurado. Vá para o efeito e clique com o botão direito do mouse para revelar a caixa do efeito. Nesta caixa, existe a opção @b{Mostrar}. Esta opção faz com que a caixa de configuração do efeito apareça abaixo do cursor. A maioria dos efeitos possuem configuração, mas alguns não. Caso ele não possua, nada aparecerá quando a opção @b{Mostrar} for selecionada. Quando você mexe nos parâmetros de configuração do efeito, normalmente eles agem sobre toda a duração do efeito.

@menu
* Tipos de efeitos tempo-real::
* Editando efeitos tempo-real::
* Efeitos tempo-real de áudio::     Efeitos tempo-real de áudio
* Efeitos tempo-real de vídeo::     Efeitos tempo-real de vídeo
@end menu

@c cincvdoc_node_number_137
@node Tipos de efeitos tempo-real
@section Tipos de efeitos tempo-real
@cindex Tipos de efeitos tempo-real

Os outros dois tipos de efeitos suportados pela caixa de diálogo Adicionar Efeito são efeitos reciclados. Para usar um efeito reciclado, três pré-requisitos devem ser satisfeitos:
@itemize @minus
@item Deve haver outros efeitos na linha do tempo.
@item Os outros efeitos devem ser do mesmo tipo que o da trilha na qual você está adicionando o efeito. Se a trilha é de áudio, os efeitos devem ser de áudio; se a trilha é de vídeo, os efeitos devem ser de vídeo.
@item O ponto de inserção ou região selecionada deve começar dentro dos outros efeitos.
@end itemize

No caso de um efeito compartilhado, essas condições devem ser verdadeiras. No caso de uma trilha compartilhada, eles precisam ser apenas outra trilha na linha do tempo do mesmo tipo que a trilha para a qual você está aplicando o efeito. Se você clicou com o botão direito do mouse em uma trilha de vídeo, não haverá nada na coluna @b{Trilhas compartilhadas} se nenhuma outra trilha de vídeo existir. Se você clicou com o botão direito do mouse em uma trilha de áudio não haverá nada na coluna de trilha compatilhada caso não exista outra trilha de áudio.

Se efeitos compartilhados ou trilhas compartilhadas estiverem disponíveis, eles aparecerão nas colunas @b{Efeitos compartilhados} e @b{Trilhas compartilhadas}. O botão @b{Adicionar} abaixo de cada coluna faz tudo o que estiver destacado na coluna ser adicionado abaixo da trilha atual.

Efeitos compartilhados e trilhas compartilhadas permitem que coisas muito singulares possam ser feitas. No caso de um efeito compartilhado, o efeito compartilhado será tratado como uma cópia do efeito original, exceto que no efeito compartilhado a caixa de configuração não pode ser acessada. Toda a configuração do efeito compartilhado é determinada pela configuração do efeito original e apenas a caixa de configuração do efeito original pode ser acessada.

Quando um efeito compatilhado é reproduzido, ele é processado como um efeito normal, exceto que a configuração é copiada do efeito original. Alguns efeitos detectam quando estão sendo compartilhados, como os efeitos de reverberação e o compressor. Esses efeitos determinam quais trilhas os estão compartilhando e ou mixam as duas trilhas ou usam uma delas para marcar algum valor. O reverb mixa as trilhas para simular ambiência. O compressor usar umas das trilhas compartilhadas como disparador ("trigger").

@cindex Combinando trilhas
@cindex Trilhas, combinando
@cindex Trilha compartilhada
Quando uma trilha original possui uma @b{trilhas compartilhada} como um de seus efeitos, a própria trilha compartilhada é usada como um efeito tempo-real. Isso é mais comumente conhecido como @b{combinar trilhas}, mas o Cinelerra chega ao mesmo resultado adicionando trilhas compartilhadas. O fade e qualquer efeito na trilha compartilhada são aplicados à trilha original. Uma vez que a trilha compartilhada tenha processado a informação, a trilha original lâ quaisquer efeitos que estejam abaixo da trilha compartilhada e então os compõem na saída.

Além disso, uma vez que a trilha compartilhada tenha processado a saída da trilha original como um efeito em tempo-real, a trilha compartilhada se mixa na saída com suas configurações de panorâmica, modo e projetor. Assim, duas trilhas estão mixando a mesma informação na saída. Na maioria das vezes, você não vai querer que a trilha compartilhada mixe a mesma informação que a trilha original na saída. Você vai querer que ela pare logo antes do estágio de mixagem e dê a informação de volta à trilha original. Faça isso habilitando o @image{manual_images_intl/mutepatch_up} botão de mutar próximo a cada trilha que você não quer que seja mixada na saída.

Suponha que você estivesse fazendo um vídeo e você queria que a trilha compartilhada fosse composta junto com a informação da trilha original na saída uma segunda vez. No caso de vídeo, o vídeo a trilha compartilhada sempre apareceria abaixo do vídeo da trilha original, independentemente de se ele estivesse no topo da trilha original. Isso acontece porque trilhas compartilhadas são compostas por ordem de sua adição. Já que ela é parte da trilha original, ela deve ser composta antes que a trilha original seja composta.

@c cincvdoc_node_number_138
@node Editando efeitos tempo-real
@section Editando efeitos tempo-real
@cindex Efeitos tempo-real, editando
Muitas operações existem para manipular efeitos uma vez que eles estejam na linha do tempo. Já que mixar efeitos e mídia é um trabalho complexo, os métodos usados na edição de efeitos não são tão concisos como recortar e colar. Parte da edição acontece pelo arraste de pontos de entrada/saída, parte da edição acontece a partir de menus e parte acontece arrastando efeitos.

Normalmente quando você edita as trilhas, os efeitos seguem as decisões de edição. Se você cortar a partir de uma trilha, o efeito enconlhe. Se você arrastar pontos de entrada/saída, o efeito muda de duração. Este comportamento pode ser desabilitado selecionando @b{Configurações->editar efeitos} na janela de projeto. Isso separa os efeitos das operações de edição, mas e se você só quer editar os efeitos?

Mova o cursor da linha do tempo por sobre as bordas do efeito até que ele mude para um ícone de redimensionamento à esquerda ou à direita. Neste estado, se você arrastar o final do efeito, ele fará uma edição igual à que arrastar o final de uma trilha faz.

Os três comportamentos de expansão/encolhimento de trilha se aplicam à edição de efeitos e eles estão relacionados aos botões do mouse conforme você configurou em @b{preferências de interface} @xref{Interface}.  Quando você faz uma edição de expansão/encolhimento em um efeito, a borda do efeito é movida ao arrastá-la. Ao contrário da edição de trilha, o efeito não possui uma duração baseada na fonte. Você pode extendê-lo tanto quando desejar sem que haja limites.

Também diferentemente da edição de trilhas, a posição de início da operação de arraste não condiciona a decisão de edição à mídia. A mídia à qual o efeito está relacionado não segue as edições de efeito. Outros efeitos, entretanto, seguem as decisões de edição feitas em um efeito. Se você arrastar o final de um efeito que esteja alinhado a efeitos em outras trilhas, os efeitos nas outras trilhas serão editados enquanto a mídia permanecerá a mesma.

O que acontece se você arrastar o final de um efeito para dentro, deixando um monte de tempo não afetado por ele ao final da trilha? Quando você arrasta um efeito a partir da Janela de Recursos, você pode inseri-lo na porção da fileira não ocupada pela operação de arraste. Efeitos tempo-real são organizados em fileiras abaixo da trilha. Cada fileira pode ter vários efeitos.

Em alguns casos, você vai querer que a operação de arraste mude apenas um dos efeitos enfileirados. Isso pode ser feito primeiro posicionando o ponto de inserção no começo ou no final do efeito. Pressione a tecla @key{SHIFT} quando estiver começando a operação de arraste. Isso faz com que a operação mude apenas uma fileira de efeitos.

Além de arrastar para redimensionar a abrangência do efeito, você pode movê-los para cima ou par baixo. Cada trilha pode possuir uma pilha de efeitos abaixo dela. Ao mover um efeito para cima ou para baixo, você muda a ordem na qual os efeitos são processados na trilha. Vá para um efeito e clique com o botão direito do mouse para revelar o menu de efeitos. As opções @b{Mover para cima} e @b{Mover para baixo} movem o efeito para cima ou para baixo.

@cindex Efeitos compartilhados
@cindex Efeitos, compartilhados
Quando você estiver movendo efeitos para cima ou para baixo, esteja ciente que se eles estiverem compartilhados como @b{shared effects}, quaisquer referências apontarão para um efeito diferente após a operação de movê-los.

Finalmente, há o arraste dos efeitos propriamente ditos. Arrastar efeitos se parece muito a arrastar os blocos de edição. Você deve selecionar a @image{manual_images_intl/arrow,2.67mm} seta para entrar no modo de arrastar e soltar antes de conseguir arrastar efeitos. Os efeitos se colam às bordas das mídias, dos efeitos e das trilhas. Esteja ciente que se você arrastar uma referência a um efeito compartilhado, a referência normalmente apontará para o efeito errado depois disso.

Clique com o botão direito do mouse em um efeito para revelar o menu para o efeito. Selecione @b{adicionar...} para mudar o efeito ou mudar a referência caso ele seja um efeito compartilhado.

@c cincvdoc_node_number_139
@node Efeitos tempo-real de áudio
@section Efeitos tempo-real de áudio
@cindex Efeitos tempo-real de áudio

@menu
* Compressor::           Como reduzir a abrangência dinâmica do áudio.
* Áudio ao vivo::        Passar áudio da placa de som diretamente para a linha do tempo.
* Mudança de freqüência::
* Reverter áudio::       Como reproduzir regiões ao reverso.
* Atrasar áudio::
* Depurador::
* DepuradorFFT::
* Limar pontas::
* EQ Paramétrica::
* Verb livre::
* Ganho::
* Colégio de Heroína::
* Interpolar::
* Inverter Áudio::
* Áudio em loop::
* Sobreposição::
* Nível do Som::
* Espectrograma::
* Sintetizador::
* Esticamento de tempo::
@end menu

@c cincvdoc_node_number_140
@node Compressor
@subsection Compressor
@cindex Compressor

@image{manual_images_intl/compressor,12.5mm}

Contrário à experiência da ciência da computação, o compressor de áudio não reduz a quantidade de informação necessária para armazenar o áudio. O compressor de áudio reduz a abrangência dinâmica do áudio. Na verdade, no Cinelerra, o compressor faz a função de um expansor e compressor.

O compressor funciona calculando o nível máximo de som dentro de um certo período de tempo da posição atual. O nível máximo de som é usado como o nível de entrada de som. Para cada nível de entrada de som há um nível de saída de som especificado pelo usuário. O ganho na posição atual é ajustado de forma que o nível máximo de som na abrangência de tempo seja o valor especificado pelo usuário.

O compressor possui um gráfico que correlaciona cada nível de entrada de som a um nível de saída. A direção horizontal é o nível de entrada de som em dB@. A direção vertical é o nível de saída de som em dB@. O usuário especifica os níveis de saída de som criando pontos no gráfico. Clique no gráfico para criar ym ponto. Se dois pontos existem, arraste um ponto por sobre o outro para apagá-lo. O último ponto a ser selecionado terá seus valores exibidos em caixas de texto para um ajuste mais preciso.

Para fazer o compressor reduzir a abrangência dinâmica do áudio, faça com que todos os valores de saída sejam mais altos que os valores de entrada exceto 0 dB@. Para fazer o compressor expandir a abrangência dinâmica do áudio, faça todos os valores de saída exceto 0 dB serem mais baixos que os valores de entrada. O algoritmo atual limitará todos os níveis de som acima de 0 dB para 0 dB, então, para conseguir um efeito de sobrecarga ("overload"), ponha um efeito de ganho antes do compressor para reduzir todos os níveis e siga-o com outro efeito de ganho para amplificar todos os níveis de volta para acima de 0 dB@.

@b{Segundos para reação:} Determina para onde com relação à posição atual o nível máximo de áudio é levado e quão rápido o ganho é ajustado para alcançar este pico. É notado em segundos. Se este número for negativo, o compressor lê à frente da posição atual para obter o pico futuro. O ganho é jogado ("ramped") para aquele pico por sobre um tempo de reação. Isso o permite chegar ao nível de saída desejado exatamente quando o pico de entrada ocorre na posição atual.

Se o tempo de reação for positivo, o compressor busca apenas a posição atual para o ganho e joga ("ramps") o ganho por sobre um tempo de reação para chegar ao nível de saída desejado. Ele chega ao nível de saída exatamente um período de reação após detectar o pico de entrada.

@b{Segundos para declínio:} Se o pico for maior que o nível atual, o compressor joga ("ramps") o ganho para cima até o valor de pico. Então, se um pico futuro for menor que o pico atual, ele joga o ganho para baixo. O tempo levado para jogar o ganho para baixo pode ser maior que o para elevá-lo. Este tempo de jogá-lo para baixo são os segundos de queda.

@b{Tipo de Gatilho:} O compressor é um efeito multi-canal. Várias trilhas podem dividir um compressor. Como o sinal de muitas trilhas é interpretado é determinado pelo tipo de gatilho.

O @b{Tipo de Gatilho} usa o valor informado na caixa de texto @b{Gatilho} como o número da trilha a ser usada como entrada para o compressor. Isso permite que uma trilha que não é nem ouvida determine a altura de outras trilhas.

O gatilho @b{Máximo} pega a trilha mais alta e a usa como a entrada para o compressor.

O tipo de gatilho @b{Total} adiciona o sinal de todas as outras trilhas e usa o total como entrada para o compressor. Essa é a compressão que soa mais natural e é ideal quando a média de várias trilhas é jogada para falantes únicos ("single").

@b{Gatilho:} O compressor é um efeito multi-canal. Várias trilhas podem dividir um compressor. Normalmente apenas uma trilha é sondada para o pico de entrada. Esta trilha é especificada pelo @b{Gatilho}. Ao dividir várias trilhas e reproduzi-las com o valor de gatilho, você pode fazer uma onda seno de uma trilha seguir a amplitude de uma bateria de outra trilha, por exemplo.

@b{Suavizar apenas:} Para visualizar o que o compressor está fazendo para o nível de som, esta opção faz com que ele substitua a onda sonora com apenas o valor atual de pico. Assim fica bem fácil ver como os @b{Segundos para reação} afetam os valores detectados de pico.

@c cincvdoc_node_number_141
@node Atrasar áudio
@subsection Atrasar áudio
@cindex Atrasar áudio

@image{manual_images_intl/delayaudio,12.5mm}

Apenas informe quantos segundos você quer atrasar a trilha de vídeo.

@c cincvdoc_node_number_142
@node Depurador
@subsection Depurador
@cindex Depurador

@image{manual_images_intl/denoise,13mm}

conserte-me.

@c cincvdoc_node_number_143
@node DepuradorFFT
@subsection DepuradorFFT
@cindex DepuradorFFT

@image{manual_images_intl/denoisefft,13mm}

conserte-me.

@c cincvdoc_node_number_144
@node Limar pontas
@subsection Limar pontas
@cindex Limar pontas

@image{manual_images_intl/despike,12.5mm}

conserte-me.

@c cincvdoc_node_number_145
@node EQ Paramétrica
@subsection EQ Paramétrica
@cindex EQ Paramétrica

@image{manual_images_intl/parametric,12.5mm}

conserte-me.

@c cincvdoc_node_number_146
@node Verb livre
@subsection Verb livre
@cindex Verb livre

@image{manual_images_intl/freeverb,12.5mm}

conserte-me.

@c cincvdoc_node_number_147
@node Ganho
@subsection Ganho
@cindex Ganho

@image{manual_images_intl/gain,12.5mm}

conserte-me.

@c cincvdoc_node_number_148
@node Colégio de Heroína
@subsection Colégio de Heroína
@cindex Colégio de Heroína

@image{manual_images_intl/reverb,12.5mm}

conserte-me.

@c cincvdoc_node_number_150
@node Interpolar
@subsection Interpolar
@cindex Interpolar

@image{manual_images_intl/interpolateaudio,13.25mm}

conserte-me.

@c cincvdoc_node_number_151
@node Inverter Áudio
@subsection Inverter Áudio
@cindex Inverter Áudio

@image{manual_images_intl/invertaudio,12.5mm}

conserte-me.

@c cincvdoc_node_number_152
@node Áudio ao vivo
@subsection Áudio ao vivo
@cindex Efeito de áudio ao vivo

@image{manual_images_intl/liveaudio,12.5mm}

Este efeito lê o áudio diretamente da entrada da placa de som. Ele substitui qualquer áudio na trilha, então é normalmente aplicado a uma trilha vazia.

Para usar o Áudio Ao Vivo, destaque uma região horizontal de uma trilha de áudio ou defina pontos de entrada e saída. Então, solte o efeito Áudio Ao Vivo nela. Crie trilhas extras e adicione cópias compartilhadas do primeiro efeito Áudio Ao Vivo às outras trilhas para possuir canais de gravação extras.

O Áudio Ao Vivo usa o driver de áudio selecionado em @b{Configurações->Preferências->Reprodução->Saída de Audio} para gravação, mas ao contrário do que acontece em gravações, ele usa o @b{Tamanho do buffer de reprodução} como o tamanho de buffer de gravação e usa a @b{taxa de amostragem do projeto} como taxa de amostragem.

Essas configurações são críticas, já que algumas placas de som não conseguem gravar no mesmo tamanho de buffer em que elas fazem a reprodução. Áudio Ao Vivo tem sido mais confiável quando o driver de gravação é o ALSA e o tamanho do fragmento de reprodução ("playback fragment") é 2048.

Coloque outros efeitos após o Áudio Ao Vivo para processar entrada da placa de som em tempo-real.

Agora, a notícia ruim. Com o Áudio Ao Vivo não há pré-leitura ("read-ahead"), então efeitos como o compressor ou atrasarão se eles tiverem pré-leitura habilitada ou a reprodução vai sofrer um under-run.

Outro problema é que às vezes o relógio de gravação na placa de som é levemente mais lento que o relógio da reprodução. A gravação eventualmente fica para trás e a reprodução soa zoada.

Finalmente, Áudio Ao Vivo não funciona ao reverso.

@c cincvdoc_node_number_153
@node Áudio em loop
@subsection Áudio em loop
@cindex Áudio em loop

@image{manual_images_intl/loopaudio,12.5mm}

conserte-me.

@c cincvdoc_node_number_154
@node Sobreposição
@subsection Sobreposição
@cindex Sobreposição

@image{manual_images_intl/overlay,13.25mm}

conserte-me.

@c cincvdoc_node_number_155
@node Mudança de freqüência
@subsection Mudança de freqüência
@cindex Mudança de freqüência
@cindex Áudio, mudança de freqüência

@image{manual_images_intl/pitch,12.5mm}

Assim como os métodos de esticamento de tempo, existem três métodos de modificação de nível: @b{Mudança de freqüência}, @b{Refazer amostragem}, e @b{caixa de diálogo de informação do recurso}.  Mudança de Freqüência é um efeito tempo-real que pode ser arrastado e solto em trilhas de áudio graváveis. Mudança de Freqüência usa uma transformação Fourier rápida para tentar mudar a freqüência sem modificar a duração, mas isso introduz artefatos.

Já que os artefatos ("windowing artifacts") são menos obstrusivos em um áudio que obviamente sofreu uma mudança de freqüência, a Mudança de Freqüência é principalmente útil para mudanças extremas de freqüência. Para mudanças médias de freqüências, use @b{Refazer amostragem} da interface @b{Áudio->Renderizar efeito}. Refazer a Amostragem pode mudar a freqüência em até 5% sem uma mudança notável na duração.

Um outro jeito de mudar a freqüência levemente é ir para a janela de @b{Recursos}, destacar a pasta @b{mídia}, clicar com o botão direito do mouse em um arquivo de áudio e selecionar @b{Info}. Ajuste a taxa de amostragem na caixa de diálogo @b{Info} para ajustar a freqüência. Este método também requere clicar com o botão esquerdo do mouse na borda direita das trilhas de áudio e arrastá-las para a esquerda ou para a direita para corresponderem às mudanças de duração.

@c cincvdoc_node_number_156
@node Reverter áudio
@subsection Reverter áudio
@cindex Efeito reverter áudio

@image{manual_images_intl/reverseaudio,12.5mm}

Aplique @b{Reverter áudio} a uma trilha de áudio e reproduza-a de trás para frente. O som tocará para frente.

Saiba que quando reverter o áudio, a onda sonora na linha do tempo não mais refletirá a saída revertida.

@c cincvdoc_node_number_157
@node Nível do Som
@subsection Nível do Som
@cindex Nível do Som

@image{manual_images_intl/level,12.5mm}

conserte-me.

@c cincvdoc_node_number_158
@node Espectrograma
@subsection Espectrograma
@cindex Espectrograma

@image{manual_images_intl/spectrogram,12.5mm}

conserte-me.

@c cincvdoc_node_number_159
@node Sintetizador
@subsection Sintetizador
@cindex Sintetizador

@image{manual_images_intl/synthesizer,12.5mm}

conserte-me.

@c cincvdoc_node_number_160
@node Esticamento de tempo
@subsection Esticamento de tempo
@cindex Esticamento de tempo

@image{manual_images_intl/timestretch,12.5mm}

conserte-me.

@c cincvdoc_node_number_161
@node Efeitos tempo-real de vídeo
@section Efeitos tempo-real de vídeo
@cindex Efeitos tempo-real de vídeo

@menu
* 1080 para 480::       			Como converter HDTV em SD
* TV Envelhecendo::    				Como conseguir uma aparência de filme antigo
* Desfocar::
* Brilho/Contraste::    			Como ajustar brilho e contraste
* TV Queimando::  				Como fazer seu vídeo "queimar"
* Chroma key::        				Criar transparência baseada em similaridades de cores
* Chroma key (HSV)::
* Balanço de Cores::
* Atrasar Vídeo::
* Depurar vídeo::
* Depurar vídeo2::
* Decimar::          				Como reduzir taxas de quadros eliminando quadros similares
* Desentrelaçar::       			Como converter vídeo entrelaçado em vídeo progressivo
* Chave de diferença::    			Criar transparência baseada em diferenças de cor
* TV Pontilhada::           			Como dar a seu vídeo uma aparência de "TV Pontilhada"
* Reduzir amostragem::     			Como reduzir o tamanho de uma imagem jogando informação fora
* Campos para quadros::  			Como recuperar vídeo entrelaçado a partir de "bobbed video"
* Inverter::              			Como inverter uma trilha de vídeo
* Quadros para campos::
* Congelar Quadro::
* Gama::
* Gradiente::
* Histograma::         			Como mudar o mapeamento de diferentes valores de brilho
* TV Holográfica::
* Saturação de tons::    			Como ajustar a saturação e a gradação de tons
* Interpolar vídeo::
* Interpolar pixels:: 				Como criar uma ilusão de taxas de quadros mais altas
* Telecine Inverso::  				Como converter quadros "pull down" para quadros progressivos
* Inverter Vídeo::
* Desfoque Linear::
* Vídeo Ao Vivo::        			Passar o vídeo da placa de captura diretamente para a linha do tempo
* Vídeo em loop::        			Como fazer regiões da linha do tempo ficarem em loop
* Moção::            				A arte de mapear movimento
* Desfoque de movimento::
* Pintura a óleo::      			Como fazer seu vídeo se parecer a uma pintura
* Sobrepor vídeo::
* Perspectiva::       				Como modificar a perspectiva de uma trilha de vídeo
* Polar::             				Como dobrar e embrulhar seu vídeo
* RGB-601::
* Desfoque Radial::
* Mudar taxa de quadros - RT::         		Mudar o número de quadros em uma seqüência
* Redirecionar::           			Redirecionar canais para uma trilha diferente
* Reverter vídeo::     				Como reproduzir regiões ao reverso
* Rotacionar::            			Como rotacionar seu vídeo
* SVG via Inkscape::
* Escala::
* Média Temporal Seletiva::
* Aguçar::
* Mudar Entrelaçamento::
* Inverter canais::
* Entrada::         				Como conseguir monocromo de uma região da imagem
* Média de tempo::      			Como adicionar padrões de trilha ou aumentar a qualidade da imagem estática
* Frente de Tempo::
* Título::             				Como adicionar texto a uma trilha a partir do Cinelerra.
* Trasladar::
* Desaguçar::           			Como desaguçar seu vídeo
* Escopo do Vídeo::        			Como ver a abrangência dinâmica da intensidade e gradação de tons
* Onda::
* Rodopiar::
* YUV::
* Desfoque de Aproximação::
@end menu

@c cincvdoc_node_number_162
@node 1080 para 480
@subsection 1080 para 480
@cindex Efeito 1080 para 480

@image{manual_images_intl/1080to540,12.5mm}

A maioria das transmissões de tv são recebidas com uma resolução de 1920x1080, mas se originam de uma fonte 720x480 no estúdio. É uma perda de espaço comprimir todo o 1920x1080 se os únicos detalhes resolvíveis são 720x480. Infelizmente, redimensionar um vídeo 1920x1080 para 720x480 não é tão simples como encolhê-lo.

Na estação de tv, o material 720x480 original foi primeiro convertido para campos de 720x240. Cada campo foi então re-escalado para 1920x540. Os dois campos 1920x540 foram finalmente combinados com entrelaçamento para formar a imagem 1920x1080. Esta técnica permite que uma tv de consumidor reproduza a imagem re-amostrada sem circuitos extras para segurar o entrelaçamento 720x480 em uma imagem 1920x1080.

Se você simplesmente desentrelaçasse as imagens 1920x1080, você acabaria com uma resolução de 720x240. O efeito @b{1080 para 480} extrai propriamente dois campos de tamanho 1920x540 da imagem, redimensiona-os separadamente e os combina de novo para restaurar uma imagem 1920x480 entrelaçada. O efeito @b{Escala} deve ser então aplicado para reduzir o tamanho horizontal para 960 ou 720 dependendo da razão de aspecto original.

As trilhas para as quais @b{1080 para 480} for aplicado precisam estar a uma resolução de 1920x1080. As configurações em @b{configurações->formato} devem estar em uma resolução de pelo menos 720x480.

O efeito não sabe se a primeira fileira da imagem 1920x1080 pertence à primeira fileira do 720x480 original. Você deve especificar o que a primeira fileira é nas configurações do efeito.

A saída deste efeito é uma imagem pequena no meio do quadro 1920x1080 original. Use o projetor para centralizar a imagem de saída no reprodutor.

Finalmente, uma vez que você tenha um vídeo entrelaçado 720x480, você pode tanto aplicar @b{Quadros para campos} ou @b{Telecine Inverso} para recuperar mais dos quadros progressivos originais.

@c cincvdoc_node_number_163
@node TV Envelhecendo
@subsection TV Envelhecendo
@cindex TV Envelhecendo

@image{manual_images_intl/aging,17mm}

Este efeito é aquele que você usa se quiser chegar a um aspecto de "filme antigo" ou aparência de programa de tv. Ele vai colocar linhas pra cima e pra baixo do vídeo, além de colocar uns pontos pretos na tela. O uso é feito junto com Brilho/Contraste e Balanço de Cores para fazer seu vídeo parecer realmente um vídeo antigo em preto e branco.

@c cincvdoc_node_number_164
@node Desfocar
@subsection Desfocar
@cindex Desfocar

@image{manual_images_intl/blur,12.5mm}

Este efeito desfoca uma trilha de vídeo. Os parâmetros são:
@itemize @bullet
@item @b{Horizontal e vertical} @*
Estes parâmetros são usados para dizer qual dos campos o desfoque afetará. Pode ser ambos os campos.
@item @b{Raio} @*
Use este deslizador para definir a quantidade de desfoque que será aplicada.
@item @b{Desfocar alfa, vermelho, verde, azul} @*
Especifica quais canais de cores têm de ser desfocados.
@end itemize

@c cincvdoc_node_number_165
@node Brilho/Contraste
@subsection Brilho/Contraste
@cindex Brilho/Contraste
@cindex Contraste

@image{manual_images_intl/brightness,12.5mm}

Se você quer esclarecer uma tomada escura ou adicionar luz, esta é a ferramente a ser usada. Não use este efeito em excesso para não degradar a qualidade de seu vídeo. Use-o junto com quadros-chave para fazer brilhar uma tomada longa que está escura no começo, mas clara ao final. Geralmente, você vai querer mudar o brilho e o contraste usando mais ou menos os mesmos valores (por exemplo, escuridão 28, contraste 26) de forma que as cores originais permaneçam intactas.

@c cincvdoc_node_number_166
@node TV Queimando
@subsection TV Queimando
@cindex TV Queimando
@cindex Vídeo queimando

@image{manual_images_intl/burn,16mm}

O efeito de vídeo queimando faz o seu vídeo "queimar" onde há pequenos pedaços de luz colorida no vídeo, nas bordas de uma camiseta branca por exemplo. Ele pode ser um bom recurso para um vídeo musical ou uma ferramenta para te ajudar a soltar a imaginação em seu vídeo.

@c cincvdoc_node_number_167
@node Chroma key
@subsection Chroma key
@cindex Efeito Chroma key

@image{manual_images_intl/chromakey,12.5mm}

Este efeito apaga pixels que combinem com a cor selecionada. Eles são substituídos por preto se não há canal alfa ou transparência se há um canal alfa. A seleção do modelo de cor é importante para determinar o comportamento.

@cindex Selecionador de cor
O Chroma key usa ou a luminância ou a gradação da cor para determinar o que será apagado. @b{Usar valor} considera apenas a luminância para determinar a transparência. Selecione uma cor central para apagar usando o botão @b{Cor}. Alternativamente, uma cor pode ser selecionada diretamente do quadro de saída usando a ferramenta @b{selecionador de cor} na janela de composição primeiro e, então, selecionando o botão @b{Usar selecionador de cor}. Isso marca a cor do chroma key para a cor atual colhida pelo selecionador de cor.

Saiba que a saída do chroma key é alimentada de volta para o compositor, então selecionar uma cor novamente do compositor usará a saída do efeito chroma key. O chroma key deve estar desabilitado quando se quer selecionar cores com o Selecionador de cor.

Se a luminância ou a gradação de cor estiver dentro de um certo valor de entrada, ela será apagada. Aumentar a entrada determina a abrangência de cores a ser apagada. Entretanto, isso não é um simples interruptor ligado/desligado. Conforme a cor se aproxima da borda do valor de entrada, ela gradualmente vai se apagando se o valor de gradiência estiver alto ou é rapidamente apagada se a gradiência estiver baixa. A gradiência é definida aqui como o número de valores extras flanqueando a entrada requerida para ir de opaco a transparente.

Normalmente a entrada é bastante baixa quando se está usando uma gradiência alta. Os dois parâmetros tendem a ser exclusivos porque a gradiência preenche a entrada extra.

A gradiência tenta amenizar as bordar do chroma key, mas não funciona bem para fontes comprimidas. Uma técnica popular de amenização é usar a gradiência no máximo e um efeito em cadeia de desfoque abaixo do efeito chroma key para borrar apenas o alfa.

@c cincvdoc_node_number_168
@node Chroma key (HSV)
@subsection Chroma key (HSV)
@cindex Chroma key effect (HSV)

@image{manual_images_intl/chromakeyhsv,12.5mm}

conserte-me.

@c cincvdoc_node_number_169
@node Balanço de Cores
@subsection Balanço de Cores
@cindex Balanço de Cores

@image{manual_images_intl/colorbalance,12.5mm}

O Balanço de Cores do Vídeo é uma boa ferramenta para se usar com Brilho/Contraste e Saturação de tons para tentar compensar possíveis erros de filmagem (luz baixa, etc. Ele não consegue fazer muita coisa sem abaixar muito a qualidade do vídeo, entretanto. Ele é como o efeito de balanceamento de cores em programas de manipulação de imagens, como o GIMP@. Com ele, você pode mudar as cores que estão sendo enviadas para a saída CMY (Ciano, Magenta, Amarelo) ou RGB (Vermelho, Verde, Azul).

@c cincvdoc_node_number_170
@node Decimar
@subsection Decimar
@cindex Efeito Decimar

@image{manual_images_intl/decimate,13.25mm}

Este efeito descarta os quadros de uma trilha que são mais similares para reduzir a taxa de quadros. Isso normalmente é aplicado a um DVD para converter vídeos a 29.97 quadros por segundo para a taxa de quadros de filme, a 23.97, mas este efeito de decimar consegue pegar qualquer taxa como entrada e convertê-la para qualquer taxa de saída menor.

A taxa de saída do @b{Decimar} é a taxa de quadros por segundo do projeto. A taxa de entrada é configurada na interface de usuário do @b{Decimar}. Para converter vídeo progressivo a 29.97 quadros por segundo para filme a 23.97 quadros por segundo, aplique um efeito de decimar na trilha. Configure a taxa de entrada do decimar para 29.97 e a taxa do projeto para 23.97.

Saiba que qualquer efeito colocado antes dos processos de decimar processam o vídeo à taxa de entrada do decimar e cada efeito colocado após o decimar processa o vídeo à taxa de quadros do projeto. Efeitos computacionais intensivos devem vir abaixo do decimar.

@c cincvdoc_node_number_171
@node Desentrelaçar
@subsection Desentrelaçar
@cindex Efeito Desentrelaçar

@image{manual_images_intl/deinterlace,12.5mm}

O efeito Desentrelaçar evoluiu com os anos para desentrelaçamento e muito mais. De fato, dois dos métodos de desentrelaçamento, @b{Telecine Inverso} e @b{Quadros para campos}, são efeitos separados. O efeito Desentrelaçar oferece várias variações de replicação de linha para aliminar artefatos "pente" no vídeo entrelaçado. Ele também possui algumas ferramentas de troca de linhas para consertar vídeo capturado incorretamente ou fazer com que o resultado de um efeito de Reversão exiba os campos na ordem correta.

@c cincvdoc_node_number_172
@node Atrasar Vídeo
@subsection Atrasar Vídeo
@cindex Atrasar Vídeo

@image{manual_images_intl/delayvideo,12.5mm}

conserte-me.

@c cincvdoc_node_number_173
@node Depurar vídeo
@subsection Depurar vídeo
@cindex Depurar vídeo

@image{manual_images_intl/denoisevideo,12.5mm}

conserte-me.

@c cincvdoc_node_number_174
@node Depurar vídeo2
@subsection Depurar vídeo2
@cindex Depurar vídeo2

@image{manual_images_intl/denoisemjpeg,12.5mm}

conserte-me.

@c cincvdoc_node_number_175
@node Chave de diferença
@subsection Chave de diferença
@cindex Efeito Chave de diferença

@image{manual_images_intl/diffkey,12.5mm}

A Chave de diferença cria transparência em áreas que sejam similares entre dois quadros. O efeito Chave de diferença deve ser aplicado a duas trilhas. Uma trilha contém a ação em frente a um fundo constante e a outra trilha o fundo sem nada à sua frente. Aplique o efeito Chave de diferença à trilha com a ação e aplique uma cópia compartilhada dele à trilha com o fundo. A trilha com o fundo deve ser mutada e abaixo da trilha com a ação e o modelo de cor deve possuir um canal alfa.

Pixels que forem diferentes entre o fundo e trilha de ação serão tratados como opacos. Pixels que forem similares são tratados como transparentes. Mude a @b{entrada} na janela da Chave de diferença para fazer mais pixels que não são da mesma cor transparentes. Mude a @b{Gradiência} para mudar a razão diante da qual a transparência se esvanece conforme os pixels tornam-se mais diferentes.

A gradiência conforme definida aqui é o número de valores extras flanqueando a entrada requerida para ir de opaco a transparente. Uma gradiência alta é mais útil com uma entrada baixa porque a gradiência preenche a entrada extra.

@b{Usar valor} faz a intensidade de pixels ser comparada ao invés da cor.

Aplicar um desfoque à trilha de cima com apenas o canal alfa sendo desfocado pode suavizar a borda da transparência.

@b{Nota:} Atualmente, este efeito tem dado pau quando usado em modos de cor YUV.

@c cincvdoc_node_number_176
@node TV Pontilhada
@subsection TV Pontilhada
@cindex TV Pontilhada

@image{manual_images_intl/dot,16.5mm}

Outro efeito de Kentaro (effectTV).

@c cincvdoc_node_number_177
@node Reduzir amostragem
@subsection Reduzir amostragem
@cindex Reduzir amostragem

@image{manual_images_intl/downsample,12.5mm}

Reduzir a amostragem é o processo de reduzir o tamanho de uma imagem jogando informação fora, reduzindo a taxa de amostragem.

Parâmetros se refere a: @*
Horizontal @*
Deslocamento Horizontal @*
Vertical @*
Deslocamento Vertical @*
Canais

@c cincvdoc_node_number_178
@node Campos para quadros
@subsection Campos para quadros
@cindex Efeito Campos para quadros

@image{manual_images_intl/fieldframe,12.5mm}

Este efeito lê os quadros a duas vezes a taxa de quadros do projeto, combinando dois quadros de entrada em um quadro único entrelaçado de saída. Efeitos precedendo @b{campos para quadros} processam quadros a duas vezes a taxa de quadros do projeto. Cada quadro de entrada é chamado um campo.

@b{Campos para quadros} precisa saber qual campo corresponde a quais linhas no quadro de saída. O jeito mais fácil de descobrir isso é tentar as duas opções da janela. Se os campos de entrada são resultantes de um processo de duplicação de linhas como @b{quadros para campos}, a configuração errada resultará em uma saída mais desfocada. Se os campos de entrada são o resultado de um processo de conversão padrão como @b{1080 para 480}, a configuração errada não vai fazer qualquer diferença.

O "debobber" que converte 720x480 entrelaçado em 1920x1080 entrelaçado ou 1280x720 progressivo parece degradar a resolução vertical a ponto de ela não poder ser recuperada.

@c cincvdoc_node_number_179
@node Inverter
@subsection Inverter
@cindex Inverter

@image{manual_images_intl/flip,12.5mm}

Este efeito permite inverter uma trilha de vídeo (ou uma porção dela) da esquerda para a direita, direita para a esquerda, cima para baixo, baixo para cima.

A janela de diálogo é simples, uma vez que apenas os parâmetros verticais e horizontais são requeridos.

@c cincvdoc_node_number_180
@node Quadros para campos
@subsection Quadros para campos
@cindex Quadros para campos

@image{manual_images_intl/framefield,13.25mm}

Este plugin aplica a operação reversa ao plugin "Campos para Quadros": ele extrai os dois campos entrelaçados armazenados em linhas alternantes do material entrelaçado fonte e gera uma saída como se eles fossem quadros inteiros separados. As linhas alternantes que faltarem em cada quadro de saída são interpoladas. (A nomenclatura deste par de plugins é obviamente enganadora no que se refere ao uso comum dos termos "campo" e "quadro"; normalmente, "campos" denotam as metades das imagens, entrelaçadas, e "quadro" denota a imagem completa).

Este plugin é útil apenas caso sua saída seja puxada com o dobro da taxa de quadros no que diz respeito ao material de origem. Um cenário típico de uso é quando se faz máscara, escalamento e translação em material entrelaçado sem a necessidade de se destruir a informação temporal adicional contida em tal material de origem. Isso é útil se o seu formato alvo pretendido for entrelaçado. Se, de outro modo, você quiser apenas dar saída a exibissões progressivas (por exemplo, caso você crie vídeos para serem exibidos em monitores de computador somente) então será muito mais conveniente desentrelaçar o material de origem antes de fazer qualquer outro processamento. 

@b{Processando material entrelaçado sem desentrelaçamento}

@enumerate 1
@item Crie um novo projeto com a taxa de quadros duplicada. Por exemplo, crie um com 50 quadros por segundo caso sua fonte de origem seja de 25i
@item Insira o seu material fonte em uma trilha de vídeo na linha do tempo. Agora, o Cinelerra reproduzirá cada quadro de seu material duas vezes.
@item Aplique o efeito "Quadros para Campos". Assegure-se de escolher a ordem correta dos campos. Valores típicos são "Campo de baixo primeiro" para DV e "Campo do topo primeiro" para HDV.
@item Aplique então quaisquer outros efeitos, incluindo translações, escalamento, câmera lenta, máscara com precisão de quadros ou use o plugin de rastreamento de moção.
@item Renderize o seu projeto para um recorte intermediário. Assegure-se de escolher um codec de vídeo sem perdas de compressão ("lossless"), como o Motion-JPEG-A o mesmo YUV não-comprimido se você tem espaço de armazenamento suficiente.
@item Insira o recorte intermediário em seu projeto original. Assegure-se que a taxa de quadros duplicada tenha sido detectada corretamente pelo Cinelerra (olhando as informações do recorte na pasta de recursos de mídia)
@item Aplique o efeito "Campos para quadros" no recorte intermediário. Isso combinará os dois campos adjacentes em um campo entrelaçado com a taxa de quadros original.
@item Faça a renderização final no seu projeto original
@end enumerate

@c cincvdoc_node_number_181
@node Congelar Quadro
@subsection Congelar Quadro
@cindex Efeito Congelar Quadro

@image{manual_images_intl/freezeframe,12.5mm}

Em sua forma mais simples, destaque uma região da trilha para congelar, solte o efeito de congelar quadro na região destacada e o quadro com a numeração mais baixa ("lowest numbered frame") na área afetada será reproduzido por toda a região afetada.

Congelar Quadro possui uma opção @b{habilitado} que pode ser objeto de quadros-chave. Regiões de um efeito Congelar Quadro que estão habilitadas repetem o quadro de numeração mais baixa desde o último quadro-chave. Isso gera possibilidades únicas.

@itemize @bullet
@item Se um efeito de congelar quadro possui um quadro-chave no meio dele marcado para @b{habilitado}, o quadro no meio será repetido durante todo o efeito.
@item Se um efeito de congelar quadro possui vários quadros-chave, cada um marcado para @b{habilitado}, cada vez que um quadro-chave é encontrado, o quadro abaixo dele se torna o congelado.
@item Se um efeito de congelar quadro se alterna entre @b{habilitado} e @b{desabilitado}, cada vez que um quadro-chave @b{habilitado} é encontrado, o quadro abaixo dele é replicado até o próximo quadro-chave @b{desabilitado}. As regiões desabilitadas são reproduzidas normalmente.
@end itemize

@c cincvdoc_node_number_182
@node Gama
@subsection Gama
@cindex Efeito Gama
@cindex Imagens brutas de câmera

@image{manual_images_intl/gamma,12.5mm}

Imagens brutas de câmera armazenam cores em uma escala logarítmica. Os pretos nessas imagens são próximos a 0 os brancos supostamente seriam a infinidade. As placas de vídeo e a maioria dos codecs de vídeo armazenam cores em uma escala linear, mas o Cinelerra mantém as imagens brutas de câmera em sua escala logarítmica original quando as renderiza. Isso é necessário porque o particionador ("parser") da imagem bruta não consegue sempre decodificar os valores corretos de gama para as imagens. Ele também faz seu processamento em números inteiros 16 bit ("16 bit integers"), o que remove um monte de informações.

O efeito gama converte as cores logarítmicas em cores lineares por meio de um valor gama e um valor máximo. O valor gama determina quão inclinada a curva de saída será e o valor máximo é onde 1.0 na saída corresponderá ao brilho máximo da entrada.

O efeito gama possui mais dois parâmetros para simplificar a correção de gama. A opção @b{automático} faz com que ele calcule @b{máx} a partir do histograma da imagem. Use-a quando for fazer uma pré-visualização de uma longa lista de imagens, já que isso muda para cada imagem.

A opção @b{Usar selecionador de cor} usa o valor atualmente no selecionador de cores para estabelecer o valor @b{máx}. Note que toda vez que você seleciona uma cor da janela de composição, você precisa apertar @b{Usar selecionador de cor} para aplicar o novo valor.

@c cincvdoc_node_number_183
@node Gradiente
@subsection Gradiente
@cindex Gradiente

@image{manual_images_intl/gradient,12.5mm}

O efeito Gradiente sobrepõe uma cor suave de gradiente ao topo de cada quadro de vídeo. Ele é útil para todos os tipos de preenchimento de fundo, para filtragem parcial ou para adicionar destaques em movimento. O efeito Gradiente pode gerar preenchimentos de cor linear ou circular. Para preenchimentos lineares, você pode escolher o ângulo; para preenchimentos circulares, o centro do padrão de gradiente criado. Além disso, você pode controlar a gradiência da cor de transição selecionando uma função de transição (linear, logarítmica, quadrada) e mudando o raio de "início" e "fim". Note que ambas as cores usadas nesta transição de cores podem conter um valor arbitrário de Alfa (transparência). Todos os parâmetros podem ser marcados com quadros-chave e serão interpolados entre os quadros-chave.

Observe os problemas já bem conhecidos:
@itemize @bullet
@item Quando se usa modelos de cor limitados em seu projeto, o preenchimento Gradiente pode criar bandas ou passos de cor.
@item Quando se usa um formato de projeto com armazenamento anamórfico, o Cinelerra não fará nenhuma correção interna para isso. Isso pode resultar em um preenchimento circular aparecendo de forma elíptica. Um exemplo comum é o formato HDV 1080i, que é armazenado como 1440x1080 pixels, mas exibido como 1920x1080 (razão de aspecto 16:9). Como o Cinelerra faz os cálculos em um mapa de bits de 1440x1080 pixels, qualquer preenchimento circular será esticado horizontalmente quando a saída final for exibida.
@end itemize

@c cincvdoc_node_number_184
@node Histograma
@subsection Histograma
@cindex Efeito Histograma

@image{manual_images_intl/histogram,12.5mm}

Mostra o número de ocorrências para cada cor na trama de um histograma.

Ele sempre é executado em ponto flutuante ("floating point") RGB, independentemente do espaçamento de cor do projeto. O histograma possui duas configurações de parâmetros de transferência: a transferência de entrada e a transferência de saída.

Quatro histogramas são possíveis no visor de histograma. Os histogramas vermelho, verde, azul mostram a entrada de histograma para vermelho, verde, azul e as multiplica por uma transferência de entrada para obter a saída de vermelho, verde, azul. Então, a saída de vermelho, verde, azul são escaladas por uma transferência de saída. O vermelho, verde, azul escalados são convertidos em um valor e é feita a trama no valor do histograma. O valor do histograma então muda dependendo das configurações de vermelho, verde, azul. As transferências de valor são aplicadas uniformemente para o R, G, B após suas transferências de cores serem aplicadas.

Selecione qual transferência para vê-la selecionando um dos canais ao topo do histograma.

A transferência de entrada é definida por um gráfico sobreposto ao histograma. A direção horizontal corresponde a cada cor possível de entrada. A direção vertical corresponde à cor de saída para cada cor de entrada. O vídeo que entra no histograma é primeiro tramado na trama do histograma e então é transladado de modo que os valores de saída agora igualem os valores de saída para cada valor de entrada no gráfico de entrada.

O gráfico de entrada é editado adicionando-se ou removendo-se qualquer número de pontos. Clique e arraste em qualquer lugar do gráfico de entrada para criar um ponto e movê-lo. Clique em um ponto existente para fazê-lo ficar ativo e movê-lo. O ponto ativo é sempre indicado sendo preenchido. A entrada do ponto ativo e a cor de saída são dados no topo da janela. As cores de entrada e saída do ponto podem ser mudadas por meio dessas caixas de texto.

Pontos podem ser apagados ao primeiro se selecionar um ponto e depois arrastá-lo ao outro lado de um ponto adjacente. Eles também podem ser apagados ao selecioná-los e pressionando a tecla @b{delete}.

Após a transferência de entrada, a imagem é processada pela transferência de saída. A transferência de saída é simplesmente o mínimo e o máximo para se escalar as cores de entrada. Valores de entrada de 100% são escalados para baixo para o máximo da saída. Valores de entrada de 0% são escalados para cima para o mínimo da saída.

Valores de entrada abaixo de 0 são sempre achatados para 0 e valores de entrada acima de 100% são sempre achatados para 100%. Clique e arraste nos triângulos de gradiência de saída para mudá-los. Ele também possui caixas de texto onde se podem entrar valores.

Habilite o botão @b{automático} para que o histograma faça um cálculo automático da transferência de entrada para vermelho, verde, azul mas não o valor. Ele faz isso escalando o meio 99% dos pixels para pegar 100% da largura do histograma. O número de pixels permitidos para poderem passar é configurado pela caixa de texto @b{Entrada}. Uma entrada de 0.99 escala a entrada de modo que 99% dos pixels possam passar. Entradas menores permitem que menos pixels passem e fazem a saída parecer mais contrastada.

A transferência automática de entrada é calculada pelos canais R, G e B, mas não o valor. @*
@b{Trama do Histograma} @*
@b{Dividir saída}

@c cincvdoc_node_number_185
@node TV Holográfica
@subsection TV Holográfica
@cindex TV Holográfica

@image{manual_images_intl/holo,16.25mm}

Por Kentarou effectTV

@c cincvdoc_node_number_186
@node Saturação de tons
@subsection Saturação de tons
@cindex Saturação de tons
@cindex Saturação

@image{manual_images_intl/huesaturation,12.5mm}

Com este efeito, você pode mudar a gradação, saturação e valor. Os parâmetros são modificados usando três deslizadores simples.

@itemize @bullet
@item O controle de tons muda as cores circularmente no plano de cores, normalmente resultando em cores "falsas".
@item O controle de saturação pode ser usado para reduzir o material colorido para preto e branco.
@item O controle de valor faz das cores dadas mais brilhantes ou mais foscas.
@end itemize

@c cincvdoc_node_number_187
@node Interpolar vídeo
@subsection Interpolar vídeo
@cindex Interpolar vídeo

@image{manual_images_intl/interpolatevideo,13.25mm}

O efeito Interpolar tenta criar uma ilusão de taxa de quadros mais alta a partir do material de origem de taxas de quadros muito baixas alterando os quadros com o tempo. Ele faz uma média de dois quadros de entrada para cada quadro de saída. Os quadros de entrada estão a tempos diferentes, resultando em uma dissolução para todos os quadros de saída entre os quadros de entrada. Há duas formas de especificar os quadros de entrada. Você pode especificar a taxa de quadros de entrada que é mais baixa do que a taxa de quadros do projeto. Isso faz com que os quadros de entrada sejam pegos a intervalor pares. @*
Você também pode especificar lugares de quadros-chave como posições dos quadros de entrada. Deste modo, a taxa de quadros de saída é usada como a taxa de quadros de entrada e você simplesmente cria quadros-chave onde você quiser especificar um quadro de entrada.

@c cincvdoc_node_number_188
@node Interpolar pixels
@subsection Interpolar pixels
@cindex Interpolar pixels

@image{manual_images_intl/interpolate,12.5mm}

Observação: este efeito funciona somente para modelos de cor flutuante.

conserte-me.

@c cincvdoc_node_number_189
@node Telecine Inverso
@subsection Telecine Inverso
@cindex Efeito Telecine Inverso

@image{manual_images_intl/ivtc,12.5mm}

Esta é a ferramenta mais efetiva de desentrelaçamento quando o material é um transfer de vídeo de um filme. Aqui o filme foi convertido de 24 quadros por segundo para 60 quadros por segundo. Então, os 60 quadros por segundo foram re-amostrados para 30 quadros por segundo extraindo-se as linhas ímpares e pares e entrelaçando as linhas. O efeito IVTC é primariamente uma forma de converter vídeo entrelaçado para vídeo progressivo. Ele desfaz três padrões de entrelaçamento. @*
@code{A AB BC CD D} @*
@code{AB CD CD DE EF} @*
@code{Automático}

As duas primeiras opções são padrões fixos e afetadas pelos parâmetros @b{Padrão do deslocamento} e @b{Campo ímpar primeiro}. A última opção cria várias combinações de linhas para cada quadro e pega a combinação mais progressiva. É um algoritmo de força bruta.

Esta técnica não depende de um padrão como outras técnicas e é menos destrutiva, mas o tempo vai ficar um pouco balançado ("jitter") devido à falta de uma redução de taxa de quadros. Para suavizar o tempo, você deve aplicar um efeito de Decimar após o telecine.

@c cincvdoc_node_number_190
@node Inverter Vídeo
@subsection Inverter Vídeo
@cindex Inverter Vídeo

@image{manual_images_intl/invertvideo,12.5mm}

Também chamado de Inverter Vídeo, este é um método de reverter as cores de uma trilha de vídeo.

Os quatro parâmetros se referem aos canais (Vermelho, Azul, Verde, Alfa)

@c cincvdoc_node_number_191
@node Desfoque Linear
@subsection Desfoque Linear
@cindex Desfoque Linear

@image{manual_images_intl/linearblur,12.5mm}

Desfoque possui três estilos: Linear, Radial e de Aproximação.

Os parâmetros se referem a:
@itemize @bullet
@item @b{Comprimento} @*
Distância entre a imagem original e o passo final de desfoque
@item @b{Ângulo} @*
Ângulo de moção, para desfoque linear
@item @b{Passos} @*
Número de passos de desfoque
@item @b{Canais} @*
Quais canais desfocar.
@end itemize

@c cincvdoc_node_number_192
@node Vídeo Ao Vivo
@subsection Vídeo Ao Vivo
@cindex Efeito Vídeo Ao Vivo

@image{manual_images_intl/livevideo,12.5mm}

Este efeito lê o vídeo diretamente da entrada da placa de captura. Ele substitui qualquer vídeo na trilha, então é normalmente aplicado a uma trilha vazia. A configuração para a placa de captura é pega das preferências de gravação. Vá para @b{Configurações->Preferências->Gravação} para configurar a placa de captura.

Vá para a seção @b{Entrada de Vídeo}, onde diz @b{Driver de Gravação}. Ele deve estar configurado para @b{Video4Linux2} ou @b{IEC 61883}. Outros drivers de vídeo não foram testados com o efeito Vídeo Ao Vivo e provavelmente não funcionarão.

Para vídeo ao vivo, a seleção de @b{Formato de Arquivo} e @b{Vídeo} precisa estar configurada para um formato que a linha do tempo possa usar. O formato de arquivo deve ser @b{Quicktime para Linux} e a gravação de vídeo deve estar habilitada para ele. Clique no ícone de ferramenta @image{manual_images_intl/wrench,4.33mm} para configurar a compressão do vídeo.

A compressão do vídeo depende do driver de gravação. Para o driver de gravação @b{Video4Linux2}, a compressão deve ser @b{Motion JPEG A}. Para o driver @b{IEC 61883}, a compressão deve ser @b{DV}. Isso faz com que o driver gere uma saída em um modelo de cor que a linha do tempo consiga usar.

Algumas placas provêm configurações de cor e canal. Vídeo Ao Vivo pega as configurações de cor dos valores configurados na janela @b{Entrada de Vídeo}. Vá para @b{Arquivo->Gravação} para revelar a interface de gravação e a janela Entrada de Vídeo. Valores configurados na janela @b{Entrada de Vídeo} são usados pelo @b{Vídeo ao Vivo}. Quaisquer canais que a placa de captura suporte precisam ser configurados na interface @b{Entrada de Vídeo}, já que alguns canais são usados pelo efeito @b{Vídeo ao Vivo}.

Com a gravação de vídeo configurada, destaque uma região horizontal de uma trilha de vídeo ou defina pontos de entrada e saída. Então, jogue o efeito Vídeo Ao Vivo nela. Jogue outros efeitos após Vídeo Ao Vivo para processar o vídeo ao vivo em tempo real. Para resultados melhores, você deve usar OpenGL e uma placa de vídeo que suporte a linguagem de sombreamento ("shading") GL. Vá para @b{Configurações->Preferências->Reprodução->Saída de Vídeo} para habilitar o driver OpenGL.

Apenas um efeito Vídeo Ao Vivo pode existir em qualquer momento na linha do tempo. Ele não pode ser compartilhado por mais de uma trilha.

@c cincvdoc_node_number_193
@node Vídeo em loop
@subsection Vídeo em loop
@cindex Efeito de Vídeo em loop

@image{manual_images_intl/loopvideo,12.5mm}

Seções do vídeo podem ser deixadas em loop arrastando um efeito @b{loop} nela. Contrário à opção @b{configurações->reprodução em loop}, os efeitos de loop podem ser renderizados onde a opção @b{configurações->reprodução em loop} não podem. Os efeitos de loop também são convenientes para regiões curtas.

Os efeitos de loop possuem uma opção: o número de @b{quadros} ou @b{amostras} a entrarem em loop. Isso especifica a duração da região a entrar em loop começando ou a partir do começo do efeito ou do último quadro-chave. A região é replicada por todo o efeito.

Cada vez que um quadro-chave é configurado em um efeito de loop, o quadro-chave se torna o começo da região a entrar em loop. Marcar vários quadros-chave em sucessão faz várias regiões entrarem em loop. Marcar um quadro-chave único faz a região após o quadro-chave entrar em loop através do efeito, não importando onde o quadro-chave está. O fim de um efeito pode entrar em loop a partir do início marcando o quadro-chave perto do final.

@c cincvdoc_node_number_194
@node Moção
@subsection Moção
@cindex Efeito de vídeo Moção

@image{manual_images_intl/motion,12.5mm}

O rastreador de movimento é uma aplicação quase completa por si só. O rastreador de movimento rastreia dois tipos de movimentação: translação e rotação. Ele pode rastrear as duas simultaneamente ou apenas uma. Ele pode fazer restreamento de 1/4 de pixel ou de pixel único. Ele pode estabilizar a moção ou fazer com que uma trilha siga a movimentação de outra.

Embora o rastreador de movimento seja aplicado como um efeito tempo-real, ele normalmente precisa ser renderizado para que se veja resultados úteis. O efeito leva um longo tempo para detectar a movimentação precisamente.

O rastreador de movimento funciona usando uma região do quadro como região a ser rastreada. Ele compara esta região entre dois quadros para calcular o movimento. Esta região pode ser definida em qualquer lugar da tela. Uma vez que o movimento entre dois quadros tenha sido calculado, um número de coisas pode ser feito com aquele vetor de movimento. Ele pode ser escalado por um valor estabelecido pelo usuário e forçado para uma abrangência máxima. Ele pode ser jogado fora ou acumulado com todos os vetores de movimento que são levados até a posição atual.

Para economizar tempo, o resultado da movimentação pode ser salvo para reuso posterior, re-chamado a partir de um cálculo prévio ou descartado.

O rastreador de movimento possui uma noção de dois rastreadores, a camada-mestre ("master layer") e a camada-alvo ("target layer"). A camada mestre é onde a comparação entre dois quadros se dá. A camada alvo é onde a moção é ou aplicada à trilha ou compensada para a moção na camada mestre.

A elaboração do rastreamento de movimentação é suficiente para sustentar companhias inteiras e construir carreiras por aí. O rastreador de movimento no Cinelerra não é tão sofisticado como alguns rastreadores de movimento de primeira classe, mas é o suficiente para suavizar algumas tomadas de câmera.

Aqui está uma breve descrição dos parâmetros do rastreador de movimento:

@itemize @bullet

@item @b{Translação da Trilha} @*
Habilita operações de translação. O rastreador de movimento rastreia a moção em X e Y na camada mestre e ajusta a moção X e Y na camada alvo.

@cindex Efeito Moção, bloco de translação
@cindex Bloco de translação
@item @b{Tamanho do bloco de translação} @*
Para as operações de translação, um bloco é comparado a um número de blocos vizinhos para encontrar aquele com a menor diferença. O tamanho do bloco a ser buscado é informado por este parâmetro.

@item @b{Raio de busca da translação} @*
O tamanho da área a ser varrida para o bloco de translação.

@item @b{Passos de busca de translação} @*
Idealmente, a operação de busca compararia o bloco de translação com cada outro pixel no raio de busca de translação. Para aumentar a velocidade desta operação, um subconjunto das posições totais é buscado. Então, a área de busca é delimitada e varrida novamente pelo mesmo número de passos de busca até que a moção seja conhecida por uma precisão de 1/4 de pixel.

@item @b{Bloco X, Y} @*
Essas coordenadas determinam o centro do bloco de translação baseado nas porcentagens de largura e altura da imagem. O centro deste bloco deve ser parte da imagem que está visível a todo tempo.

@item @b{Deslocamento absoluto máximo} @*
A quantidade de movimentação detectada pelo rastreador de movimento é ilimitada se este valor estiver em 100. Caso esteja a menos de 100, a quantidade de moção será limitada por aquela porcentagem do tamanho da imagem.

@item @b{Velocidade gradual} @*
A movimentação detectada entre cada quadro pode ser acumulada para formar um vetor de movimentação absoluto. Se a velocidade gradual for 100, o vetor absoluto é adicionado ao próximo quadro. Se a velocidade gradual for menor que 100, o vetor absoluto é escalado para baixo pela quantidade gradual antes de ser adicionado ao próximo quadro.

@item @b{Rotação da Trilha} @*
Habilita operações de rotação. O rastreador de movimento rastreia a rotação na camada mestre e ajusta a rotação na camada alvo.

@item @b{Tamanho do bloco de rotação} @*
Para operações de rotação, um bloco único é comparado a blocos de mesmo tamanho, cada um rotacionado por um valor diferente. Este é o tamanho do bloco de rotação.

@item @b{Raio de busca de rotação} @*
Este é o ângulo máximo de rotação a partir do quadro de início que o rastreador de rotação consegue detectar. O rastreamento de rotação é a partir deste ângulo seguindo o sentido horário ou a partir deste ângulo seguindo o sentido anti-horário. Assim, o raio de busca de rotação é metade da abrangência total varrida.

@item @b{Passos da busca de rotação} @*
Idealmente, cada ângulo possível seria testado para se conseguir a rotação. Para aumentar a velocidade da busca de rotação, o raio de busca de rotação é dividido em um número finito de ângulos e apenas estes ângulos são comparados ao quadro inicial. Então, o raio de busca é delimitado e um número igual de ângulos é comparado no raio menor até que a precisão máxima seja alcançada. @* Normalmente você precisa de um passo de busca para cada grau varrido. Uma vez que o rastreador de rotação varre o raio de busca de rotação em duas direções, você precisará de dois passos para cada grau no raio de busca para varrer a abrangência completa.

@item @b{Desenhar vetores} @*
Quando a translação está habilitada, duas caixas são desenhadas no quadro. Uma caixa representa o bloco de translação. A outra, fora do bloco de translação, representa a extenção do raio de busca de translação. No centro dessas caixas está uma flecha mostrando a translação entre os dois quadros mestre. @* Quando a rotação for habilitada em uma caixa única, o tamanho do bloco de rotação é desenhado rotacionado pela quantidade de rotação detectada.

@item @b{Rastrear quadro único} @*
Quando esta opção é usada, a moção entre um quadro único de início e o quadro atual abaixo do ponto de inserção é calculada. O quadro inicial é especificado na caixa @b{Número do Quadro}. A movimentação calculada desta forma é usada como o vetor de movimentação absoluto. O vetor de movimentação absoluto para cada quadro substitui o vetor de movimentação absoluto para o quadro anterior. A velocidade gradual não possui um efeito nisso, uma vez que ela não contém qualquer vetor de moção prévio.A reprodução pode começar em qualquer lugar da linha do tempo, já que não há uma dependência dos resultados anteriores.

@item @b{Rastrear quadro anterior} @*
Faz com que apenas a movimentação entre o quadro prévio e o quadro atual seja calculada. Isso é adicionado a um vetor de movimentação absoluto para se obter a nova moção a partir do início da sequência para a posição atual. Após cada quadro ser processado desta forma, a posição do bloco é mudada para sempre cobrir a mesma região da imagem. A reprodução deve ser iniciada a partir do início do efeito de moção para que se acumule todos os vetores necessários de movimentação.

@item @b{Quadro anterior mesmo bloco} @*
Este é útil para estabilizar tomadas de câmera trepidantes. Neste modo, a movimentação entre o quadro anterior e o atual é calculada. Ao invés de ajustar a posição do bloco para refletir a nova localização da imagem, como o Rastrear quadro anterior faz, a posição do bloco não é modificada entre cada quadro. Assim, uma nova região é comparada a cada quadro.

@item @b{Camada Mestre} @*
Determina a trilha que oferece o quadro inicial e o quadro final para o cálculo de moção. Se for @b{Bottom}, a trilha à base de todas as trilhas compartilhando este efeito será a camada mestre. A trilha ao topo de todas as trilhas será a camada alvo.

@item @b{Cálculo} @*
Determina se a moção será calculada e se ela deve ser salva no disco rígido. Se esta opção estiver em @b{Não Calcular}, o cálculo de moção é pulado. Se ela estiver em @b{Recalcular}, o cálculo de moção é recalculado a cada vez que cada quadro for renderizado. Se ela estiver em @b{Salvar}, o cálculo de moção sempre será realizado mas uma cópia também será salva. Se estiver em @b{Carregar}, o cálculo de moção será carregado de um cálculo salvo anteriormente. Se não há cálculo anteriores salvos no disco, um novo cálculo de moção é realizado.

@item @b{Ação} @*
Uma vez que o vetor de moção seja conhecido, determina se a camada alvo será movida em oposição ao vetor de moção ou se seguindo o vetor de moção. Se estiver em @b{Não fazer nada}, a camada alvo permanece intocada. Se estiver em @b{Trilha...}, a camada alvo será movida pela mesma quantidade que a camada mestre. Isto é útil para ajustar títulos a objetos no quadro. Se estiver em @b{Estabilizar...}, a camada alvo é movida em oposição ao vetor de moção. Isso é útil para estabilizar um objeto no quadro. As operações de moção pode ser precisas para pixels únicos ou subpixels mudando-se a configuração de ação.  @end itemize

@menu
* Segredos do rastreamento de moção::
* Rastreamento de moção em 2 passagens::
* Usando desfoque para melhorar o rastreamento de moção::
* Usando o histograma para melhorar o rastreamento de moção::
* O rastreamento de moção em ação::
* Estabilização de rastreamento em ação::
@end menu

@c cincvdoc_node_number_195
@node Segredos do rastreamento de moção
@subsubsection Segredos do rastreamento de moção
@cindex Segredos do rastreamento de moção
@cindex Rastreamento de moção, segredos do

Uma vez que este é um efeito muito lendo, existe um método para aplicá-lo para conseguir o melhor dele. Primeiro, desabilite a reprodução de trilha na qual você está fazendo o rastreamento de moção. Então, jogue o efeito em uma região do vídeo com alguma movimentação para ser rastreada. Rebobine o ponto de inserção para o início da região. Marque @b{Ação} -> @b{Não fazer nada}. Marque @b{Cálculo} -> @b{Não calcular}. Habilite @b{Desenhar vetores}. Então habilite a reprodução da trilha para ver as áreas onde o rastreamento está sendo feito.

Habilite quais vetores de @b{moção de translação} ou @b{moção de rotação} você quer rastrear. Observando a janela de compositor e ajustando as configurações de @b{Bloco x,y}, centralize o bloco na parte da imagem que você quer rastrear. Então marque o raio de busca, tamanho de bloco e coordenadas de bloco para translação e rotação.

Uma vez que isso tenha sido configurado, marque o cálculo para @b{Salvar coordenadas} e faça buscas de teste pela seqüência para ver se o rastreador de moção funciona e para salvar os vetores de moção. Quando isso tiver sido feito, desabilite a reprodução da trilha, desabilite @b{Desenhar vetores}, marque a ação de moção para ser feita na camada alvo e mude o cálculo para @b{Carregar coordenadas}. Finalmente, habilite a reprodução da trilha.

Quando usar um único quadro de início para calcular a movimentação de uma seqüência, o quadro de início deve ser um quadro único com a menor moção com relação aos outros quadros. Raramente será o quadro 0. Normalmente é um quadro perto do meio da seqüência. Desta forma, o radio de busca precisa chegar a apenas metade de toda a extensão da moção na seqüência.

Se o rastreador de moção for usado em uma fazenda de renderização, os modos @b{Salvar coordenadas} e @b{quadro anterior} não funcionarão. Os resultados da operação de salvar coordenadas são salvos nos discos rígidos dos nódulos de renderização, não no nódulo mestre. Operações futuras de renderização nesses nódulos processarão quadros diferentes e lerão as coordenadas erradas dos sistemas de arquivos dos nódulos. O fato de que os nódulos de renderização visualizam apenas uma porção da linha do tempo também faz com que o @b{quadro anterior} funcione, já que ele depende de um cálculo do vetor de moção absoluto que se inicia no quadro 0.

@c cincvdoc_node_number_196
@node Rastreamento de moção em 2 passagens
@subsubsection Rastreamento de moção em 2 passagens
@cindex Rastreamento de moção em 2 passagens
@cindex Rastreamento de moção, 2 passagens

O método descrito acima é o rastreamento de moção em 2 passagens. Uma passagem é usada apenas para calcular os vetores de movimento. Uma segunda passagem é usada para aplicar os vetores de movimento ao material. Isso é mais rápido que uma passagem única porque assim os erros no cálculo do vetor de movimento podem ser descobertos rapidamente.

Isso também permite que o rastreamento de moção use um modelo de cor que demande menos como o RGB888 no passo de rastreamento ("scanning") e um modelo de cor que demande mais como o RGB Float no passo de ação. O passo de rastreamento leva muito mais tempo do que o segundo.

Isso sofre da desvantagem de não ser prático para seqüências extremamente longas onde algum erro seja aceitável e a qualidade da imagem seja ruim antes de mais nada, como estabilizar tomadas de câmera.

O método mais lento é calcular o vetor de moção e aplicá-los simultaneamente. Este método pode usar uma trilha como a trilha de cálculo do vetor de moção e outra trilha como a trilha alvo para as ações do vetor de moção. Isso é útil para seqüências longas onde algum erro pode ser aceitável.

@c cincvdoc_node_number_197
@node Usando desfoque para melhorar o rastreamento de moção
@subsubsection Usando desfoque para melhorar o rastreamento de moção
@cindex Desfoque, rastreamento de moção
@cindex Rastreamento de moção, usando desfoque para melhorar

Com material extremamente ruidoso ou entrelaçado, aplicar um efeito de desfoque antes do rastreamento de moção pode melhorar a precisão do efeito. Ou salve os vetores de moção em uma @b{passagem de trilha} e desabilite o desfoque para a @b{ação de passagem} ou aplique o desfoque apenas à @b{camada mestre}.

@c cincvdoc_node_number_198
@node Usando o histograma para melhorar o rastreamento de moção
@subsubsection Usando o histograma para melhorar o rastreamento de moção
@cindex Rastreamento de moção, usando o histograma

Um histograma é quase sempre aplicado antes do rastreamento de moção para reduzir o ruído em pixels mais escuros. Ou salve os vetores de moção em uma @b{passagem de trilha} e desabilite o histograma para a @b{ação de passagem} ou aplique o histograma apenas à @b{camada mestre}.

@c cincvdoc_node_number_199
@node O rastreamento de moção em ação
@subsubsection O rastreamento de moção em ação
@cindex O rastreamento de moção em ação

Primeiro, adicione um efeito de moção à trilha. Arraste-o da janela de recursos e jogue-o diretamente por sobre o vídeo na janela principal do Cinelerra. Você deve ver algo similar a isto:

@center @image{manual_images_intl/cin_timeline_eff_clip,90mm}

Clique com o botão direito do mouse no marcador do efeito de moção na linha do tempo e selecione "mostrar" para ver a caixa de diálogo do rastreador de moção:

@center @image{manual_images_intl/cin_motion_win,90mm}

Comece olhando no seu Compositor. Você verá algumas caixas novas sobrepostas ao vídeo. Elas são importantes para controlar o rastreador de moção. Aqui está uma captura rápida de como aparecerá quando ele estiver funcionando:

@center @image{manual_images_intl/cin_comp_action_small,90mm}

A imagem acima mostra o rastreador de moção perdendo a trilha do objeto porque uma janela de busca está muito pequena. Falaremos mais sobre isso mais tarde, mas rapidamente: @*
@itemize @minus
@item A caixa pequena do meio é o alvo do rastreador.
@item A caixa maior do meio é a abrangência de busca para o rastreador. Ela deve conter a abrangência completa do movimento para o alvo do rastreamento.
@item Neste exemplo, estamos tentando rastrear o objeto vermelho. Falhamos neste quadro de vídeo porque o objeto está bem à direita do centro do quadro.
@item O vetor que aponta para a esquerda indica o rastreador de moção tentando encontrar o alvo. Mais sobre isso depois.
@end itemize

Mova para o início do seu recorte de vídeo

Assegure-se que a caixa de diálogo do rastreador de moção esteja aberta

Olhe para o Compositor

Começe a ajustar estes quadro botões:

@center @image{manual_images_intl/cin_motion_track,90mm}

Assegure-se de habilitar a Translação da Trilha

Desabilite a Rotação da Trilha

Comece com o botão dois - Tamanho do bloco de translação - e gire-o para ter uma idéia do que está mudando. Note que ambas as caixas são redimensionadas. Olhe para a caixa pequena de dentro. Ajuste-a para o tamanho do alvo (o objeto que você quer rastrear). Não se preocupe se ela ainda não cobre o objeto.

Vá para os botões três e quatro - Bloco X e Bloco Y@. Use-os para colocar o designador de alvo por sobre o alvo.

Finalmente, use o botão de cima - Raio de busca da translação. Expanda-o para incluir toda a abrangência do movimento ("travel") que você espera do alvo. Se você olhar para trás em minha captura de tela original, o raio de busca era muito pequeno e o alvo se moveu para fora de sua abrangência. Você pode testar isso reproduzindo a linha do tempo e vendo os resultados (se a sua máquina for suficientemente rápida para tempo-real) ou renderizando e vendo o objeto estabilizado na saída.

Faça o primeiro quadro do vídeo ficar parecido a:

@center @image{manual_images_intl/cin_comp_first_setup_small,90mm}

Esta imagem mostra um monte de detalhes. Note que o quadro pequeno está centralizado por sobre o objeto e ajustado justamente para inclui-lo. Essas configurações são controladas pelos botões dois a quatro. Finalmente, o quadro de fora é mais largo do que o movimento de balanço do pêndulo em todo o recorte de vídeo.

Finalmente, aqui estão outras configurações necessárias para ver o efeito:

@center @image{manual_images_intl/cin_motion_set_output1,90mm}

@itemize @minus
@item @b{Desenhar vetores} Desabilite esta opção para evitar a renderização das caixas de alvo e dos vetores de moção em seu vídeo renderizado. Se habilitada, os vetores e as caixas são renderizadas no vídeo de saída.
@item @b{Rastrear Quadro Único} Para este exemplo, está configurado com um número de quadro de 0 (primeiro quadro)
@item @b{Camada Mestre} Se o efeito for compartilhado entre duas trilhas, ele especifica em qual daquelas trilhas o movimento será rastreado (camada mestre) e qual delas será afetada pelo vetores de translação resultantes (camada alvo). Se não há uma segunda trilha compartilhando o rastreador de moção, então a camada mestre é igual à camada alvo.
@item @b{Ação} Selecione as opções de estabilização para que o vídeo renderizado siga a movimentação do alvo. Selecione uma opção de Trilha para rodar o rastreamento de moção sem ajustar o vídeo.
@item @b{Cálculo}
@itemize @minus
@item @b{Não calcular} selecione esta opção para desligar o ajuste do vídeo.
@item @b{Recalcular} Faz o rastreamento de moção e atualiza o vídeo por configuração de Ação.
@item @b{Salvar e Carregar} Salva/Carrega os vetores de translação/rotação (absolutos ou relativos) para/de arquivos. Cada quadro pega um arquivo separado da pasta /tmp que contém seu vetor.
@end itemize
@end itemize

@c cincvdoc_node_number_200
@node Estabilização de rastreamento em ação
@subsubsection Estabilização de rastreamento em ação
@cindex Estabilização de rastreamento em ação

Nesta seção, vamos explicar como estabilizar um vídeo. Tal necessidade pode surgir quando o vídeo foi gravado a partir de um veículo, por exemplo.

Primeiro selecione na linha do tempo a parte do material que você quer estabilizar, usando pontos de entrada e saída. Aplique o efeito de moção a esta parte do vídeo.

Selecione a opção "Quadro anterior mesmo bloco". Esta opção é recomendada para estabilizar material de câmera gravado de um jeito trepidante. Seu objetivo não é "seguir" um objeto. O bloco fica exatamente no mesmo lugar durante toda a duração do efeito.

Alargue o bloco e selecione quase a metade do tamanho do vídeo. Selecione a opção "Estabilizar Subpixel": ela dará uma estabilização mais fina. Reduza o valor de "Deslocamento absoluto máximo" para limitar a amplitude da estabilização. Você provavelmente vai preferir obter uma estabilização não-perfeita em alguns lugares do vídeo, ao invés de ter uma borda negra gigante de um lado da imagem durante grandes chacoalhadas. Marque o valor de "Passos de busca de translação" para 128. Aumentar este valor não vai dar um resultado melhor, mas vai acrescer consideravelmente o tempo de renderização. Assegure-se de a opção "Desenhar vetores" estar selecionada e renderize parte do vídeo onde o efeito de moção foi aplicado.

Se o resultado estiver bom, deselecione a opção "Desenhar vetores". O bloco e os vetores não serão mais desenhados no vídeo. Então, renderize seu vídeo para um arquivo @file{.dv} e importe-o em seu projeto.

Você notará que o vídeo estará estabilizado mas que há bordas pretas aparecendo nos cantos dos quadros. Você terá que fazer uma aproximação e definir quadros-chave de projetor para mover o projetor pela tela para remover estas bordas pretas. Quanto mais trepidante seu material for, mais você terá que aproximar para descartar as bordas pretas. Este é o motivo pelo qual o resultado fica melhor com material HDV do que com material DV.

@c cincvdoc_node_number_201
@node Desfoque de movimento
@subsection Desfoque de movimento
@cindex Desfoque de movimento

@image{manual_images_intl/motionblur,12.5mm}

conserte-me.

@c cincvdoc_node_number_202
@node Pintura a óleo
@subsection Pintura a óleo
@cindex Pintura a óleo
@cindex Pintura, óleo

@image{manual_images_intl/oilpainting,12.5mm}

Este efeito faz com que as trilhas de vídeo apareçam como uma pintura. Ele pode ser controlado pelo deslizador de Raio. A intensidade das cores pode ser escolhida como opção.

@c cincvdoc_node_number_203
@node Sobrepor vídeo
@subsection Sobrepor vídeo
@cindex Sobrepor vídeo

@image{manual_images_intl/overlay,13.25mm}

Este efeito pode combinar várias trilhas usando o tão chamado Sobrepositor ("Overlayer"). Isso é um dispositivo básico interno normalmente usado pelo Cinelerra para criar as transições (de dissolver) e para compor a saída final de cada trilha no mapa de bits de saída. O Sobrepositor tem a habilidade de combinar uma ou várias camadas de imagem no topo de uma "camada de base". Ele pode fazer isso combinando imagens em vários modos de saída diferentes (e cambiáveis): Normal, Aditivo, Subtrativo, Multiplicado (Filtro), Dividido, Max e Substituir. Para uma explicação detalhada dos vários modos de sobreposição, veja @xref{Composição}. 

Agora, o plugin de sobreposição habilita o uso deste dispositivo Sobrepositor no meio de qualquer pilha de plugins, abrindo possibilidades infinitas de filtragem e processamento. Isso só é útil como um plugin compartilhado (por exeplo, um plugin de múltiplas trilhas). Assim, para usar o plugin de sobreposição:

@enumerate 1
@item Adicione o efeito na Trilha A.
@item Escolha "adicionar efeito" do menu de contexto de outra trilha (Trilha B).
@item Escolha "Trilha A:Sobreposição" como um plugin compartilhado.
@item Manipule os parâmetros do plugin na Trilha A.
@end enumerate

Na janela de parâmetros do plugin de Sobreposição, você pode escolher a ordem de sobreposição, por exemplo, qual trilha terá o papel de "camada de base" e qual terá o papel de "camada de cima". Para alguns modos de sobreposição, isso pode fazer bastante diferença, por exemplo, a camada de cima é subtraída da de baixo para o modo "Subtrativo". Além disso, você pode escolher em qual das trilhas sobrepor a saída combinada. (Dica: na maioria dos casos, você vai querer mutar a outra trilha e apenas reter esta saída combinada). 

@c cincvdoc_node_number_204
@node Perspectiva
@subsection Perspectiva
@cindex Perspectiva

@image{manual_images_intl/perspective,12.5mm}

O efeito de perspectiva permite que você mude a perspectiva de um objeto e é perfeito para fazer com que os objetos pareçam que estão sumindo na distância.

@c cincvdoc_node_number_205
@node Polar
@subsection Polar
@cindex Polar

@image{manual_images_intl/polar,12.5mm}

O efeito Polar dobra e embrulha seu vídeo em formas bizarras. Matematicamente, ele converte seu vídeo de ou coordenadas polares para coordenadas retangulares, ou o contrário.

@c cincvdoc_node_number_206
@node RGB-601
@subsection RGB-601
@cindex RGB-601

conserte-me.

@image{manual_images_intl/rgb601,12.5mm}

@c cincvdoc_node_number_207
@node Desfoque Radial
@subsection Desfoque Radial
@cindex Desfoque Radial

@image{manual_images_intl/radialblur,12.5mm}

Cria um desfoque de redemoinho que simula uma câmera espiralando. Você pode variar o local, tipo e a qualidade do desfoque.

@c cincvdoc_node_number_208
@node Mudar taxa de quadros - RT
@subsection Mudar taxa de quadros - RT
@cindex Efeito de vídeo Mudar taxa de quadros - RT

@image{manual_images_intl/reframert,12.5mm}

Mudar taxa de quadros - RT muda o número de quadros em uma seqüência de vídeo diretamente a partir da linha do tempo. Ele possui dois modos, selecionados por dois botões na interface@.

O modo @b{Stretch} multiplica o número de quadros atual de sua saída pelo fator de escala para chegar ao quadro para ler a partir de sua entrada. Se seu quadro de saída atual for #55 e o fator de escala 2, o quadro #110 é lido de sua entrada. O modo de esticamento tem o efeito de mudar a duração do vídeo de saída pelo inverso do fator de escala. Se o fator de escala for maior que 1, a saída vai terminar antes do final da seqüência na linha do tempo. Se ele for menor que 1, a saída terminará após o final da seqüência na linha do tempo. O efeito Mudar taxa de quadros - RT deve ter a sua duração relacionada à duração necessária para acomodar o fator de escala. Mude a duração do efeito clicando no final do efeito e arrastando-o.

Embora o modo de esticamento mude o número do quadro lido de sua entrada, ele não muda a taxa de quadros da entrada. Efeitos antes do Mudar taxa de quadros - RT assumem a mesma taxa de quadros que o Mudar taxa de quadros - RT@.

@cindex Efeito de reprodução rápida
Mudar taxa de quadros - RT, no modo de esticamento, pode ser usado para criar um @b{efeito de reprodução rápida}. Selecione o modo de esticamento e informe um valor acima de 1 para conseguir uma reprodução acelerada.

@cindex Efeito de reprodução lenta ("slow motion")
Para um @b{efeito de câmera lenta}, use o efeito Mudar taxa de quadros - RT no modo de esticamento com um valor menor do que 1. @b{Exemplo}: você possui um recorte que você quer colocar em câmera lenta. O recorte começa aos 33.792 sesegundos e termina aos 39.765. O recorte tem 5.973 de duração. Você quer reproduzi-lo a 4/10 avos de sua velocidade normal. Você divide a duração do recorte pela velocidade de reprodução (5.973/.4) para obter uma duração final de recorte de 14.9325 segundos. Você cria um ponto de entrada ao início de seu recorte: 33.792 segundos. Você coloca um ponto de saída 14.9325 segundos depois, a 48.7245 segundos (33.792 + 14.9325). Você adiciona um efeito de Mudar taxa de quadros - RT, marcando-o para .4 e esticamento. Você deve mudar o ponto de saída a 48.7245 para um ponto de entrada. Você começará seu próximo recorte após o efeito de câmera lenta ao ponto de saída 48.7245.

Você também pode mudar a taxa de quadros do recorte se você clicar com o botão direito do mouse no @b{visor de mídia} e ir para @b{Info}. Se você não escolher o menu antes, você pode informar uma taxa de quadros de sua escolha também. O Cinelerra pegará os quadros certos de saída para a taxa de quadros do projeto, efetivamente fazendo também a passagem de tempo.

O modo @b{Reduzir amostragem} não muda a duração da seqüência de saída. Ele multiplica a taxa de quadros da saída pelo fator de escala para chegar a uma taxa de quadros para ler a entrada. Isso tem o efeito de replicar os quadros de entrada de modo que eles apenas sejam mudados na taxa de quadros escalada quando enviados para a saída. Ele não muda a duração da seqüência. Se o fator de escala for 0.5 e a taxa de quadros de saída for 30 quadros por segundos, apenas 15 quadros serão mostrados por segundo e a entrada será lida a 15 quadros por segundo. Reduzir amostragem é útil apenas para fatores de escala abaixo de 1; portanto o nome Reduzir amostragem.

O modo de Reduzir amostragem muda a taxa de quadros da entrada assim como o número de quadros a serem lidos, então efeitos antes de Mudar taxa de quadros - RT vêem a taxa de quadros * o fator de escala como sua taxa de quadros. Se o fator de escala for 2 e a taxa de quadros de saída for 30, a taxa de quadros de entrada será 60 e o número do quadro de entrada será dobrado. Isso normalmente não fará nada, mas alguns efeitos de entrada podem se comportar de maneira diferente a uma taxa de quadros maior.

@c cincvdoc_node_number_356
@node Redirecionar
@subsection Redirecionar
@cindex Efeito de vídeo redirecionar

conserte-me.

Habilita a transferência seletiva do canal Alfa ou dos Componentes (RGB ou YUV) ou tanto a partir de uma trilha fonte para uma trilha alvo, parcialmente sobrescrevendo o conteúdo do alvo. Funciona como um plugin compartilhado. Um cenário de uso típico é construir uma Máscara possivelmente animada em uma trilha e então transferir o canal Alfa para outra trilha de conteúdo.

@c cincvdoc_node_number_209
@node Reverter vídeo
@subsection Reverter vídeo
@cindex Efeito Reverter vídeo

@image{manual_images_intl/reversevideo,12.5mm}

A mídia pode ser revertida na linha do tempo em tempo real. Isso não deve ser confundido com usar a reprodução reversa no transporte. Os efeitos de reversão revertem a região coberta pelo efeito independentemente da direção do transporte.

A região a ser revertida é primeiro determinada por qual parte da trilha o efeito estará abaixo e segundo pelas localizações dos quadros-chaves no efeito. Os efeitos de reversão possuem uma opção @b{habilitado} que permite que você marque quadros-chave. Isso introduz muitas possibilidades.

Cada quadro-chave @b{habilitado} é tratado como o início de uma nova região revertida e o fim de uma região previamente revertida. Vários quadros-chave @b{habilitados} em sucessão produzem várias regiões revertidas independentes umas das outras. Um quadro-chave @b{habilitado} seguido por um quadro-chave @b{desabilitado} produz uma região revertida seguida por uma região não-revertida.

@c cincvdoc_node_number_210
@node Rotacionar
@subsection Rotacionar
@cindex Rotacionar

@image{manual_images_intl/rotate,13.25mm}

O filtro Rotacionar pode rotacionar o vídeo em incrementos de 90 graus, reverter e inverter o vídeo.

@c cincvdoc_node_number_211
@node SVG via Inkscape
@subsection SVG via Inkscape
@cindex SVG via Inkscape

@image{manual_images_intl/svg,12.5mm}

conserte-me.

@c cincvdoc_node_number_212
@node Escala
@subsection Escala
@cindex Escala

@image{manual_images_intl/scale,12.5mm}

conserte-me.

@c cincvdoc_node_number_213
@node Média Temporal Seletiva
@subsection Média Temporal Seletiva
@cindex Média Temporal Seletiva

@image{manual_images_intl/timeavg,12.5mm}

Este plugin está desenhado para amenizar áreas sem-movimento se um recorte de vídeo. A amenização é feita tirando-se a média do componente de cor para cada pixel de um número de quadros. O valor de amenização é usado se tanto o desvio padrão e a diferença entre o valor componente atual e o valor componente médio estejam abaixo de uma entrada.

O desvio médio e padrão são calculados para cada um dos componentes do vídeo. O tipo dos componentes medidos é determinado pelo modelo de cor de todo o projeto. O desvio médio e padrão dos quadros pode ser examinado selecionando-se o botão específico de rádio na janela de opções do plugin.

A região sobre a qual é tirada a média dos quadros é determinada ou por um deslocamento fixo ou por um sistema de marcação de re-início ("restart marker system"). Em um sistema de marcação de re-início, certos quadros-chave são marcados como o começo de seções. Então, para cada seção, os quadros à volta do quadro atual são usados como os quadros para se tirar a média, exceto quando se aproximam do começo ou do final de uma seção, onde a média é feita por sobre os @i{X} quadros de início ou final respectivamente.

@b{Uso comum:}

Se você tem que selecionar o número de quadros dos quais você quer tirar a média.

@enumerate 1
@item Informe um número razoável de quadros para que se tire a média (ex. 10).
@item Selecione o método @b{Média Temporal Seletiva} e informe 1 e 10 para todas as @b{Entrada Média} e @b{Entrada Padrão} respectivamente. Isso basicamente faz com que todos os pixels usem o valor da média.
@item Ligue a máscara para o primeiro componente. Isso deve fazer com que todo o quadro possua uma cor sólida daquele componente específico.
@item Reduza aos poucos o valor da @b{Entrada Padrão}. Conforme você faz isso, você notará que regiões vastamente diferentes da média vão ostentar um estado de máscara invertida. Continue a reduzir a entrada até que você alcance o ponto em que as regiões sem movimento do vídeo possuam um estado de máscara invertida. Este valor é conhecido como o @b{ruído de chão ("noise-floor")} e é o nível do ruído natural gerado pelo CCD na câmera.
@item Repita o mesmo procedimento para a @b{Entrada Média}
@item Desligue a máscara
@item Repita isso para todos os canais
@end enumerate

@c cincvdoc_node_number_214
@node Aguçar
@subsection Aguçar
@cindex Aguçar

@image{manual_images_intl/sharpen,12.5mm}

conserte-me.

@c cincvdoc_node_number_215
@node Mudar Entrelaçamento
@subsection Mudar Entrelaçamento
@cindex Mudar Entrelaçamento

@image{manual_images_intl/shiftinterlace,12.5mm}

conserte-me.

@c cincvdoc_node_number_216
@node Inverter canais
@subsection Inverter canais
@cindex Inverter canais

@image{manual_images_intl/swapchannels,12.5mm}

conserte-me.

@c cincvdoc_node_number_217
@node Entrada
@subsection Entrada
@cindex Efeito de vídeo Entrada
@cindex Luminância

@image{manual_images_intl/threshold,12.5mm}

Entrada converte a imagem em luminância pura. Os valores de luminância abaixo e acima da abrangência de entrada são convertidos para preto e os valores de luminância dentro da abrangência da entrada são convertidos para branco. A janela de Entrada mostra um histograma dos valores de luminância do quadro atual. Clique-e-arraste dentro do histograma para criar uma abrangência para ser convertida em branco. @b{clicar-com-o-SHIFT} extende uma borda dessa abrangência. Valores para a abrangência da entrada também podem ser especificados nas caixas de texto.

Este efeito é basicamente uma chave primitiva de luminância ("luminance key"). Uma segunda trilha acima da primeira com o efeito de Entrada pode ser multiplicada, resultando em apenas as partes da segunda trilha dentro da Entrada sendo reproduzida.

@c cincvdoc_node_number_218
@node Média de tempo
@subsection Média de tempo
@cindex Efeito de vídeo Média de tempo

@image{manual_images_intl/timeavg,12.5mm}

Média de tempo é um efeito que possui vários usos além de criar padrões engenhosos de trilha de objetos se movendo. Seu uso principal é reduzir o ruído em imagens estáticas. Simplesmente aponte uma câmera de vídeo a um objeto estacionário por 30 quadros, capture os quadros e faça a média deles usando a @b{Média de tempo} e você terá uma qualidade de impressão super alta. Em modelos de cor de ponto flutuante ("floating point"), a média de tempo pode aumentar a abrangência dinâmica de câmeras muito ruins.

Dentro do efeito de Média de tempo está um buffer de acumulação e um divisor. Um número de quadros é calculado no buffer de acumulação e divididos pelo divisor para obter-se a média.

Já que a média de tempo pode consumir quantidades exorbitantes de memória, é melhor que ela seja aplicada primeiro desabilitando a reprodução da trilha, jogando o efeito Média de tempo nela, configurando a média de tempo para o número desejado de quadros e re-habilitando a reprodução da trilha.

@itemize @bullet
@item @b{Quadros para tirar média} @*
Determina o número de quadros a serem acumulados no buffer de acumulação. Para integrações extremamente largas, é mais fácil editar o EDL em um editor de texto e informar o número de quadros.

@item @b{Acumular} @*
Dá saída ao buffer de acumulação sem dividi-la.

@item @b{Média} @*
Faz com que o buffer de acumulação seja dividido antes de ser enviado para a saída. Resulta em uma média de todos os quadros.

@item @b{Inclusivo Ou} @*
Faz com que o buffer de acumulação seja substituído por quaisquer pixels que não são transparentes. Em combinação com o rastreamento de movimento, permite que seqüências inteiras sejam combinadas para formar panoramas.

@item @b{Reprocessar quadro} @*
Se um efeito antes da Média de Tempo for ajustado, a média de tempo normalmente não relê o buffer de acumulação para entender a mudança. Esta opção o força a reler o buffer de acumulação quando outros efeitos mudarem.

@item @b{Desabilitar subtração} @*
Para representar o acúmulo de não apenas o número especificado de quadros, a média de tempo retém todos os quadros anteriores na memória e os subtrai quando for houver uma reprodução. Não haveria memória suficiente caso ele tivesse que acumular milhares de quadros. Desabilitar a subtração significa que os quadros anteriores não são armazenados na memória e apenas a função média é afetada pela contagem de quadros.
@end itemize

@c cincvdoc_node_number_219
@node Frente de Tempo
@subsection Frente de Tempo
@cindex Frente de Tempo

@image{manual_images_intl/timefront,12.5mm}

Este é um plugin de distorção baseado neste artigo: @*
@uref{http://www.vision.huji.ac.il/videowarping/HUJI-CSE-LTR-2005-10_etf-tr.pdf}

@c cincvdoc_node_number_220
@node Título
@subsection Título
@cindex Título
@cindex Gimp

@image{manual_images_intl/titler,12.5mm}

Embora seja possível adicionar textos a vídeos importando imagens estáticas do Gimp e usando-as, o efeito Título permite que você adicione texto a partir do próprio Cinelerra.

O Título possui opções padrão para @b{fonte, tamanho e estilo}. A melhor fonte é uma genérica, fonte normal como um Arial em um tamanho maior.

O Título também possui opções que você vai encontrar apenas em imagens em movimento. A operação @b{Justificar} justifica o texto relativo a todo o quadro. Uma vez justificado, o deslocamento @b{X e Y} é aplicado. Isso permite que o texto seja justificado ao mesmo tempo em que você pode empurrá-lo dentro da margem de segurança.

O @b{Tipo de movimento} move o texto em qualquer das quatro direções. Quando for usado, o texto pode desaparecer. Assegure-se que a velocidade esteja marcada para um valor razoavelmente alto (tente 150) e mova o ponto de inserção ao longo da linha do tempo até que o texto esteja longe o suficiente ao longo da animação para reaparecer.

Marcar a opção @b{loop} faz com que o texto saia completamente e se repita. Sem ela, o texto sai da tela e nunca mais reaparece.

A velocidade da animação é determinada pela @b{velocidade}, em pixels por segundo. Configure-a para um número mais alto para aumentar a velocidade da animação.

@b{Sombra de fundo} desenha uma cópia preta do texto original perto de sua base direita. Isso é útil quando se está desenhando um texto por sobre um vídeo que está mudando para manter as bordas sempre visíveis.

Além da possibilidade de movimentação do texto, @b{Fade in/Fade out} são um segundo tipo de animação. Se os segundos para o fade são 0, nenhum fade é feito.

@b{Cor} pega a cor para se desenhar o texto. Normalmente, branco é a única cor praticável.

@b{Estampar código de tempo} substitui o texto com a posição atual da linha do tempo em segundos e quadros.

A entrada do Título é limitada a 1023 caracteres. Títulos maiores do que 1023 caracteres serão aceitos pelo software, mas provavelmente causarão travamentos. Veja @uref{http://bugs.cinelerra.org/show_bug.cgi?id=155|bug 155} para saber mais sobre isso.

O efeito de título suporta quadros-chave. Para adicionar legendas a seu vídeo, você precisará marcar um efeito de título e definir quadros-chave. Se você habilitar a marcação automática de quadros-chave @image{manual_images_intl/autokeyframe}, um novo quadro-chave será criado cada vez que você editar o texto. Na caixa de entrada de texto, você verá a legenda disposta abaixo do ponto de inserção.

@b{Observação:} Para adicionar legendas, você deveria provavelmente utilizar um editor de legendas. Veja 
@xref{Adicionando legendas}, para mais informação.

@menu
* Adicionando fontes:: 				Como adicionar fontes ao efeito Título
* A margem de segurança para títulos::      	Como manter o texto visível na saída
@end menu

@c cincvdoc_node_number_221
@node Adicionando fontes
@subsubsection Adicionando fontes
@cindex Fontes, adicionando
@cindex Fontes TTF
O sistema X Window originalmente não possuía um renderizador adequado de fontes para vídeo. Ele também é restrito à profundidade de bits atual. Ele não possui uma forma conveniente de saber quais fontes funcionam com o renderizador adequado de fontes na profundidade de bits desejada. O jeito mais fácil que encontramos de suportar fontes no efeito Título é ter um diretório para elas em @file{/usr/lib/cinelerra/fonts}.

O Título suporta principalmente fontes True Type, @b{TTF}. Ele suporta outras, mas as TTF são as mais confiáveis. Para adicionar fontes true type, copie os arquivos @file{.TTF} para a pasta @file{/usr/lib/cinelerra/fonts}. Naquela pasta, execute o comando @command{ttmkfdir && mv fonts.scale fonts.dir} e reinicie o Cinelerra. As novas fontes devem aparecer. O uso do ttmkfdir muda freqüentemente, então esta técnica pode não funcionar.

@c cincvdoc_node_number_222
@node A margem de segurança para títulos
@subsubsection A margem de segurança para títulos
@cindex A margem de segurança para títulos
@cindex Exibição em TV

Se o vídeo for exibido em uma televisão de consumidor, a borda mais para fora será recortada em 5% de cada lado. Mais do que isso, o texto que estiver muito próximo a esta margem parecerá desalinhado. Assegure-se, quando estiver adicionando títulos, de ter a ferramenta @b{margem de segurança} @image{manual_images_intl/titlesafe} ativa na janela do @b{compositor}. O texto não deve sair do retângulo interno.

@c cincvdoc_node_number_223
@node Trasladar
@subsection Trasladar
@cindex Trasladar

@image{manual_images_intl/translate,12.5mm}

Este efeito permite deslocar, recortar e/ou escalar o vídeo-fonte horizontal ou verticalmente. Os parâmetros de Entrada e Saída funcionam de forma similar às funções de câmera e projetor no Compositor:

@itemize @bullet
@item X/Y de Entrada especificam a partir de quantos pixels para a esquerda/topo da fonte você quer começar (câmera), enquanto X/Y de Saída definem onde na tela você quer que a saída comece (projetor)
@item L/A de Entrada definem a partir de quantos pixels da fonte você vai querer incluir em cada direção enquanto a L/A de Saída definem quantos pixels na tela você quer que a fonte leve. Valores idênticos para tanto Entrada quanto Saída que forem menores que a dimensão da fonte simplesmente recortarão a fonte. Valores diferentes alargarão (ou comprimirão se Saída > Entrada) a fonte naquela direção (e recortarão se a Entrada for menor que a dimensão da fonte.)
@end itemize

Este efeito suporta quadros-chave, de forma que estes parâmetros possam mudar suavemente conforme o tempo.

Você pode usar este efeito para muitas coisas como ter um bloco de edição recortado se movendo pela tela, ou mudando de tamanho ou se alongando conforme faz isso. Saiba de antemão, porém, que para material entrelaçado deslocamentos horizontais provavelmente destruirão a ordem dos campos, resultando em todos os tipos de "gagueiras" ("flickering") e saltos de movimentos. 

@c cincvdoc_node_number_224
@node Desaguçar
@subsection Desaguçar
@cindex Desaguçar

@image{manual_images_intl/unsharp,12.5mm}

Este efeito aplica uma técnica adicional de sala escura, a assim chamada máscara de desaguçamento, para cada quadro de vídeo. Com parâmetros diferentes de valores, isso pode ser usado para suavizar ou aguçar a imagem. Seus parâmetros são:
@itemize @bullet
@item @b{Quantidade} @*
Mover o deslizador para a direita faz com que as áreas mais escuras fiquem ainda mais escuras e as áreas mais claras fiquem ainda mais claras.

@item @b{Raio} @*
Este deslizador controla quanto de desfoque será usado no estágio de busca por bordas. O efeito prático disso é especificar quão larga uma região será escurecida ou clareada.

@item @b{Entrada} @*
Este deslizador permite controlar quão grande é uma diferença entre um pixel na cópia desfocada e a cópia original é requerida antes que qualquer escurecimento ou clareamento seja aplicado.
@end itemize

@c cincvdoc_node_number_225
@node Escopo do Vídeo
@subsection Escopo do Vídeo
@cindex Escopo do Vídeo

@menu
* O escopo em forma de onda::
* O escopo em forma de vetor::
@end menu

@image{manual_images_intl/videoscope,12.5mm}

Escopo do Vídeo é uma ferramenta que representa digitalmente is níveis de luz e cor em uma tela calibrada. Ele é útil porque o olho humano não está especializado para detectar o nível preciso de luz e cor, mas para detectar as diferenças entre as luzes e cores.

O Escopo do Vídeo pode ser usado em junção com outros plugins do Cinelerra como YUV, Gradação de cor, Brilho, Histograma para corrigir precisamente o vídeo para contraste, claridade, conformância (normalizar vários vídeos gravados sob diferentes condições de luz) ou para propósitos cinemáticos.

Algum pensamento está sendo dedicado a se ter um Escopo do Vídeo para gravação. Infelizmente, isso requereria um monte de variações do Escopo do Vídeo para todos os drivers diferentes de vídeo.

O Escopo do Vídeo contém dois modos de exibição: o @b{escopo em onda} e o @b{escopo em vetor}

@c cincvdoc_node_number_226
@node O escopo em forma de onda
@subsubsection O escopo em forma de onda
@cindex O escopo em forma de onda

A tela marcada verticalmente da base ao topo da base ou 0% é o Topo de Preto máximo ou 100% é o Branco máximo. Divide a fonte de vídeo em colunas verticais de pixels e então cada pixel da coluna é mensurado e o escopo em forma de onda é pintado na escala vertical correspondente de acordo com seu valor de intensidade de luz.

Um pixel na base do escopo indica o preto total; um pixel no topo (100%) do escopo significa branco total.

A imagem mostra uma marcação de linhas em passos no escopo, indicando os níveis correspondentes de luminância nas barras da imagem de teste. Múltiplos níveis na mesma coluna são representados por múltiplas linhas no escopo.

O escopo em forma de onda ajuda a corrigir os níveis de luz de uma imagem para abrangência de contraste ou para conformar níveis de luz em várias cenas originalmente gravadas em diferentes configurações de luz.

Ajustando os níveis de luz (ajustando a luminância): 

Insira o efeito xxx em sua trilha, clique com o botão direito do mouse no efeito e clique em "mostrar". Insira o efeito Escopo de Vídeo na trilha (assegure-se que ele esteja colocado abaixo do efeito xxx, de forma que ele possa ver o resultado do efeito xxx). Clique com o botão direito do mouse e escolha "mostrar". Olhando o nível de luminância mostrado na onda, ajuste o controle do xxx para que ele se adeque ao nível desejado de luz para sua imagem. Se você está procurando por uma abrangência de contraste melhor, ajuste o nível do xxx no plugin para alinhar o ponto mais escuro do escopo à escala de 0% e a porção mais branca de interesse a 100%. Qualquer coisa acima de 100% estará super-saturada.

@c cincvdoc_node_number_227
@node O escopo em forma de vetor
@subsubsection O escopo em forma de vetor
@cindex O escopo em forma de vetor

O escopo em forma de vetor é usado para monitorar cor. A tela representa uma roda de cor onde o valor da cor de pixel está pontilhado no raio de uma linha que se move para longe do centro. O raio menor indica o branco absoluto e os círculos que se afastam indicam valores maiores de intensidade.

O tom da cor também é pontilhado, representado pelo ângulo em graus na roda de cor, representando tons diferentes de cores.

O escopo em forma de vetor pode ser usado com outros plugins para corrigir a cor, ajustar a matiz da imagem e aplicar outros efeitos para efeitos cinemáticos, correção de imagem ou para conformar telas separadas para parecerem a mesma.

O escopo em forma de vetor também pode ser usado para monitorar se a saída de vídeo pode ser reproduzida devidamente em vários monitores. Quaisquer pontos ao longo do raio interior serão exibidos como branco puro e quaisquer pontos acima do raio de 100% muito provavelmente não serão exibidos corretamente na tela.

@c cincvdoc_node_number_228
@node Onda
@subsection Onda
@cindex Onda

@image{manual_images_intl/wave,12.5mm}

O efeito de Onda adiciona ondas à imagem.

@center @image{manual_images_en/effect_wave_before_after,120mm}

Você pode ajustar os seguintes parâmetros:

@center @image{manual_images_intl/effect_wave_window,60mm}

@c cincvdoc_node_number_229
@node Rodopiar
@subsection Rodopiar
@cindex Rodopiar

@image{manual_images_intl/whirl,12.5mm}

conserte-me.

@c cincvdoc_node_number_230
@node YUV
@subsection YUV
@cindex YUV

@image{manual_images_intl/yuv,12.5mm}

conserte-me.

@c cincvdoc_node_number_231
@node Desfoque de Aproximação
@subsection Desfoque de Aproximação
@cindex Desfoque de Aproximação

@image{manual_images_intl/zoomblur,12.5mm}

conserte-me.

@c cincvdoc_node_number_232
@node Efeitos renderizados
@chapter Efeitos renderizados
@cindex Efeitos renderizados
@cindex Efeitos, renderizados

Um outro tipo de efeito é performado em uma seção da trilha e fica armazenado em algum lugar antes de ser reproduzido. O resultado normalmente é colado à trilha para substituir o original.

Efeitos renderizados não são listados na Janela de Recursos; ao invés disso, podem ser acessados pelas opções de menu @b{Áudio->Renderizar efeito} e @b{Vídeo->Renderizar efeito}. Cada uma dessas opções trás uma caixa de diálogo para o efeito renderizado. Efeitos renderizados se aplicam para apenas um tipo de trilha, seja áudio ou vídeo. Se nenhuma trilha deste tipo existe, um erro aparece.

Uma região na Linha do Tempo onde será aplicado o efeito deve ser definida antes de selecionar @b{Renderizar efeito...}.  Se nenhum ponto de entrada/saída e nenhuma região destacada existem, toda a região após o ponto de inserção é tratada como área afetada. De outra forma, a região entre os pontos de entrada/saída ou a região selecionada será a região afetada.

As trilhas onde será aplicado o efeito renderizado devem estar @b{armadas}. Todas as outras trilhas serão ignoradas.

Finalmente, o efeito renderizado processa certos atributos da trilha quando lê as informações de entrada mas não outras. Transições na trilha afetada são aplicadas. Arrastos ("nudge") não são e efeitos não são. Isso permite que novos dados sejam colados na posição existente sem que se mude o valor de deslocamento ("nudge value").

Na caixa de diálogo de renderização de efeito está uma lista de todos os efeitos tempo-real e renderizáveis. A diferença aqui é que os efeitos tempo-real são renderizados para o disco rígido e não aplicados abaixo da trilha. Selecione um efeito da lista para designá-lo como o que será executado.

Defina um arquivo para onde o efeito será renderizado na caixa @b{Selecione um arquivo para renderizar para}. A lente de aumento @image{manual_images_intl/magnify,7mm} permite que você selecione um arquivo a partir de alguma lista.

Selecione o formato de arquivo que seja melhor para o tipo de trilha. O ícone de ferramenta @image{manual_images_intl/wrench,4.33mm} permite configurações específicas ao formato de arquivo.

Também existe uma opção para criar um novo arquivo a cada marcador. Se você pussui uma extração de CD na sua Linha do Tempo que queira dividir em arquivos diferentes, os marcadores se tornariam pontos de divisão entre os arquivos se esta opção for selecionada. Quando a Linha do Tempo está dividida por marcadores, o efeito é reiniciado a cada marcador. Operações de normalização pegam o pico do arquivo atual e não de toda a Linha do Tempo.

Finalmente, há a estratégia de inserção como na caixa de diálogo de render. Deve ser notado que mesmo que o efeito se aplica apenas para áudio ou vídeo, a estratégia de inserção se aplica a todas as trilhas como em uma operação de fichário.

Quando você clica em @b{OK} na caixa de diálodo de efeito, ela chama o GUI (interface gráfica) do efeito. Se o efeito também é tempo-real, uma segunda GUI aparece para que se aceite ou rejeite as configurações atuais. Após aceitar as configurações, o efeito é processado.

@menu
* Efeitos renderizados de áudio::     Efeitos renderizados de áudio
* Efeitos renderizados de vídeo::     Efeitos renderizados de vídeo
@end menu

@c cincvdoc_node_number_233
@node Efeitos renderizados de áudio
@section Efeitos renderizados de áudio
@cindex Efeitos renderizados de áudio

@menu
* Refazer amostragem::        Como reduzir a abrangência dinâmica do áudio.
@end menu

@c cincvdoc_node_number_234
@node Refazer amostragem
@subsection Refazer amostragem
@cindex Efeito de refazer amostragem

Multiplica o número de cada amostragem de saída por uma fator de escala para chegar ao número de amostragem de entrada. A amostragem do arquivo de saída é configurada para a taxa de amostragem ("sample rate") do projeto, mas sua duração é mudada para refletir o número escalado de amostras. Também filtra o áudio com a nova amostragem para remover 'aliasing'.

Se o fator de escala é 2, cada 2 amostras de entrada serão reduzidas para 1 amostra de saída e o arquivo de saída terá a metade das amostras da seqüência de entrada. Se é de 0.5, cada 0.5 amostras de entraga serão esticadas para 1 amostra de saída e o arquivo de saída terá duas vezes o número de amostras da seqüência de entrada.

@c cincvdoc_node_number_235
@node Efeitos renderizados de vídeo
@section Efeitos renderizados de vídeo
@cindex Efeitos renderizados de vídeo

@menu
* Reframe::        Reframe
@end menu

@c cincvdoc_node_number_236
@node Reframe
@subsection Reframe
@cindex Efeito de vídeo reframe

Faz exatamente a mesma coisa que o @b{Mudar taxa de quadros - RT} no modo @b{Esticar}. Multiplica o número de quadros de saída pelo fator de escala para chegar a um número de quadros de entrada e muda a duração da seqüência. Ao contrário do ReframeRT, este efeito deve ser usado a partir do menu de @b{Vídeo} e renderizar sua saída.

Saiba que o @b{Mudar taxa de quadros} não escreve a taxa de quadros escalada como a taxa de quadros do arquivo renderizado. Ele produz um arquivo de duração escalada e taxa de quadros igual à do projeto. A nova duração é 1/fator de escala tão grande quanto for a seqüência original.

@b{Para criar um vídeo em câmera-lenta ou reprodução rápida:}
@enumerate 1
@item Selecione o recorte de vídeo que você quer fazer um re-frame e coloque-o em uma trilha de vídeo
@item Selecione a área que você quer que seja afetada
@item Do menu de Vídeo, selecione a opção Renderizar Efeito
@item Da lista de efeitos, selecione Reframe
@item Informe o formato de saída e estratégia de inserção para o novo recorte a ser criado
@item Pressione ok
@item No menu que aparecer, informe o fator de escala como 2 para que o vídeo rode duas vezes mais rápido e .5 para que rode a metade da valocidade
@end enumerate

@c cincvdoc_node_number_237
@node Efeitos ladspa
@chapter Efeitos ladspa
@cindex Efeitos ladspa

Efeitos LADSPA são suportados nos modos tempo-real e renderizáveis para áudio. Os plugins LADSPA que você acha na internet variam em termos de qualidade. A maioria não pode ser mexida em tempo real tão facilmente e trabalham melhor quando renderizados. Alguns dão pau e alguns podem ser aplicados apenas em uma trilha devido a uma falta de re-entrada ("lack of re-entrancy"). Embora o Cinelerra implemente a interface LADSPA de forma tão acurada quanto possível, trilhas múltiplas de tempo-real, processamento simultâneo vão além da maioria dos usuários de LADSPA. Os efeitos LADSPA aparecem na pasta de áudio como o martelo ("hammer") e o chave de fenda ("screwdriver"), para significar que são Plugins para desenvolvedores de áudio GNU/Linux.

Os efeitos LADSPA são habilitados simplesmente ao se configurar a variável de ambiente @env{LADSPA_PATH} para o local de seus plugins LADSPA ou colocando-os na pasta @file{/usr/lib/cinelerra}.

Se você usa Debian, você pode conseguir um monte de plugins usando o apt: @*
@command{apt-cache search ladspa} @*
@command{apt-get install jack-rack cmt blop swh-plugins}

@c cincvdoc_node_number_238
@node Transições
@chapter Transições
@cindex Transições

@menu
* Usando transições::
* Transição de vídeo "Dissolver"::
@end menu

@c cincvdoc_node_number_239
@node Usando transições
@section Usando transições
@cindex Usando transições

Um vídeo é composto de várias cenas e tomadas. No entanto, nem sempre o corte seco - no qual uma cena sai e, imediatamente, a cena seguinte aparece - é o mais adequado para o momento e o conteúdo que o vídeo pretende expressar. As transições são uma forma de se passar de uma cena à outra com diferentes variações.

O Cinelerra suporta transições de áudio e de vídeo, as quais estão listadas na janela de Recursos.

@center @image{manual_images_intl/resources_video_transitions,70mm}
@center @b{Transições de vídeo na janela de Recursos}

As transições só podem ser aplicadas a determinados tipos de trilhas. As transições presentes em @b{transições de áudio} só podem ser aplicadas às trilhas de áudio.  Já as transições presentes em @b{transições de vídeo} só podem ser aplicadas às trilhas de vídeo.

Abra um arquivo de vídeo e adicione dois trechos à linha do tempo. Vá até a janela de Recursos e clique na pasta @b{Transições de vídeo}. Arraste uma transição qualquer da lista e solte-a sobre o segundo vídeo na linha do tempo. Aparecerá uma caixa informando que temos uma transição naquele ponto. Ao fazer isto, aplicamos uma transição entre a primeira e a segunda cena do vídeo.

@center @image{manual_images_intl/drop_transition}
@center @b{Arrastando uma transição "Dissolver" para a linha do tempo}

Agora você pode reproduzir o vídeo e ver como ficou a transição pela @b{janela Compositor}. Às vezes, a transição é tão curta que quase não é possível percebê-la. Veremos a seguir como apagar e editar as transições.

@cindex Retirar Transições
@cindex Editar Transições

Uma vez que a transição está inserida, esta pode ser editada da mesma forma que um efeito. Clique com o botão direito do mouse sobre a transição para acessar seu menu. A opção @b{mostrar} traz alguns parâmetros específicos para a transição em questão. A opção @b{comprimento} determina o tempo de duração da transição em segundos. Assim que esses dois parâmetros são ajustados, eles são aplicados às futuras transições até que sejam modificados novamente. Pra finalizar, a opção @b{Separar} remove a transição da linha do tempo.

Arrastar e soltar as transições da janela de Recursos para a janela principal do Cinelerra pode ser lento e cansativo. Felizmente, uma vez que uma transição é arrastada da janela de Recursos, você pode usar as teclas @b{U} e @b{u} para inserir novamente a mesma transição. A tecla @b{U} insere a última transição de vídeo utilizada e a @b{u} (minúsculo) insere a última transição de áudio em todas as trilhas não protegidas de gravação. Se o cursor ou o ponto de entrada (colchete) estiver sobre um trecho de áudio ou vídeo, a transição será inserida no começo desse trecho.

Quando as transições são reproduzidas da linha do tempo para a placa aceleradora de vídeo, a aceleração do hardware geralmente será desativada durante a transição e reativada logo depois. Esse procedimento é usado para que a transição possa ser renderizada. Ao se usar uma placa de vídeo sem aceleração, normalmente não ocorre esse problema.

@b{Importante:} O ponto exato em que a transição vai ser reproduzida não é durante o primeiro trecho de vídeo. A transição é iniciada assim que a segunda cena começa a ser reproduzida e permanece ativa por uma certa quantidade de tempo. Por isso, é necessário que o primeiro trecho de vídeo tenha alguns quadros após o ponto de corte para que a transição seja completada sobre a segunda cena.

Por exemplo, a transição "Dissolver" é iniciada no ponto exato em que está localizada na linha do tempo. Se você determinar a duração de um minuto para a transição, esta @b{não iniciará} meio segundo antes do corte e continuar por meio segundo depois desse ponto. Ao contrário, ela será iniciada exatamente após o ponto de corte e perpetuará por um segundo após este ponto.

É um erro comum colocar a transição "Dissolver" logo depois do último quadro de um bloco de vídeo. Vamos imaginar que a transição foi colocada entre o bloco A e o bloco B, logo depois do último quadro do bloco A.

No momento em que a transição começa a ser reproduzida, não há mais quadros do bloco A para serem exibidos. Em virtude disso, não há outra escolha para o cinelerra a não ser congelar o último quadro do bloco A e dissolvê-lo com o bloco B.

É preciso ter certeza de que há quadros suficientes do bloco A para serem exibidos durante o tempo em que a transição vai ser reproduzida. A duração desses quadros deve ser igual ou maior do que o tempo de duração da transição.

@c cincvdoc_node_number_240
@node Transição de vídeo "Dissolver"
@section Transição de vídeo "Dissolver"
@cindex Transição de vídeo "Dissolver"

@image{manual_images_intl/video_disolve_icon}

Esta é uma suave transição "Dissolver" entre dois trechos de vídeo, os quais nós chamaremos de trecho inicial e trecho final. O trecho inicial vai ganhando transparência e desaparecendo enquanto o trecho final vai surgindo aos poucos. A duração de tempo para esse processo acontecer pode ser determinado pelo controle de "Comprimento".

@b{Controles disponíveis:} @*
Clicando com o botão direito no ícone da transição na linha do tempo, um menu irá aparecer com os seguintes controles
@itemize @bullet
@item @b{Mostrar:} Abra uma janela com opções específicas da transição (não disponível para a "Dissolver")
@item @b{Ligado:} Ativa e desativa a transição
@item @b{Comprimento:} Determina a duração em segundos da transição
@item @b{Separar:} Remove a transição da linha do tempo
@end itemize

@c cincvdoc_node_number_241
@node Usando quadros-chave
@chapter Usando quadros-chave
@cindex Usando quadros-chave

O termo "quadro-chave" é emprestado do mundo da animação, onde ele se refere a um desenho essencial (chave) em uma seqüência. Tipicamente, isso seria o ponto de início ou de final de uma transição suave em uma série de quadros. Os quadros-chave seriam desenhados por artistas mais velhos e seus assistentes desenhariam os "entre-eles". O termo "quadro-chave" desde então vem sendo usado para sugerir conceitos similates em outras áreas.@*

Na edição não-linear de vídeo digital e software de composição de vídeo, um quadro-chave representa um certo valor marcado pelo usuário a um certo ponto na linha do tempo. Por exemplo, você poderia usar quadros-chave para fazer um fade em um recorte marcando a transparência para 100% no primeiro quadro-chave e adicionar outro quadro-chave 5 segundos depois na linha do tempo com um valor de transparência de 0%. Um quadro-chave é usado para manipular as mudanças feitas no sinal conforme o tempo, essencialmente agindo como um ponto de controle para o usuário para marcar parâmetros, por exemplo de efeitos. O Cinelerra interpola os valores intermediários fazendo com que a mudança aconteça suave e gradualmente conforme o tempo.@*

@cindex Quadro-chave padrão
@cindex Quadro-chave, padrão
Quando você muda o fade, câmera, projetor ou outros parâmetros de uma trilha, eles ficam por padrão o mesmo por toda a duração do projeto. Seus valores são armazenados em um quadro-chave. O quadro-chave onde ele é armazenado por padrão é conhecido como o @b{quadro-chave padrão}. O quadro-chave padrão se aplica à duração inteira apenas caso não haja outros quadros-chave presentes e caso não seja desenhado na linha do tempo.

O único jeito em que ocorre a mudança conforme o tempo é caso quadros-chave adicionais sejam criados.@*
Marcar parâmetros estáticos com o quadro-chave padrão é útil apenas caso você não queira mudar nada conforme o tempo. Normalmente você precisará mover a câmera ou mudar as posições de máscara, por exemplo caso uma máscara precise seguir um objeto. Definir quadros-chave adicionais ao padrão é uma técnica muito conveniente de criar mudanças dinâmicas.

No Cinelerra, há quadros-chave para quase todos os parâmetros de composição e de efeito.@*
Parâmetros podem ser representados graficamente de várias formas: curvas, botões de habilitação/desabilitação, modos e assim por diante.@*
O quadro-chave relativo pode ser representado na linha do tempo como um pequeno quadrado em uma curva (ex. fade) ou um símbolo (ex. máscara).@*
No Cinelerra, o termo "quadro-chave" pode ser enganador: ele não se refere a um quadro, mas a um ponto entre dois quadros.

Para exibir a representação gráfica dos parâmetros e os quadros-chave relativos, use o menu de @b{Ver}.@*
Um jeito mais rápido de habilitar/desabilitar múltiplos tipos de parâmetros é trazer @b{Janela -> Mostrar Sobreposições}. 
Esta janela permite habilitar/desabilitar cada parâmetro no menu de visão. Quando os parâmetros são selecionados, eles são desenhados na linha do tempo por sobre as trilhas aos quais eles se aplicam. 

Como usar os diferentes tipos de quadros-chave está descrito aqui.

@menu
* Quadros-chave de curva::
* Quadros-chave de ativação/desativação::
* Quadros-chave automáticos::
* Quadros-chave do Compositor::
* Editando quadros-chave::
@end menu

@c cincvdoc_node_number_242
@node Quadros-chave de curva
@section Quadros-chave de curva
@cindex Quadros-chave de curva
@cindex Quadros-chave, curva

Muitos parâmetros são armazenados em curvas Bezier. Vá para @b{ver->fade} ou @b{ver->...aproximação} para exibir as curvas na linha do tempo para estes parâmetros. Tanto no modo de edição de recortar e colar quanto no de arrastar e soltar, mova o cursor por sobre as curvas na linha do tempo até que ela tome forma. Então, simplesmente clicando ou arrastando na curva, você pode criar um quadro-chave na posição.

Após o quadro-chave ser criado, clique nele e arraste-o para reposicioná-lo. Quando você clica e arrasta um segundo quadro-chave na curva, ela cria uma rampa suave.
@b{arrastar-com-o-CTRL} em um quadro-chave muda o valor ou do controle de entrada ou do controle de saída. Isso afetará a agudeza da curva. Enquanto o controle de entrada e o controle de saída podem ser movidos horizontalmente/verticalmente, o movimento horizontal é puramente para legibilidade e não é usado no valor da curva.

Você pode lembrar que o Gimp e as máscaras de Composição usam @key{SHIFT} para selecionar pontos de controle, então porque a linha do tempo usa a tecla @key{CTRL}? Quando você @b{arrastar-com-o-SHIFT} em uma curva da linha do tempo, o quadro-chave adere ao valor do quadro anterior ou posterior, dependendo de qual exista. Isso permite que marque um valor constante de curva sem ter que copiar o quadro-chave anterior ou posterior.

@menu
* Navegando pelos quadros-chave de curva::
@end menu

@c cincvdoc_node_number_243
@node Navegando pelos quadros-chave de curva
@subsection Navegando pelos quadros-chave de curva
@cindex Navegando pelos quadros-chave de curva

Não há muito espaço na linha do tempo para uma grande abrangência de valores de curvas. Você precisará aproximar ou desaproximar as curvas verticalmente para possuir alguma variabilidade. Isso é feito por duas ferramentas: o botão de adequação de automação e o menu de aproximação de automação @image{manual_images_intl/autozoom}.

O botão de adequação de automação escala e desloca a abrangência vertical de modo que a área de curva selecionada apareça na linha do tempo. Se uma região da linha do tempo estiver destacada pelo cursor, apenas aquela região é escalada. Pontos de entrada/saída não afetam a região a ser aproximada. @kbd{ALT-f} também faz a adequação de automação.

O menu de aproximação de automação muda manualmente a escala vertical das curvas em múltiplos de 2. Clique em sua seta para mudar a aproximação. @kbd{ALT-PARACIMA} e @kbd{ALT-PARABAIXO} mudam a aproximação de automação a partir do teclado.

@c cincvdoc_node_number_244
@node Quadros-chave de ativação/desativação
@section Quadros-chave de ativação/desativação
@cindex Quadros-chave de ativação/desativação
@cindex Quadros-chave, ativação/desativação

Mutar é o único quadro-chave de ativação/desativação. Os quadros-chave de mutar determinam se a trilha é processada mas não renderizada para a saída. Clique e arraste nessas curvas para criar um quadro-chave. Diferentemente das curvas, o quadro-chave de ativação/desativação possui apenas dois valores: ligado ou desligado.
@key{CTRL} e @key{SHIFT} não fazem nada nos quadros-chave de ativação/desativação.

@c cincvdoc_node_number_245
@node Quadros-chave automáticos
@section Quadros-chave automáticos
@cindex Quadros-chave automáticos
@cindex Quadros-chave, automáticos

Você deve ter notado que quando algumas curvas de fade estão marcadas, mover o ponto de inserção pelas curvas faz com que os faders reflitam o valor da curva abaixo do ponto de inserção. Isso não é só para parecer legal. Os próprios faders podem marcar quadros-chave no modo de quadros-chave automáticos. O modo de quadros-chave automáticos é normalmente mais útil do que arrastar curvas.

Habilite o modo de quadros-chave automáticos habilitando o botão de quadros-chave automáticos @image{manual_images_intl/autokeyframe}.  No modo de quadros-chave , cada vez que você movimentar um parâmetro passível de possuir um quadro-chave, um quadro-chave será criado na linha do tempo. Uma vez que quadros-chave automáticos afetam muitos parâmetros, é melhor habilitá-los só quando você precisa de um quadro-chave e desabilitá-lo em seguida.

É útil ir no menu @b{Ver} e tornar o parâmetro desejado visível antes de fazer alguma mudança. O local onde o quadro-chave automático é gerado está abaixo do ponto de inserção. Se a linha do tempo estiver sendo reproduzida quando se fizer alguma alteração, vários quadros-chave automáticos serão gerados conforme você muda o parâmetro.

Quando o modo de quadros-chave automáticos está desabilitado, uma coisa também estranha acontece. Ajustar um parâmetro ajusta o quadro-chave que imediatamente precede o ponto de inserção. Se dois quadros-chave de fade existirem e o ponto de inserção estiver entre eles, mudar o fader muda o primeiro quadro-chave.

Há vários parâmetros que podem receber quadros-chave apenas no modo de quadros-chave automáticos. Estes são parâmetros para os quais as curvas levariam muito espaço na trilha ou que não podem ser facilmente representados por uma curva.

Efeitos podem receber quadros-chave apenas no modo automático devido ao número de parâmetros em cada efeito individual.

Traslado de câmera e projetor podem receber quadros-chave no modo de quadros-chave automáticos enquanto a aproximação de câmera e projetor podem receber quadros-chave com curvas. É aqui que concluímos a discussão da composição, uma vez que a composição é altamente dependente na habilidade de ser mudada conforme o tempo.

@c cincvdoc_node_number_246
@node Quadros-chave do Compositor
@section Quadros-chave do Compositor
@cindex Quadros-chave do Compositor
@cindex Quadros-chave, Compositor

O traslado de câmera e projetor são representados por dois parâmetros: x e y. Fica difícil ajustá-los com as curvas. O Cinelerra recolve este problema confiando nos quadros-chave automáticos. Com uma trilha de vídeo carregada, mova o ponto de inserção para o início da trilha e habilite o modo de quadros-chaves automáticos.

Mova o projetor levemente na janela de composição para criar um quadro-chave. Então, avance alguns segundos no vídeo. Mova o projetor para uma grande distância para criar outro quadro-chave e enfatizar a movimentação. Isso criará uma segunda caixa de projeção no compositor, com uma linha unindo as duas caixas. A linha que as une é o caminho de locomoção. Se você criar mais quadros-chave, mais caixas serão criadas. Uma vez que todos os quadros-chave desejados sejam criados, desabilite o modo de quadros-chave automáticos.

Agora, quando você mover o slider da janela de composição por aí, a projeção do vídeo se move conforme o tempo. A qualquer ponto entre dois quadros-chave, o caminho de locomoção é vermelho para todo o tempo antes do ponto de inserção e verde para todo o tempo após o ponto de inserção. É debatível se esta é uma função útil, mas te fará feliz saber qual quadro-chave será afetado pela próxima movimentação do projetor.

Clicar-e-arrastar quando quadros-chave automáticos estiverem desligados ajustará o quadro-chave anterior. Se você estiver no meio do caminho entre dois quadros-chave, a primeira caixa do projetor será ajustada enquanto a segunda ficará na mesma posição. Mais do que isso, o vídeo não parecerá se mover em passo com o primeiro quadro-chave. Isso é porque no meio do caminho entre dois quadros-chave, o traslado do projetor é interpolado. Para marcar o segundo quadro-chave, você precisará fazer a mesma coisa só que após o segundo quadro-chave.

Por padrão, o caminho de locomoção é uma linha reta, mas ela pode ser curvada com pontos de controle. @b{arraste-com-o-CTRL} para marcar tanto o ponto de controle de entrada ou saída do quadro-chave anterior. Mais uma vez, saímos do Gimp porque o @key{SHIFT} já está sendo usado para aproximação. Após os pontos de controle de entrada/saída estarem extrapolados do quadro-chave, @b{arrastar-com-o-CTRL} em qualquer lugar do vídeo ajustará o ponto de controle mais próximo. Um ponto de controle pode estar completamente fora da visão e ainda assim ser controlável.

Quando editar o traslado da câmera, o comportamento das caixas de câmera será levemente diferente. A automação de câmera normalmente é usada para faz panorâmicas de fotografias estáticas. A caixa atual de câmera não se move durante um arraste, mas se vários quadros-chave forem marcados, cada caixa de câmera exceto o quadro-chave atual parecem se mover. Isso acontece porque a exibição da câmera mostra cada outra posição de câmera relativa à atual.

A situação torna-se mais intuitiva se você curvar o caminho de locomoção entre dois quadros-chave e ver entre os dois quadros-chave. A divisão entre vermelho e verde, a posição atual entre os quadros-chave, sempre estará centrada enquanto as caixas de câmera se movimentam.

@c cincvdoc_node_number_247
@node Editando quadros-chave
@section Editando quadros-chave
@cindex Editando quadros-chave
@cindex Quadros-chave, editando

@b{IMPORTANTE:} quando você copiar e colar quadros-chave, assegure-se que não haja @b{pontos de ENTRADA ou SAÍDA definidos na linha do tempo}.

Quadros-chave podem ser mudados ou movidos entre trilhas da linha do tempo usando operações similares às de recorte e cola usadas para editar mídia. Apenas os quadros-chave selecionados no menu @b{ver} são afetados por operações de edição de quadros-chave, entretanto.

A operação mais popular de edição de quadro-chave é a réplica de alguma forma de curva de uma trilha a outra, para fazer um par estéreo. O primeiro passo é isolar a gravação da trilha no patchbay @image{manual_images_intl/recordpatch_up} dando um @b{clique-com-o-SHIFT} nele. Então, ou marque pontos de entrada/saída ou destaque a região desejada de quadros-chave. Vá para @b{quadros-chave->copiar quadros-chave} para copiá-los para a área de transferência. Isole a gravação da trilha de destino no patchbay @image{manual_images_intl/recordpatch_up} dando um @b{clique-com-o-SHIFT} nela e vá para @b{quadros-chave->colar quadros-chave} para colar a área de transferência.

Os comandos de edição de mídia são mapeados para os comandos de edição de quadro-chave usando a tecla @key{SHIFT} ao invés de apenas o atalho do teclado.

Isso leva à parte mais complicada na edição de quadros-chave, o quadro-chave padrão. Lembre-se que quando nenhum quadro-chave estiver marcado, ainda há um quadro-chave padrão que armazena todo o parâmetro global para toda a duração. O quadro-chave padrão não é desenhado porque ele sempre existe. E se o valor do quadro-chave padrão for um bom valor, que você queira usar para outros quadros-chave não-padrão? O @b{quadros-chave->copiar quadro-chave padrão} e @b{quadros-chave->colar quadro-chave padrão} permitem a conversão do quadro-chave padrão para um quadro-chave não-padrão.

@b{Quadros-chave->copiar quadro-chave padrão} copia o quadro-chave padrão para a área de transferência, não importando qual região da linha do tempo estiver selecionada. A função @b{quadros-chave->colar quadros-chave} pode ser então usada para colar a área de trabalho como um quadro-chave não-padrão.

Se você copiou um quadro-chave não-padrão, ele pode ser armazenado como o quadro-chave padrão chamando @b{quadros-chave->colar quadro-chave padrão}. Após usar o colar quadro-chave padrão para converter um quadro-chave não-padrão em um quadro-chave padrão, você não verá o valor do quadro-chave padrão refletido até que todos os quadros-chave não-padrão sejam removidos.

Finalmente, há um jeito conveniente de apagar quadros-chave além de selecionar uma região e chamar @b{quadros-chave->limpar quadros-chave}. Simplesmente clique-e-arraste um quadro-chave para antes de seu quadro-chave precedente ou para após o quadro-chave seguinte na trilha. Esta é a única forma pela qual se pode apagar quadros-chave simultaneamente em trilhas agrupadas.


@c cincvdoc_node_number_248
@node Capturando mídia
@chapter Capturando mídia
@cindex Capturando mídia
@cindex Mídia, capturando

@menu
* Capturando usando Cinelerra::
* Capturando usando dvgrab::
@end menu

@c cincvdoc_node_number_249
@node Capturando usando Cinelerra
@section Capturando usando Cinelerra
@cindex Capturando usando Cinelerra

@menu
* Funções de gravação do Cinelerra::
* Gravação em grupo::
* Editando informação de tuner::
@end menu

@c cincvdoc_node_number_250
@node Funções de gravação do Cinelerra
@subsection Funções de gravação do Cinelerra
@cindex Funções de gravação do Cinelerra

Idealmente, toda mídia seria armazenada em discos rígidos, CD-ROM, flash ou DVD e carregá-la no Cinelerra seria uma questão de carregar um arquivo. Na realidade, muito poucas fontes de mídia podem ser acessadas como um sistema de arquivos mas, ao invés disso, dependem de mecanismos de transporte de fita e mecanismos de entrada/saída para transferir a informação para o computador. Esses tipos de mídia são importados para o Cinelerra através da caixa de diálogo de Gravação.

O primeiro passo em uma gravação é configurar o dispositivo de entrada. Em @b{Configurações->preferências} há um número de parâmetros de gravação descritos na configuração de @xref{Gravação}. Estes parâmetros se aplicam à gravação não importando quais sejam as configurações do projeto, já que os parâmetros de gravação normalmente se relacionam à capacidade máxima do hardware de gravação, enquanto as configurações de projeto variam.

Vá para @b{Arquivo->gravação} para gravar a partir de uma fonte entrada/saída. Isso requerirá um formato de saída muito parecido ao exigido pela função de render. Uma vez que isso esteja feito, a janela de gravação e o monitor de gravação aparecerão.

A janela de gravação possui diferentes seções. Enquanto vários parâmetros mudam dependendo de se o arquivo possui áudio ou vídeo, algumas seções serão sempre as mesmas.

@itemize @bullet
@item A área de formato de saída descreve o formato do arquivo de saída e a posição atual dentro dele.
@item A área de edição de grupo permite que você mude os parâmetros no grupo atual.
@item Os controles de transporte iniciam e páram a gravação de modos diferentes.
@item A lista de grupo exibe todos os grupos definidos.
@item A área de confirmação permite que você determine como os arquivos de saída são importados para dentro da Linha do Tempo e sai.
@end itemize

@center @image{manual_images_en/recording,140mm}
@center @b{Áreas de janela de gravação}

A gravação no Cinelerra é organizada em torno de grupos. Um grupo essencialmente define um arquivo de saída distinto para a gravação. Por agora, você pode ignorar completamente o conceito de grupo ("batch") e gravar simplesmente apertando o botão de gravação @image{manual_images_intl/record}.

O botão de gravação abre o arquivo atual de saída caso este não esteja aberto e escreve a informação capturada nele. Use o botão de parar ("stop") para parar a gravação. A gravação pode ser continuada com o botão de gravação sem apagar o arquivo neste ponto. No caso de um arquivo de vídeo, existe um botão de gravação de um quadro único @image{manual_images_intl/singleframe}, que captura apenas um quadro.

Quando mídia suficiente estiver gravada, escolha um método de inserção do menu @b{Estratégia de Inserção} e aperte @b{fechar}.

@c cincvdoc_node_number_251
@node Gravação em grupo
@subsection Gravação em grupo
@cindex Gravação em grupo

Agora chegamos ao conceito de grupos ("batches"). Grupos tentam fazer o mecanismo entrada/saída parecer mais com um sistema de arquivos. Grupos são tradicionalmente usados para dividir a fita em diferentes programas e salvar os diferentes programas como arquivos diferentes ao invés de gravar direto uma fita inteira. Devido ao alto custo de desenvolvimento de mecanismos de controle preciso de quadros, o único uso dos grupos atualmente é gravar diferente programas durante diferentes momentos do dia. Isso ainda é útil para gravar programas de TV ou minutar períodos de vídeos conforme qualquer um que não pode bancar aplicações apropriadas sabe.

A janela de gravação suporta uma lista de grupos e dois modos de gravação: gravação interativa e em grupo. Gravação interativa acontece quando o botão de gravar é pressionado. A gravação interativa se inicia imediatamente e usa o grupo atual para determinar tudo, exceto o tempo de início. Por padrão, o grupo atual está configurado para se comportar como uma fita.

A gravação em grupo ocorre quando o botão @b{início} é pressionado. Na gravação em grupo, o @b{tempo de início} é o tempo em que o grupo começa a ser gravado.

Primeiro, você vai querer criar alguns grupos. Cada grupo possui certos parâmetros e métodos de ajuste.

@itemize @bullet

@item @b{Ligado} @*
Determina se o grupo será incluído nas operações de gravação em grupo. Clique na fileira de lista abaixo de @b{On} para habilitar ou desabilitar grupos.

@item @b{Caminho} @*
É o arquivo onde o grupo será gravado. O nome do arquico especificado na caixa de diálogo de gravação é o nome do primeiro grupo, para simplificar a gravação interativa, mas o nome de arquivo pode ser mudado na janela de gravação para qualquer grupo na área @b{editar grupo}.

@item @b{Novidades} @*
Mostra se o arquivo existe ou não. Este é um atributo muito importante, já que não há um diálogo confirmando se o arquivo existe. Na primeira vez que você pressionar 'gravar', o arquivo é aberto. Se o arquivo existe, neste momento é apagado. 'News' diz @b{Arquivo existe} caso o arquivo exista e @b{OK} caso não exista. Cada vez que você continue a gravação no mesmo grupo, o 'news' deve dizer @b{Abrir}, indicando que o arquivo já está aberto e não será apagado da próxima vez que o botão de gravar for apertado. @*
Se você sair do grupo atual após a gravação, o arquivo é fechado. Da próxima vez que você entrar neste grupo, o arquivo será apagado.

@item @b{Tempo de início} @*
É a marcação de 24 horas do dia em que o grupo começará a gravar caso esteja no modo de grupo. O tempo de início pode se tornar um tempo de fita e número de carrete caso o controle de deck esteja implementado, mas por agora ele se refere ao tempo do dia.

@item @b{Duração} @*
Esta é a duração do grupo. Só possui significado se o @b{Modo} do grupo é @b{Com contador}. Uma vez que a duração da gravação alcance a @b{duração}, a gravação pára, seja no modo interativo, seja no modo de grupo.

@item @b{Fonte} @*
Possui significado apenas quando o hardware de captura possui múltiplas fontes. Normalmente a fonte é um canal 'tuner' ou entrada ("input"). Quando o grupo atual acaba e o próximo grupo começa a gravar, a fonte é mudada para o que estiver marcado para o próximo grupo. Desta forma, várias estações de TV podem ser gravados em diferentes momentos.
@end itemize

A janela de gravação possui uma noção do @b{grupo atual}. O grupo atual não é o mesmo que o grupo que estiver em destaque na lista de grupos. O texto do grupo atual fica colorido em vermelho na lista de grupos. O grupo em destaque é apenas exibido na seção de edição de grupos para edição.

Ao colorir o grupo atual de vermelho, qualquer grupo pode ser editado ao se deixá-lo em destaque, sem mudar o grupo a ser gravado.

Todas as operações de gravação acontecem no grupo atual. Se há vários grupos, deixe em destaque o grupo desejado e aperte @b{ativar} para torná-lo o grupo atual. Se o botão @b{início} for pressionado, o grupo atual pisca para indicar que está esperando pelo tempo de início no modo de grupo. Se o botão de @b{gravação} for pressionado, o grupo atual é gravado imediatamente no modo interativo.

Nos modos de grupo e interativos, quando o grupo atual termina de gravar, o próximo grupo é ativado e performado. Todas as gravações futuras serão feitas em modo de grupo. Quando o primeiro grupo termina, o próximo pisca até que seu horário de início chegue.

Interrompa tanto o grupo quanto a operação interativa apertando o botão de parar ("stop").

Finalmente, há o botão @image{manual_images_intl/rewind} rebobinar. Tanto para gravações em grupo ou interativas, o botão de rebobinar faz o grupo atual fechar seu arquivo respectivo. A próxima operação de gravação no grupo atual apaga o arquivo.

@c cincvdoc_node_number_252
@node Editando informação de tuner
@subsection Editando informação de tuner
@cindex Editando informação de tuner
@cindex Tuner, editando informação

Às vezes no processo de gravação e no processo de configuração, você precisará definir e selecionar os canais de tuner para tanto gravar quanto para reproduzir para algum lugar. No caso dos drivers de gravação Video4Linux e Buz, canais de tuner definem a fonte. Quando o driver Buz também é usado para reprodução, os canais de tuner definem o destino.

Para definir os canais de tuner, pressione o botão @image{manual_images_intl/channel} canal. Isso traz a janela de edição de canais. Nesta janela, você pode adicionar, editar e escolher canais. Para alguns drivers de vídeo, você também pode ajustar a qualidade da imagem.

A operação @b{adicionar} traz uma caixa de edição de canal. O título do canal aparece na lista de canais. A fonte do canal é a entrada na tabela de freqüência física do tuner correspondente ao título.

Um bom ajuste no diálogo de edição de canal ajusta a freqüência física levemente se o driver suporta este tipo de coisa. A tabela de normalização ("norm") e freqüência juntas definem qual tabela de freqüência é selecionada para definir as fontes. Se o dispositivo suporta múltiplas entradas, o menu de entradas as seleciona.

Para escolher os canais, deixe em destaque o canal na lista e pressione @b{mover para cima} ou @b{mover para baixo} para movê-lo.

Uma vez que os canais sejam definidos, o item @b{fonte} na janela de gravação pode ser usado para selecionar canais para gravação. A mesma função de seleção de canal também existe na janela de monitoramento de gravação. Saiba que as seleções de canal na janela de monitoramento de gravação e na janela de gravação são armazenados no grupo atual.

Para alguns drivers, uma opção para @b{Trocar campos} pode estar visível. Estes drivers não captam a ordem dos campos direito todas as vezes sem intervenção humana. Use este campo para fazer com que as linhas pares e ímpares sejam gravadas na ordem correta.

@c cincvdoc_node_number_253
@node Capturando usando dvgrab
@section Capturando usando dvgrab
@cindex Capturando usando dvgrab

dvgrab é uma ferramenta de linha de comando ótima e simples de usar para capturar vídeos a partir de uma câmera DV. Quando evocado, automaticamente colocará sua câmera em modo de reprodução ("play") e começar a armazenar os vídeos em seu disco rígido. Os arquivos de vídeo serão etiquetados sequencialmente, como @file{001.avi}, @file{002.avi} e assim por diante.

Para instalar o dvgrab, use o mecanismo de instalação de sua distribuição preferida (apt, rpm, deb, etc) ou dê uma olhada na página da internet do dvgrab.

Capturando vídeo em quatro passos fáceis:
@enumerate 1
@item Crie uma pasta onde você quer que seus vídeos capturados sejam armazenados
@item @command{cd} para esta pasta
@item Digite: @command{dvgrab --buffers 500} e @kbd{RETURN}
@item Pressione @kbd{CTRL-C} para parar de capturar o vídeo
@end enumerate

A opção @option{--autosplit} é bastante útil. Ela dividirá as cenas de acordo com o código de tempo. Entretanto, isso só funciona quando capturando a partir de uma câmera DV. Ele não funcionará quando estiver capturando a partir de um conversor analógico/digital como o Canopus ADVC110.

Leia o manual do dvgrab para obter mais informações sobre as características do programa.

@c cincvdoc_node_number_254
@node Renderizando arquivos
@chapter Renderizando arquivos
@cindex Renderizando arquivos
@cindex Arquivos, renderizando

Renderizar significa pegar uma seção da linha do tempo, com todas as escolhas de edição, efeitos e composição e armazená-los em um arquivo puro de vídeo. Você pode então apagar todos os arquivos fonte, reproduzir o arquivo renderizado em um reprodutor de vídeos ou trazê-lo de volta ao Cinelerra para mais edições. É muito difícil retocar quaisquer decisões de edição no arquivo puro de vídeo, entretando, então mantenha os arquivos fonte originais e o arquivo XML por vários dias após tê-los renderizado.

Todas as operações de render são baseadas numa região de linha do tempo a ser renderizada. Você precisa definir esta região na linha do tempo. A seção de navegação descreve métodos para se definir regiões. @xref{Barra de tempo}. As funções de renderização definem a região baseadas em uma série de regras. Quando uma região está em destaque ou pontos de entrada/saída estão marcados, a região afetada é renderizada. Quando nenhuma região estiver em destaque, tudo após o ponto de inserção será renderizado. Ao simplesmente posicionar o ponto de inserção ao início de uma trilha e desmarcando todos os pontos de entrada/saída, toda a trilha é renderizada.

@menu
* Renderização de um arquivo único::      	Renderizando um arquivo único
* Renderização de arquivos separados::
* Estratégia de inserção de arquivos renderizados::
* Renderização em grupo::            		Renderizando vários arquivos
* A fazenda de renderização::            	Renderizando usando vários computadores
* Renderização por linha de comando::     	Renderizando a partir da linha de comando, sem interface gráfica
* Renderizando vídeos para a internet::
* Tabela de compatibilidade do Quicktime para GNU/Linux::
* Fazendo um DVD::
* Usando a renderização de fundo::
@end menu

@c cincvdoc_node_number_255
@node Renderização de um arquivo único
@section Renderização de um arquivo único
@cindex Renderização de um arquivo único

O jeito mais rápido de fazer com que a mídia vá para o disco é usar a função de renderização de um arquivo único.

Vá para @b{Arquivo->renderizar} ou pressione @kbd{SHIFT-R} para revelar a caixa de diálogo de render. Selecione o íncone de lupa @image{manual_images_intl/magnify,7mm} para revelar uma caixa de diálogo de seleção de arquivo. Isso determina o nome de arquivo a ser escrito pela renderização e os parâmetros de codificação.

@center @image{manual_images_intl/render_window,80mm}
@center @b{A janela de renderização}

Na caixa de diálogo de render, selecione um formato do menu @b{Formato de Arquivo}. O formato do arquivo determina se você pode renderizar áudio ou vídeo ou ambos. Selecione a opção @b{Renderizar trilhas de áudio} para gerar trilhas de áudio e @b{Renderizar trilhas de vídeo} para gerar trilhas de vídeo.

Selecione o ícone de ferramenta @image{manual_images_intl/wrench,4.33mm} perto a cada opção para configurar os parâmetros de compressão. Se o formato de arquivo não pode armazenar áudio ou vídeo, os parâmetros de compressão estarão em branco. Se @b{Renderizar trilhas de áudio} ou @b{Renderizar trilhas de vídeo} for selecionado e o formato de arquivo não os suporta, tentar fazer a renderização gerará uma imagem de erro.

@c cincvdoc_node_number_256
@node Renderização de arquivos separados
@section Renderização de arquivos separados
@cindex Renderização de arquivos separados

A opção @b{Criar novo arquivo a cada marcador} faz com que um novo arquivo seja criado onde cada marcador na linha do tempo for encontrado. Isso é útil para dividir gravações longas de áudio em trilhas individuais. Quando se usa a fazenda de renderização, @b{Criar novo arquivo a cada marcador} faz com que um trabalho de fazenda de renderização seja criado a cada marcador ao invés de usar o algoritmo interno de carregar balanceamento para espaçar trabalhos.

Quando @b{Criar novo arquivo a cada marcador} estiver selecionado, um novo nome de arquivo será criado para cada arquivo de saída. Se o nome de arquivo informado na caixa de diálogo de render possuir números de dois dígitos nele, os números de dois dígitos serão sobrescritos com um número incremental diferente para cada arquivo de saída. Se nenhum número de dois dígitos for informado, o Cinelerra automaticamente concatena um número ao final de dado nome de arquivo para cada arquivo de saída.

No nome de arquivo @file{/hmov/trilha01.wav}, o @samp{01} seria sobrescrito para cada arquivo de saída. O nome de arquivo @file{/hmov/trilha.wav}, entretanto, se tornaria @file{/hmov/trilha.wav001} e assim por diante. A regeneração de nome de arquivo é usada apenas quando o modo de fazenda de renderização estiver ativo ou quando criar novos arquivos para cada marcador estiver ativado.

@c cincvdoc_node_number_257
@node Estratégia de inserção de arquivos renderizados
@section Estratégia de inserção de arquivos renderizados
@cindex Estratégia de inserção de arquivos renderizados

Finalmente, a caixa de diálogo permite que você selecione um modo de inserção. Os modos de inserção são os mesmos dos de carregar arquivos. Neste caso, se você selecionar @b{Não inserir}, o arquivo será escrito no disco sem alterar o projeto atual. Para outras estratégias de inserção, assegure-se de preparar a linha do tempo para ter os arquivos de saída inseridos na posição correta antes da operação de renderização estar terminada. @xref{Editando}. A seção Editando descreve como fazer a saída ser inserida na posição correta.

Deve ser notado que mesmo que você tenha apenas áudio ou apenas vídeo sendo renderizado, uma estratégia de inserção de @b{colar} se comportará como uma operação normal de cola, apagando qualquer região selecionada da linha do tempo e colando apenas a informação que foi renderizada. Se você renderizar apenas áudio e possui algumas trilhas de vídeo armadas, as trilhas de vídeo ficarão truncadas enquanto a saída de áudio será colada nas trilhas de áudio.

@c cincvdoc_node_number_258
@node Renderização em grupo
@section Renderização em grupo
@cindex Renderização em grupo

Se você quer renderizar vários projetos para arquivos de mídia sem ter que ficar usando o diálogo de @b{Renderização} repetidamente, @b{renderização em grupo} é a função a ser usada. Nesta função, você especifica vários arquivos EDL a serem renderizados e as saídas únicas para cada um deles. O Cinelerra então carrega cada arquivo EDL e renderiza-o automaticamente, sem outras intervenções do usuário. Cada arquivo EDL e sua saída a ser renderizada é chamado de um @b{grupo}. Isso permite que uma vasta quantidade de mídia seja processada e jsutifica vastamente o valor de um computador caro.

A primeira coisa a se fazer quando se prepara uma renderização em grupo é definir os projetos a serem renderizados. A renderização em grupo requere um arquivo EDL separado para cada grupo para ser renderizado. Ajuste um projeto e defina a região a ser renderizada ou destacando-a, marcando pontos de entrada/saída nela ou posicionando o ponto de inserção antes dela. Então, salve o projeto como um EDL@. Defina quantos projetos forem precisos desta forma. O renderizador em grupo pega a região ativa do arquivo EDL para ser renderizada.

Com todos os arquivos EDL preparados com regiões ativas, vá para @b{Arquivo->renderização em grupo}. Isso revelará o diálogo da renderização em grupo. A interface para a renderização em grupo é um pouco mais complexa do que para a renderização de arquivos únicos.

Uma lista de grupos deve ser definida antes de se usar a operação de renderização em grupo. A tabela de grupos aparece na base da caixa de diálogo de renderização em grupo e é chamada de @b{grupos para renderizar}. Acima disso estão os parâmetros de configuração para um grupo único.

Marque os parâmetros de @b{caminho de saída}, @b{formato de arquivo}, @b{Áudio}, @b{Vídeo} e @b{Criar novo arquivo a cada marcador} como se fosse para um arquivo único. Esses parâmetros serão aplicados a apenas um grupo. Além dos parâmetros padrões de renderização, você deve selecionar o EDL fonte a ser usado no grupo. Faça isso marcando o @b{caminho EDL}.

Se a lista de @b{grupos para renderizar} estiver vazia e nada estiver em destaque, clique em @b{Novo} para criar um novo grupo. O novo grupo conterá todos os parâmetros que você acabou de configurar.

Pressione o botão @b{Novo} repetidamente para criar mais grupos com os mesmos parâmetros. Destaque qualquer grupo e edite a configuração ao topo da janela de renderização em grupo. O grupo destacado é sempre sincronizado para a informação exibida.

Clique e arraste grupos para mudar a ordem de renderização. Pressione @b{delete} para remover permanentemente o grupo destacado.

Na caixa de lista está uma coluna que habilita ou desabilita o grupo. Desta forma, grupos podem ser pulados sem ser apagados. Clique na coluna @b{Habilitado} na lista para habilitar ou desabilitar um grupo. Caso ela esteja habilitada, o grupo será renderizado. Se estiver em branco, o grupo será pulado.

As outras colunas na lista de grupos são informativas.
@itemize @bullet
@item @b{Saída} O caminho de saída do grupo.
@cindex EDL
@item @b{EDL} O EDL fonte do grupo.
@item @b{Decorrido} A quantidade de tempo levada para renderizar o grupo se a renderização estiver terminada.
@end itemize

Para começar a renderização a partir do primeiro grupo habilitado, pressione @b{Iniciar}.

Uma vez renderizando, a janela principal mostra o progresso do grupo. Uma vez que o grupo termine, a coluna "passado" (elapsed) na lista de grupos é atualizada e o próximo grupo é renderizado até que todos os grupos habilitados tenham terminado. O grupo que estiver sendo renderizado no momento estará sempre destacado em vermelho.

Para parar a renderização antes que os grupos tenham terminado sem fechar a caixa de diálogo de renderização em grupo, pressione @b{Parar}.

Para parar a renderização antes que os grupos tenham acabado e fechar a caixa de diálogo de renderização em grupo, pressione @b{Cancelar}.

Para sair da caixa de diálogo esteja algo sendo renderizado ou não, pressione @b{Cancelar}.

@c cincvdoc_node_number_259
@node A fazenda de renderização
@section A fazenda de renderização
@cindex A fazenda de renderização

Quando a interpolação bicúbica e o HDTV foram primeiro feitos no Cinelerra, o tempo necessário para se produzir uma saída bem simples se tornou intolerável mesmo no Xeon 1.7 GHz duplo mais rápido. O suporte à Fazenda de Renderização mesmo em sua forma mais simples traz o HDTV de volta ao alinhamento com o DV padrão enquanto faz com que o DV padrão fique mais rápido do que em tempo-real.

Embora a interface da fazenda de renderização não seja espetacular, ela é simples o suficiente para ser usada dentro de uma suíte de edição com menos do que uma dúzia de nós sem passar pela mesma quantidade de confusão que você passaria com uma fazenda de várias centenas de nós. A fazenda de renderização é evocada transparentemente para todas as operações de arquivo->renderizar quando estiver habilitada nas preferências.

O Cinelerra divide a região selecionada da linha do tempo em um certo número de trabalhos que então são despachados a nós diferentes dependendo do balanço de carregamento ("load balance"). Os nós processam os trabalhos e escrevem sua saída a arquivos individuais no sistema de arquivos. Os arquivos de saída não são concatenados. É importante para todos os nós ter acesso ao mesmo sistema de arquivos no mesmo ponto de montagem para os blocos de edição.

Se um nó não consegue acessar um bloco de edição de entrada, ele mostrará mensagens de erro em seu console, mas provavelmente não morrerá. Se ele não pode acessar um bloco de edição de saída, isso fará a renderização ser abortada.

Deve ser notado que na caixa de diálogo de renderização, a opção @b{Criar novo arquivo a cada marcador} faz com que um novo trabalho da fazenda de renderização seja criado a cada marcador ao invés de pelo balanceador de carregamento. Se esta opção estiver selecionada quando não existem marcadores, apenas um trabalho será criado.

Uma fazenda de renderização do Cinelerra é organizada em um nó mestre e qualquer número de nós escravos. O nó mestre é o computador onde a interface gráfica está sendo rodada@. Os nós escravos são qualquer outro lugar na rede e são rodados por linha de comando. Execute um nó escravo a partir da linha de comando com @command{cinelerra -d}.

Esta é a configuração mais simples. Digite @command{cinelerra -h} para ver mais opções. O número da porta padrão pode ser sobrescrito informando-se o número da porta após a opção @option{-d}.

Na maioria das vezes, você vai querer trazer a saída renderizada e fazer um ajuste fino de tempo na linha de tempo. Além disso, alguns formatos de arquivo como o MPEG não podem ser copiados diretamente. Devido a isso, os trabalhos são deixados em arquivos individuais.

Você pode carregá-los criando uma nova trilha e especificar @b{concatenar às trilhas existentes} na caixa de diálogo de carregar arquivos. Arquivos que suportem cópia direta podem ser concatenados em um arquivo único renderizando-se no mesmo formato de arquivo com a fazenda de renderização desabilitada. Também para se conseguir cópia direta, as dimensões da trilha, dimensões de saída e as dimensões dos blocos de edição ("asset") devem ser iguais.

Arquivos MPEG ou arquivos que não suportem cópia direta têm que ser concatenados com a utilização da linha de comando. Os arquivos MPEG podem ser concatenados usando o @b{cat}.

A configuração da fazenda de renderização é descrita no capítulo de configuração @xref{Fazenda de renderização}. Os nós escravos tradicionalmente lêem e escrevem informação em um sistema de arquivos comum por sobre uma rede, então não precisam de discos rígidos.

Idealmente, todos os nós na fazenda de renderização possuem uma performance de CPU similar. O carregamento no Cinelerra faz um balanceamento em uma base de chegou primeiro é servido primeiro. Se o último segmento for despachado para o nó mais lento, todos os nós mais rápidos podem acabar esperando pelo nó mais lento terminar enquanto eles mesmos poderiam ter feito a renderização mais rápido.

@c cincvdoc_node_number_260
@node Renderização por linha de comando
@section Renderização por linha de comando
@cindex Renderização por linha de comando
@cindex Renderização, linha de comando

A opção de renderização por linha de comando consiste em uma forma de carregar a configuração atual de trabalhos de renderização em grupo e processá-los sem interface gráfica. Isso é útil se você estiver planejando matar o X repetidamente ou se quiser fazer a renderização do outro lado de uma rede de banda estreita. Você pode ter acesso a um super computador na Índia, mas ainda estar preso no Brasil, exilado por assim dizer. Uma interface de linha de comando é ideal para isso.

Para fazer a renderização a partir da linha de comando, primeiro rode o Cinelerra no modo gráfico. Vá para @b{arquivo->renderização em grupo}. Crie os grupos que você pretende renderizar na janela de grupos e feche a janela. Isso salvará os grupos em um arquivo. Configure os atributos desejados de fazenda de renderização em @b{configurações->preferências} e saia do Cinelerra. Essas configurações serão usadas na próxima vez que a renderização por linha de comando for usada.

Na linha de comando, rode: @command{cinelerra -r} para processar os trabalhos de grupo atuais sem uma interface gráfica. Configurar todos os parâmetros para esta operação é difícil. É por isso que a linha de comando aborta se qualquer arquivos de saída já existirem.

Outros parâmetros existem para especificar arquivos alternativos para as preferências e para os grupos. Tentar usar qualquer coisa que não os padrões é bem difícil, então isso ainda não foi testado.

@c cincvdoc_node_number_262
@node Renderizando vídeos para a internet
@section Renderizando vídeos para a internet
@cindex Renderizando vídeos para a internet

@menu
* Codificando um vídeo em formato MPEG4 para a internet::
* Codificando um vídeo em formato FLV para a internet::
@end menu

Se você quer codificar um vídeo para colocá-lo na internet, recomendamos renderizá-lo como um arquivo Quicktime4linux, e então codificar aquele arquivo em MPEG4 de formatos FLV. O arquivo Quicktime4linux renderizado do Cinelerra deve ter as seguintes propriedades:

@itemize @bullet
@item Opção de áudio: Two Complements 16bits (Pcm)
@item Opção de vídeo: DV
@end itemize

@c cincvdoc_node_number_329
@node Codificando um vídeo em formato MPEG4 para a internet
@subsection Codificando um vídeo em formato MPEG4 para a internet
@cindex Codificando um vídeo em formato MPEG4 para a internet

Para obter a melhor qualidade, você deve codificar seu arquivo Quicktime4linux com o MEncoder em duas passagens.

@b{Primeira passagem:}
@verbatim
mencoder entrada.mov -ovc xvid -xvidencopts bitrate=600:pass=1 -vf scale=320:240 -oac mp3lame -lameopts abr:br=64 -o saída.avi
@end verbatim
@b{Segunda passagem:}
@verbatim
mencoder entrada.mov -ovc xvid -xvidencopts bitrate=600:pass=2 -vf scale=320:240 -oac mp3lame -lameopts abr:br=64 -o saída.avi
@end verbatim
Não esqueça de mudar o tamanho de saída do vídeo, marcado com a opção @option{-vf scale=}.@*

Aqui estão algumas outras linhas de comando. Elas dão saída a arquivos de vídeo cujo tamanho é de mais ou menos 13 Mb para cada 3 minutos.@*
@b{Primeira passagem:}
@verbatim
mencoder -oac pcm -sws 2 -vf scale=${largura}:${altura},hqdn3d=2:1:2 \
-ovc lavc -lavcopts vcodec=mpeg4:vbitrate=${taxa_de_bits_do_video}:vlelim=-4:\
vcelim=7:lumi_mask=0.05:dark_mask=0.01:scplx_mask=0.3:naq:v4mv:mbd=2:\
trell:cmp=3:subcmp=3:mbcmp=3:aspect=4/3:sc_threshold=1000000000:\
vmax_b_frames=2:vb_strategy=1:dia=3:predia=3:cbp:mv0:preme=2:\
last_pred=3:vpass=1:cgop -ofps 25 -of avi movie.mov -o /dev/null\
-ffourcc DIVX
@end verbatim
@b{Segunda passagem:}
@verbatim
mencoder -srate 32000 -oac mp3lame -lameopts cbr:br=${taxa_de_bits_de_áudio}:\
aq=0 -sws 2 -vf scale=${largura}:${altura},hqdn3d=2:1:2 -ovc lavc\
-lavcopts vcodec=mpeg4:vbitrate=${taxa_de_bits_do_vídeo}:vlelim=-4:vcelim=7:\
lumi_mask=0.05:dark_mask=0.01:scplx_mask=0.3:naq:v4mv:mbd=2:trell:\
cmp=3:subcmp=3:mbcmp=3:aspect=4/3:sc_threshold=1000000000:\
vmax_b_frames=2:dia=3:predia=3:cbp:mv0:preme=2:last_pred=3:vpass=3:\
cgop -ofps 25 -of avi movie.mov -o movie.avi -ffourcc DIVX
@end verbatim

Você provavelmente vai ter que adaptar esses comandos se seu material tiver muito ruído; dê uma olhada nos filtros de pré-processamento do MEncoder. Os parâmetros *_mask são realmente importantes quando se codifica a uma taxa de bits baixa.@*

Se você quer que seu arquivo de vídeo seja exibido devidamente em um reprodutor de mídia conhecido, que rode em Windows, você deve saber que:
@itemize @bullet
@item a informação sobre razão de aspecto contida no cabeçalho do AVI não será levada em consideração por aquele reprodutor. É por isso que você deve escalar a imagem para a razão de aspecto correta. Largura e altura devem ser múltiplas de 16. Estas são as resoluções recomendadas para material 4/3 PAL: 384:288, 448:336, 512:384 ou 704:528.
@item o reprodutor de mídia rodando no Windows vai perder a sincronia A/V caso um áudio com taxa de áudio VBR seja usado ao invés de CBR@.
@item o parâmetro @option{-ffourcc} é necessário para que o codec de vídeo seja reconhecido como Divx.
@end itemize

@c cincvdoc_node_number_330
@node Codificando um vídeo em formato FLV para a internet
@subsection Codificando um vídeo em formato FLV para a internet
@cindex Codificando um vídeo em formato FLV para a internet

O peso de arquivos FLV (FLash Video) é muito pequeno e a única coisa necessária para reproduzi-los é um navegador de internet com o plugin flash versão 7 ou posterior instalada. Este formato é realmente útil quando alguém quer compartilhar um vídeo com uma audiência maior pela internet.

@b{Primeira passagem:}
@verbatim
ffmpeg -i vídeo.mov -b 430 -s 320x240 -aspect 4:3 -pass 1 -ar 22050 vídeo.flv
@end verbatim
@b{Segunda passagem:}
@verbatim
ffmpeg -i vídeo.mov -b 430 -s 320x240 -aspect 4:3 -pass 2 -ar 22050 vídeo.flv
@end verbatim

Atente à extensão do arquivo de saída. O FFMPEG a usa para determinar o formato de saída. A freqüência do áudio deve ser 22050 e o parâmetro @option{-ar} deve ser usado para que o vídeo seja propriamente codificado. O FFMPEG não escreve informação metadata no arquivo flv. A duração tem que ser escrita na informação metadata para que alguns reprodutores de flash exibam uma barra de progressão. O FLVTool2 (@uref{http://www.inlet-media.de/flvtool2}) pode ser usado para inserir essa informação:
@verbatim
cat arquivo_de_entrada.flv | flvtool2 -U stdin arquivo_de_saída.flv
@end verbatim

@c cincvdoc_node_number_328
@node Tabela de compatibilidade do Quicktime para GNU/Linux
@section Tabela de compatibilidade do Quicktime para GNU/Linux
@cindex Tabela de compatibilidade do Quicktime para GNU/Linux

Scott Frase escreveu uma tabela de compatibilidade do Quicktime for Linux. Ela contém uma lista exaustiva de todos os esquemas de compressão do Quicktime disponíveis e sua compatibilidade com o Cinelerra, MPlayer e alguns outros reprodutores de mídia. Este documento possui duas seções principais, uma baseada em um projeto formatado para uma resolução HDV e outra para um projeto formatado para uma resolução DV.

Esta tabela está disponível aqui: @*
@uref{http://content.serveftp.net/video/qtcompatibility.ods}

Algumas observações interessantes:
@itemize @minus
@item O MPlayer funciona melhor com vídeos menores, de resolução DV
@item A compatibilidade do Cinelerra com arquivos renderizados a partir de um projeto DV não é muito diferente de sua compatibilidade com arquivos renderizados a partir de um projeto HDV.
@item Está incluída uma tabela de comparação de compatibilidade de DV/HDV MPlayer/Cinelerra
@end itemize

@c cincvdoc_node_number_263
@node Fazendo um DVD
@section Fazendo um DVD
@cindex Fazendo um DVD
@cindex DVD, fazendo um

@menu
* Renderizando para mpeg2::
* Fazendo um menu de DVD::
* Autorando um DVD::
* Queimando um DVD::
@end menu

@c cincvdoc_node_number_264
@node Renderizando para mpeg2
@subsection Renderizando para mpeg2
@cindex Renderizando para mpeg2
@cindex Mpeg2, renderizando para

Aqui está um método para exportar vídeo em MPEG2 e fazer um capítulo único de DVD@. Este método permite que você configure precisamente a opção de codificação que você quer e produz um arquivo MPEG2 que é 100% compatível com todos os aparelhos de DVD.

O programa mplex do @b{mjpegtools} deve estar instalado. O pacote mjpegtools é construído na distribuição do hvirtual e a função mplex pode ser extraída dali.

Primeiro, assegure-se de que você definiu propriamente o formato do seu projeto do Cinelerra antes de renderizar seu vídeo (menu @b{Configurações->Formato}). PAL é 720x576 a 25 quadros por segundo; NTSC é 720x480 a 29.97 quadros por segundo.

@enumerate 1
@item Crie um script @file{~/cine_render.sh}
@item Copie no @file{arquivo ~/cine_render.sh} as seguintes linhas: @*
@command{#/bin/bash} @*
@command{mpeg2enc -v 0 -K tmpgenc -r 16 -4 1 -2 1 -D 10 -E 10 -g 15 -G 15 -q 6 -b 8600 -f 8 -o $1}
@item Ponha as premissões de execução neste arquivo:
@command{chmod 777 ~/cine_render.sh}
@item Abra o Cinelerra e selecione a parte do vídeo que você quer renderizar com os pontos de [ e ]
@item Pressione @kbd{SHIFT-R}
@item Selecione o formato @b{YUV4MPEG Stream}
@item De-selecione @b{Renderizar trilhas de áudio} e selecione @b{Renderizar trilhas de vídeo}
@item Clique no ícone da ferramenta
@item Na nova janela que se abriu, indique o nome do arquivo @file{m2v} que você quer criar. Este arquivo conterá apenas o vídeo.
@item Clique em @b{Usar pipe} e escreva este comando:
@command{/home/<seu usuário>/cine_render.sh %}
@item Clique em OK para fechar a segunda janela e em OK de novo para renderizar seu arquivo @file{m2v}
@item Quando o arquivo m2v for renderizado, abra a janela de renderização de novo e renderize um arquivo AC3 a 224kbits
@item Finalmente, combine o vídeo e o áudio com este comando:
@command{mplex -f 8 seu_arquivo_de_video.m2v seu_arquivo_de_audio.ac3 -o arquivo_de_video_e_audio.mpeg}
@end enumerate

Você pode modificar os parâmetros do mpeg2enc se quiser. Olhe a página do manual do mpeg2enc. Alguns detalhes sobre as configurações:
@itemize
@item @option{-b 8600} : esta é a taxa de bits máxima de seu arquivo @file{m2v} (ela não inclui a taxa de bits de áudio). Recomendamos que você não aumente este valor ou você pode ter erros quando estiver multiplexando o vídeo e o áudio.
@item @option{-q 6} : esta é a configuração do quantizador. Se você reduzi-la (não desça abaixo de 3), a qualidade aumentará. Mas a taxa de bits aumentará. É recomendável manter a taxa média de bits conseguida (a que for exibida quando se estiver multiplexando ops arquivos de áudio de vídeo) por volta de 10% abaixo do que a taxa de bits definida com a configuração do @option{-b}.
@end itemize

Se seu materia possuir bastante ruído (material de Hi8 analógica, por exemplo), você pode adicionar algumas ferramentas do mjpegtools na linha de comando escrita em @file{~/cine_render.sh}:
@itemize @minus
@item @command{y4mshift} e @command{y4mscaler} podem ser usados para remover as bordas com ruídos à volta do vídeo. Por exemplo, esses comandos adicionados ao início da linha de comando em @file{cine_render.sh} removem as margens pretas à volta do vídeo Hi8: @*
@command{y4mshift -n -2 | yuvscaler -I USE_744x560+12+8 -O DVD -M BICUBIC |}
@item @command{yuvdenoise} e @command{yuvmedianfilter} podem ajudar a remover ruído. Exemplo: @*
@command{yuvdenoise -F | yuvmedianfilter -T 3 |} @*
Depurar é uma tarefa complexa e as opções dadas acima são apenas um exemplo. Por favor, leia o manual do mjpegtools e inscreva-se na lista do programa para obter mais informações.
@end itemize

@c cincvdoc_node_number_265
@node Fazendo um menu de DVD
@subsection Fazendo um menu de DVD
@cindex Fazendo um menu de DVD
@cindex Menu de DVD, fazendo um

Um menu de DVD é composto de:

@itemize @minus
@item um fundo (imagem estática ou vídeo)
@item botões
@item som/música
@end itemize

Você pode construir um meni com uma interface gráfica como o qdvdauthor, dvdstyler, dvdwizard ou tovid. Entretanto, o uso dessas interfaces gráficas não é perfeito no momento, uma vez que estes programas ainda têm erros ou são limitados no momento.

O método que explicamos abaixo é mais complicado do que usar a interface gráfica, entretanto, ele:

@itemize @minus
@item produz um DVD reproduzível em todos os aparelhos
@item não está sujeito a erros
@item te poupará muito tempo já que tudo o que você terá que fazer para autorar um novo DVD é modificar os arquivos de texto
@end itemize

Se você prefere usar uma interface gráfica, recomendamos que você tente o tovid: @*
@uref{http://tovid.wikia.com/wiki/Main_Page}

Aqui estão os passos necessários para criar seu menu de DVD:

@itemize @minus
@item crie um fundo de menu com o cinelerra
@item adicione os botões criando imagens em PNG
@item combine o menu e os botões com o spumux
@end itemize

Nós supomos que você vai querer criar um menu com um fundo animado. Abra o Cinelerra e crie um projeto contendo o que você vai querer como fundo para o seu menu. Você pode adicionar uma música se quiser. Atente para o fato de que este menu vai ser reproduzido em loop.

Para desenhar os botões, você tem duas possibilidades:

@itemize @minus
@item exibi-los no Cinelerra. Desta forma, você poderá fazer botões animados, como um thumbnail de um vídeo para cada parte de seu vídeo.
@item não desenhar os botões no Cinelerra. Você os adicionará mais tarde, a partir das imagens PNG "adicionadas" ao arquivo de menu MPEG2. Este é o método mais simples, mas você não conseguirá exibir botões animados.
@end itemize

Renderize este vídeo para m2v e ac3 usando o método @command{cine_render.sh} explicado acima. Combine o áudio e o vídeo com o mplex como você faria com qualquer vídeo "normal".

Você obterá um arquivo MPEG2 contendo o fundo do menu e alguns botões dispostos em cima dele se você os adicionou no Cinelerra.

Nós temos que usar o spumux para definir cada posição de botão neste arquivo MPEG2. Se você não desenhou os botões no Cinelerra, você poderá colocá-los com o spumux.

O spumux é uma ferramenta em linha de comando que leva 2 argumentos:

@itemize @minus
@item um arquivo XML explicando onde estão os botões
@item o nome do arquivo MPEG2 (aquele que você renderizou para o menu)
@end itemize

Aqui está um arquivo XML de exemplo do spumux:
@verbatim
<subpictures> 
 <stream> 
  <spu start="00:00:00.0" image="botões_normal.png" highlight=
  "botões_em_destaque.png" select="botões_selecionados.png"> 
   <button name="1" x0="94 " y0="234 " x1="253 " y1="278" 
   down="2" right="4" />
   <button name="2" x0="63 " y0="287 " x1="379 " y1="331" up="1"
   down="3" right="5" />
  </spu>
 </stream> 
</subpictures>
@end verbatim

@itemize @bullet
@item @b{image="botões_normal.png"} Esta imagem PNG contém os botões conforme eles devem aparecer quando não estão não estão selecionados ou em destaque.
@item @b{highlight="botões_em_destaque.png"} Esta imagem PNG contém os botões em seu estado destacado.
@item @b{select="botões_selecionados.png"} Esta imagem PNG contém os botões em seu estado selecionado.
@end itemize

Se você já fez os botões no Cinelerra, você tem que especificar imagens PNG vazias (100% transparentes) aqui.

As imagens PNG usadas no spumux devem:

@itemize @minus
@item conter um @b{canal alfa} (por exemplo, suportar transparência)
@item estar em @b{4 cores indexadas}. Você pode facilmente converter uma imagem para 4 cores indexadas usando o Gimp.
@end itemize

Há uma linha por botão. Cada linha contém as coordenadas do botão, um botão possuindo uma forma retangular:

@itemize @minus
@item @b{x0, y0}: canto superior esquerdo
@item @b{x1, y1}: canto inferior direito
@end itemize

Você também tem que configurar para qual botão a navegação se moverá quando os botões para-cima, para-baixo, para-a-esquerda e para-a-direita do controle remoto do DVD forem usados. Aqui está um exemplo:

@verbatim
<button name="3" ...coordinates... up="1" down="5" left="2" right="4" />
@end verbatim

Quando o botão 3 for selecionado, se o botão "para-cima" for pressionado no controle remoto então o botão 1 será destacado. Se o botão "para-a-direita" for pressionado no controle remoto, então o botão 4 será destacado.

Quando você houver terminado de editar seu arquivo XML do spumux, você terá que digitar este comando: @*
@command{spumux menu.xml < menu.mpeg > menu_com_botões.mpeg} @* Isso gerará um @file{menu_com_botões.mpeg}. É um arquivo MPEG2 com botões.

@c cincvdoc_node_number_266
@node Autorando um DVD
@subsection Autorando um DVD
@cindex Autorando um DVD
@cindex DVD, autorando um

Após haver renderizado seus arquivos para MPEG2 e haver preparado um menu com o spumux, você precisa "autorar" o DVD com o dvdauthor.

O dvdauthor usa arquivos de XML para descrever a estrutura do DVD. A sintaxe é rigorosa e deve-se prestar muita atenção à sintaxe do arquivo .xml. O risco é que o DVD possa ser lido em alguns aparelhos, mas não em todos.

Para ajudar você a usar o dvdauthor, vamos mostrar alguns arquivos XML de exmplo.

@verbatim
<dvdauthor dest="/caminho/para/a/pasta/que/conterá/o/dvd">
    <vmgm />
    <titleset>
        <titles>
            <pgc>
                <vob file="/o/arquivo/mpeg.mpeg" />
		<post>
                    jump chapter 1;
                </post>
            </pgc>
        </titles>
    </titleset>
</dvdauthor>
@end verbatim

Este é um arquivo XML bem simples do dvdauthor. Não há menu; o arquivo de vídeo @file{/o/arquivo/mpeg.mpeg} será reproduzido assim que você inserir o DVD no aparelho.

Isso significa que seu vídeo será reproduzido em loop:
@verbatim
		<post>
                    jump chapter 1;
                </post>
@end verbatim

Para autorar o DVD, simplesmente digite o seguinte comando: @*
@command{dvdauthor -x exemplo_simples.xml}

Agora, vamos dar uma olhada em um exemplo mais complexo. Quando o DVD for inserido, um menu será exibido e você poderá escolher entre reproduzir quatro vídeos.

@verbatim
<dvdauthor dest="/caminho/para/a/pasta/que/conterá/o/dvd" jumppad="yes" >
<vmgm>
 <fpc> jump menu 1; </fpc>
  <menus>
   <video format="pal" aspect="4:3" resolution="720x576" />
   <pgc entry="title" >
    <vob file="menu.mpeg" pause="0" />
    <button name="1" > { g3=1; jump titleset 1 menu entry root; } </button>
    <button name="2" > { g3=2; jump titleset 1 menu entry root; } </button>
    <button name="3" > { g3=3; jump titleset 1 menu entry root; } </button>
    <button name="4" > { g3=4; jump titleset 1 menu entry root; } </button>
     <post> { jump cell 1; } </post>
   </pgc>
  </menus>
 </vmgm>
 <titleset>
  <menus>
   <pgc entry="root" >
    <pre> { if ( g3 gt 0 )  {
		if ( g3 eq 1 ) { g3=0; jump title 1  chapter 1; }
		if ( g3 eq 2 ) { g3=0; jump title 1  chapter 3; }
		if ( g3 eq 3 ) { g3=0; jump title 1  chapter 5; }
		if ( g3 eq 4 ) { g3=0; jump title 1  chapter 7; }
		jump vmgm menu entry title;
		}
	} </pre>
    <post> { jump vmgm menu entry title; } </post>
   </pgc>
  </menus>
  <titles>
   <video format="pal" aspect="4:3" resolution="720x576" />
   <pgc pause="0" >
    <vob file="vídeo_1.mpeg" pause="0" />
    <vob file="vídeo_preto.mpg" pause="0" />
    <vob file="vídeo_2.mpeg" pause="0" />
    <vob file="vídeo_preto.mpg" pause="0" />
    <vob file="vídeo_3.mpeg" pause="0" />
    <vob file="vídeo_preto.mpg" pause="0" />
    <vob file="vídeo_4.mpeg" pause="0" />
    <post> { call vmgm menu entry title; } </post>
   </pgc>
  </titles>
 </titleset>
</dvdauthor>
@end verbatim

O arquivo @file{vídeo_preto.mpg} é usado para adicionar uma tela preta de dois segundos entre cada vídeo. Aqui está como criá-lo: @*
@command{convert -size 720x576 xc:black -depth 8 quadro_preto.ppm} @*
@command{dd if=/dev/zero bs=4 count=960000 | toolame -b 128 -s 48 /dev/stdin áudio_vazio.mpa} @*
@command{ppmtoy4m -S 420mpeg2 -n 50 -F 25:1 -r quadro_preto.ppm | mpeg2enc -a 2 -n p -f 8 -o vídeo_preto.mpv} @*
@command{mplex -f 8 -o vídeo_preto.mpg vídeo_preto.mpv áudio_vazio.mpa}

@c cincvdoc_node_number_267
@node Queimando um DVD
@subsection Queimando um DVD
@cindex Queimando um DVD
@cindex DVD, queimando um

Quando você houver terminado de autorar o DVD, você encontrará em uma pasta os seguintes diretórios: @file{AUDIO_TS} e @file{VIDEO_TS}. Para testar seu DVD antes de queimá-lo, entre nesta pasta (cd) e digite: @* @b{xine dvd:`pwd`}

Se seu DVD for reproduzido corretamente em seu computador, é hora de queimá-lo. Quando você estiver na pasta contendo os arquivos @file{AUDIO_TS} e @file{VIDEO_TS}, digite este comando: @*
@command{nice -n -20 growisofs -dvd-compat -speed=2 -Z /dev/dvd -dvd-video -V VIDEO ./ && eject /dev/dvd}

Se você tem um monte de cópias a fazer, você pode fazer um .iso mestre primeiro usando este comando: @*
@command{nice -n -20 mkisofs -dvd-video -V VIDEO -o ../dvd.iso .} @*
Este arquivo @file{../dvd.iso} pode ser queimado usando este comando: @*
@command{nice -n -20 growisofs -dvd-compat -speed=2 -Z /dev/dvd=../dvd.iso && eject /dev/cdrom}

Recomendamos que você não queime o DVD a uma velocidade maior do que 4x. Use um DVD-R de qualidade.

@c cincvdoc_node_number_268
@node Usando a renderização de fundo
@section Usando a renderização de fundo
@cindex Renderização de fundo, usando

A renderização ao fundo permite que efeitos impossivelmente lentos sejam reproduzidos em tempo-real logo após o efeito ser colado na linha do tempo. Ele renderiza continuamente a saída temporária. Quando a fazenda de renderização estiver habilitada, a renderização ao fundo a usa continuamente. Desta forma, um vídeo de qualquer tamanho pode ser visto em tempo-real simplesmente criando-se uma rede rápida o suficiente com nós suficientes.

A renderização ao fundo é habilitada em configurações->preferências->performance. Ela possui uma função interativa: @b{configurações->marcar rederização ao fundo}. Isso marca o ponto onde a renderização ao fundo começa para onde o ponto de entrada estiver. Se algum vídeo existir, uma barra vermelha aparece na barra de tempo mostrando o que foi renderizado ao fundo.

Normalmente é útil inserir um efeito ou uma transição e então selecionar configurações->marcar rederização ao fundo logo antes do efeito para prevê-lo a uma taxa de quadros inteira.

@c cincvdoc_node_number_269
@node Dicas
@chapter Dicas
@cindex Dicas

Nesta seção, você encontrará modos de aplicar o Cinelerra a problemas comuns. Outras seções estão dispostas na ordem das ferramentas e para o que estas ferramentas são usadas. Este seção está disposta na ordem de problemas e quais ferramentas são usadas para solucioná-los.

@menu
* Codificação Dolby Pro Logic::
* Limpeza de material de TV analógica::
* Combatendo o entrelaçamento::
* Fazer um vídeo se parecer a um filme::
* Limpando o enevoado::
* Fazendo um ringtone::
* Esticamento temporal de áudio::
* Capturas de telas de vídeo::
* Melhorando a performance::             	Fazendo o Cinelerra rodar melhor no GNU/Linux.
* Traduzindo o Cinelerra::             		Como traduzir o Cinelerra para línguas diferentes.
* Fazendo panorâmicas e aproximações em imagens estáticas::
* Editando HDV 1080i usando arquivos proxy::
* Adicionando legendas::
@end menu

@c cincvdoc_node_number_270
@node Codificação Dolby Pro Logic
@section Codificação Dolby Pro Logic
@cindex Codificação Dolby Pro Logic

Dolby pro logic é uma forma fácil de dar saída a um áudio de 6 canais a partir de uma placa de som de 2 canais com resultados degradados mas úteis. Uma codificação rudimentar Dolby pro logic pode ser alcançada com o uso inteligente dos efeitos.

Crie 2 trilhas de áudio com o mesmo áudio. Aplique @b{Inverter Áudio} a uma trilha. O sinal sai dos falantes de trás.

Crie uma trilha de áudio única com áudio em mono de uma fonte diferente. Centralize-a com o controle de @b{panorâmica}. O sinal sai do falante central.

Crie outras trilhas com diferentes sinais e faça o pan com elas para a esquerda ou para a direira para enviar os sinais para os falantes de frente à esquerda ou à direita.

Finalmente, se uma cópia do sinal nos falantes de trás for desejada em qualquer falante único da frente, o sinal nos falantes de trás deve ser atrasado em pelo menos 0.05 segundos e uma nova trilha única deve ser criada. Faça o pan na nova trilha para orientar o sinal para os falantes da frente.

Se o mesmo sinal for desejado em todos os falantes exceto o do meio, atrase os falantes de trás em 0.5 segundos e atrase ou ou falante da frente-à-esquerda ou da frente-à-direita por 0.2 segundos.

Se você quiser ouvir algo do subwoofer, crie uma nova trilha, selecione uma abrangência, jogue um efeito de sintetizador e configure a freqüência para abaixo de 60 Hz. O subwoofer simplesmente toca qualquer coisa abaixo de por volta de 60Hz.

Outros truques que você pode fazer para separar os falantes são a equalização paramétrica para tocar apenas as abrangências selecionadas de freqüências por falantes diferentes e filtragem de passagens baixas ("lowpass filtering") para reproduzir sinais pelo subwoofer.

@c cincvdoc_node_number_271
@node Limpeza de material de TV analógica
@section Limpeza de material de TV analógica
@cindex Limpeza de material de TV analógica
@cindex TV, limpeza analógica

A não ser que você viva em uma nação rica como a China ou seja um terrorista, você provavelmente grava televisão analógica mais do que grava televisão digital. A qualidade da imagem na tv analógica é horrível, mas você pode fazer coisas no Cinelerra para fazê-la parecer um pouco mais com o que se parecia no estúdio.

Primeiro, quando estiver capturando o vídeo, capture-o na melhor resolução possível. Para europeus, é 720x576 e para brasileiros é 720x480. Não se dê ao trabalho de ajustar o brilho e o contraste no monitor de gravação, embora fazer um "maxing out" na cor pode ser útil. Capture-o usando MJPEG ou Component Video não-comprimido se possível. Caso estes demandem recursos demais, capture-o usando JPEG@. RGB deve ser o último recurso.

Agora, na linha do tempo use @b{Configurações->Formato} para configurar para um espaçamento de cor YUV. Jogue um efeito @b{Reduzir amostragem} no material gravado. Configure-o para
@verbatim
Horizontal:        		2
Deslocamento Horizontal:	0
Vertical:          			2
Deslocamento Vertical:   	0
      vermelho
  x   verde
  x   azul
      alfa
@end verbatim

Use a ferramenta de câmera para mudar a imagem para cima ou para baixo uma linha para remover a maioria da interferência de cor da imagem. Esta é a diferença que estamos buscando:

@center @image{manual_images_en/cleaning1}

Se você possui informação de vazio vertical ("vertical blanking information") ou coisas que mudam constantemente a cada quadro, bloqueie-os com a ferramenta de @b{Máscara}. Isso melhorará as razões de compressão.

Isso é mais ou menos tudo o que você pode fazer sem destruir mais informação do que você normalmente perderia na compressão. As técnicas mais invasivas de limpeza envolvem desentrelaçamento.

@c cincvdoc_node_number_272
@node Combatendo o entrelaçamento
@section Combatendo o entrelaçamento
@cindex Combatendo o entrelaçamento

Entrelaçamento é feito na maioria das fontes de vídeo porque custa muito caro construir câmeras de sondagem progressiva e CRTs de sondagem progressiva. Vários consumidores ficaram desapontados ao gastar cinco meses de salário em uma câmera e descobrir as imagens horríveis distorcidas que ela produz em um monitor de computador.

Sobre as câmeras de sondagem progressiva, esqueça-as. Fatores de preço provavelmente manterão as câmeras progressivas de em algum momento se igualar à resolução espacial de câmeras entrelaçadas. O entrelaçado está aqui para ficar. É por isso que fizeram efeitos de desentrelaçamento no Cinelerra.

Nós não acreditamos que em algum momento tenha existido algum efeito perfeito de desentrelaçamento. Eles ou são irreversíveis ou não funcionam. O Cinelerra corta pelo meio ao prover ferramentas de desentrelaçamento que em alguns momentos são irreversíveis e em alguns momentos não funcionam, mas não são nem uma nem outra.

@itemize @bullet
@item
@cindex Entrelaçamento, duplicação de linhas
@b{Duplicação de linhas}
Este é feito pelo efeito @b{Desentrelaçar} quando configurado para @b{Linhas ímpares} ou @b{Linhas pares}. Quando aplicado a uma trilha, reduz a resolução vertical por 1/2 e resulta em quadros progressivos com "stairstepping". É apenas útil quando seguido de um efeito de escala que reduz a imagem a metade de seu tamanho.

@item
@cindex Entrelaçamento, média de linhas
@b{Média de linhas}
O efeito @b{Desentrelaçar}, quando configurado para @b{Média de linhas pares} ou @b{Média de linhas ímpares} faz exatamente o que a duplicação de linhas faz, exceto que ao invés de fazer cópias diretas das linhas, faz a média das linhas. Isso na verdade é útil para todas as escalas. @* Há uma opção para a média adaptativa da linha que seleciona para quais linhas se deve tirar a média e para quais linhas se deve deixar o entrelaçado baseado na diferença entre as linhas. Não funciona.

@item
@cindex Entrelaçamento, telecine inverso
@b{Telecine Inverso}
Esta é a ferramenta de desentrelaçamento mais efetiva quando o material for de TV NTSC de um filme. @xref{Telecine Inverso}.

@item
@cindex Entrelaçamento, correção à base de tempo
@b{Correção à base de tempo}
As primeiras ferramentas ou destroem o material de forma irreversível ou não funcionam às vezes. A @b{Correção à base de tempo} é a última porque é a ferramenta perfeita de desentrelaçamento. Ela deixa o material intacto. Ela não reduz a resolução, perceptualmente ao menos. Ela não faz com que o movimento pareça um pouco descontinuado.

@item
@cindex Entrelaçamento, quadros para campos
O efeito @b{Quadros para campos} converte cada quadro em dois quadros, então ele deve ser usado em uma linha do tempo na qual a taxa de quadros do projeto é o dobro da taxa de quadros do material gravado. No primeiro quadro, ele põe uma cópia da média de linha das linhas ímpares. Quando reproduzido a uma taxa de quadros inteira, dá a ilusão de um vídeo progressivo sem perda de detalhes. @*
Melhor de tudo, este efeito pode ser revertido com o efeito @b{Campos para quadros}. Este combina dois quadros por material gravado de volta a um quadro entrelaçado original de metade da taxa de quadros. @*
Saiba que o Quadros para Campos dá entrada aos quadros na metade da taxa de quadros do projeto. Efeitos antes de Quadros para Campos processam à taxa reduzida de quadros. @*
Infelizmente, a saída de @b{Quadros para campos} não pode ser comprimida de forma tão eficientemente quanto o original porque introduz uma distorção vertical e uma taxa de quadros super alta. @*
Pode-se fazer um material entrelaçado a 29.97 quadros por segundo se parecer com um filme aplicando-se @b{Quadros para campos} e então reduzindo a taxa de quadros do projeto do material resultante a 59.94 quadros por segundo para 23.97 quadros por segundo. Isso não produz movimento descontínuo e o campo ímpar ocasional dá a ilusão de haver mais detalhe do que haveria se você simplesmente tirasse a média de linhas do original.
@end itemize

@cindex Entrelaçamento, exceções para HDTV
@cindex Entrelaçamento HDTV
@b{Exceções HDTV} @*
HDTV 1920x1080 é codificado de uma forma especial. Se for uma transmissão do HDTV original, um telecine inverso funciona bem. Se for uma retransmissão de uma fonte 720x480, você precisará usar uma base de tempo e um algoritmo de duplicação de linhas para desentrelaçá-lo, @xref{1080 para 480}.

@c cincvdoc_node_number_273
@node Fazer um vídeo se parecer a um filme
@section Fazer um vídeo se parecer a um filme
@cindex Fazer um vídeo se parecer a um filme
@cindex Aparência de filme

O aprimoramento do vídeo está constantemente evoluindo. Ultimamente, a melhor coisa que você pode fazer para câmeras baratas sujas de vídeo é transformar sua saída em 24 quadros por segundo progressivo. Enquanto você ainda não consegue fazer isso, é possível chegar muito próximo pelo dinheiro. Por sinal, este procedimento pode degradar vídeo de alta qualidade tão fácil quanto melhorar vídeos de baixa qualidade. Ele deve ser usado para vídeos de baixa qualidade.

@enumerate 1
@item Configure a taxa de quadros do projeto para duas vezes a taxa de quadros do vídeo.
@item Aplique um efeito de @b{Aguçar}. Configure-o para agudeza: 25, sem entrelaçamento e horizontal apenas.
@item Jogue um efeito de @b{Quadro para campos} na mesma trilha. Marque Média de Fileiras Vazias para ligado e reproduza trechos do vídeo algumas vezes para tentar descobrir qual o campo está primeiro. Se o campo errado estiver primeiro, a movimentação ficará trêmula. Segundo, qualquer edição com a taxa de quadros duplicada pode agora zoar a ordem do arquivo. Ainda estamos tentando achar o meio mais fácil de suportar avisos para problemas de campo, mas por agora você precisa voltar à taxa de quadros normal para fazer edições ou reproduções de teste para saber se os campos estão certos.
@item Renderize apenas o vídeo para o arquivo com a melhor qualidade possível.
@item Importe o vídeo de volta para uma nova trilha. Configure a taxa de quadros do projeto para 24 quadros por segundo. A nova trilha agora deve parecer mais a um filme e as imagens estarão melhores do que na gravação original.
@end enumerate

Todo este procedimento poderia ser implementado em um efeito não-tempo-real, mas o maior problema com ele é que você normalmente vai querer manter a saída baseada em campos e a saída a 24 quadros por segundo para a posteridade. Um efeito não-tempo-real requereria todo esse processamento apenas para a cópia a 24 quadros por segundo. Esta questão ainda está sendo debatida.

@c cincvdoc_node_number_274
@node Limpando o enevoado
@section Limpando o enevoado
@cindex Limpando o enevoado
@cindex Enevoado, limpando
@cindex Efeito Gradiente

Você provavelmente fotografa um monte de enevoados e nunca vê um céu azul. Mesmo se você pudesse pagar para ir brevemente a um lugar onde há céu azul, tomadas de horizonte normalmente poderiam ter mais profundidade. Isso é o que o @b{efeito Gradiente} faz.

Jogue o efeito gradiente nas trilhas enevoadas. Configure os seguintes parâmetros:
@itemize @minus
@item Ângulo: 0
@item Raio Interno: 0
@item Raio Externo: 40
@item Cor interna: azul 100% alfa
@item Cor externa: azul 0% alfa
@end itemize

É importante marcar a cor alfa 0% para azul mesmo que ela seja 0% alfa. A cor do alfa externo ainda é interpolada com a cor interna. Isso é geralmente uma configuração aplicável para o gradiente. Algumas cenas podem funcionar melhor com laranja ou marrom para uma sensação de entardecer.

@c cincvdoc_node_number_275
@node Fazendo um ringtone
@section Fazendo um ringtone
@cindex Ringtone, fazendo um

Este é o jeito como fizemos os para o Motorola V180 e provavelmente vai funcionar com qualquer telefone novo. Vá para @b{Arquivo->Carregar arquivos...} e carregue um arquivo de som com a Estratégia de Inserção: @b{Substituir projeto atual}. Vá para @b{Configurações->Formato}, mude os @b{Canais} para 1 e @b{Taxa de amostragem} para 16000 ou 22050.

Ou destaque uma região da linha do tempo ou marque pontos de entrada/saída para usar para o ringtone. Para melhorar a qualidade do áudio no telefone celular, você vai precisar da amplitude máxima na maioria das partes do som possível. Clique com o botão direito do mouse na trilha de áudio 1 e selecione @b{Adicionar efeito..}. Destaque o efeito de @b{Compressor} e aperte @b{Adicionar} na janela que aparecerá.

Assegure-se que o ponto de inserção ou área destacada esteja na região com o efeito de Compressor. Clique com o botão direito do mouse na trilha de áudio 2 e selecione @b{Adicionar efeito..}. Destaque o @b{Áudio 1: Compressor} e pressione @b{Adicionar}. Clique na lente de aumento do compressor do Áudio 1 @image{manual_images_intl/magnify,7mm} para revelar a interface do compressor.

Configure os seguintes parâmetros:
@itemize @minus
@item Segundos para reação: @b{-0.1}
@item Segundos para declínio: @b{0.1}
@item Tipo de Gatilho: @b{Total}
@item Gatilho: @b{0}
@item Suavização apenas @b{Não}
@end itemize

Clique em @b{Limpar} para limpar o gráfico. Clique em qualquer lugar da área do grid e arraste um ponto novo para Saída 0 e Entrada -50. O gráfico deve paracer ao da imagem abaixo:

@center @image{manual_images_en/compress,70mm}

Vá para @b{Arquivo->Renderizar}. Especifique o nome de um arquivo mp3 para dar saída. Configure o formato de arquivo para @b{Áudio MPEG}. Clique no ícone de ferramenta @image{manual_images_intl/wrench,4.33mm} para Áudio de marque @b{Camada} para @b{III} e @b{Kbits por segundo} para @b{24} ou @b{32}. Habilite @b{Renderizar trilhas de áudio} e desabilite @b{Renderizar trilhas de vídeo}. Pressione OK para renderizar o arquivo.

O arquivo @file{.mp3} resultante deve ser subido (upload) para um servidor de internet. Então, o navegador de internet do telefone deve baixar (download) o diretório do arquivo @file{.mp3} diretamente da URL@. Pode ser que haja um limite de tamanho para o arquivo.

@c cincvdoc_node_number_276
@node Esticamento temporal de áudio
@section Esticamento temporal de áudio
@cindex Esticamento temporal de áudio
@cindex Áudio, esticamento temporal

Pode parecer que o esticamento temporal de áudio é um problema de selecionar uma região das trilhas de áudio, habilitar a gravação das trilhas desejadas, ir para @b{Áudio->Renderizar efeito} e aplicar o @b{Esticamento de tempo}. Na verdade, há três efeitos de áudio para esticamento temporal de áudio: @b{Esticamento de tempo}, @b{Refazer amostragem}, e @b{caixa de diálogo de informações do recurso}.

Esticamento de tempo aplica uma transformação rápida Fourier para tentar mudar a duração sem mudar a frqüência, mas isso introduz artefatos ao áudio. Ele é útil apenas para mudanças grandes de tempo porque mudanças óbvias na duração tornam os artefatos menos intrusivos.

Para mudanças menores na duração, até uma abrangência de 5%, @b{Refazer amostragem} deve ser usado. Ele modifica a freqüência de áudio mas mudanças pequenas o suficiente não são notáveis. Refazer amostragem não introduz artefatos, então é mais útil para pequenas mudanças de duração nas quais o ouvinte supostamente não sabe o que está acontecendo.

Outro modo de mudar levemente a duração é ir para a janela de @b{Recursos}, destacar a pasta de @b{mídia}, clicar com o botão direito do mouse em um arquivo de áudio, clicar em @b{Info}. Ajuste a taxa de amostragem no diálogo @b{Info} para ajustar a duração. Este método também requere que se clique com o botão esquerdo na margem direita das trilhas de áudio e arraste-as para a esquerda ou para a direita para corresponder às mudanças de duração.

@c cincvdoc_node_number_277
@node Capturas de telas de vídeo
@section Capturas de telas de vídeo
@cindex Capturas de telas de vídeo

Explicamos aqui a como gravar capturas de telas de vídeo e editá-las no Cinelerra.

Primeiro, você deve gravar o vídeo com o xvidcap. Você pode achar esta ferramenta no repositório da maioria das distribuições ou baixá-lo aqui: @*
@uref{http://xvidcap.sourceforge.net}

Primeiro, capture a tela: @*
@command{xvidcap --fps 10 --cap_geometry 1280x1024+0+0 --file "arquivo1.mpeg" --gui no --audio no}

Não esqueça de mudar a opção de geometria de acordo com o tamanho da sua tela. Então, converta o arquivo @file{arquivo1.mpeg} que você obteve em um arquivo MPEG que possa ser usado pelo Cinelerra: @*
@command{ffmpeg -r 10 -i arquivo1.mpeg -s 1280x1024 -b 3000 -aspect 1.33 -r 25 arquivo2.mpeg}

Agora você pode carregar este arquivo no Cinelerra. Assegure-se de ter configurado corretamente o formato de vídeo de seu projeto (tamanho, taxa de quadros, razão de aspecto)

Quando você tiver terminado de editar o vídeo, você deve renderizá-lo. Renderize-o como uma seqüência JPEG. É recomendável que você escreva os arquivos JPEG em uma nova pasta, uma vez que provavelmente haverá um monte de novos arquivos criados.

Então, abra uma janela de terminal e entre (cd) naquela pasta. Codifique os arquivos JPEG usando os seguintes comandos:

Primeira passagem: @*
@command{mencoder "mf://*.jpg" -mf fps=25 -oac pcm -sws 2 -vf scale=1280:1024,hqdn3d=2:1:2 -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:aspect=4/3:vpass=1 -ofps 10 -of avi -o /dev/null -ffourcc DIVX} @*
Segunda passagem: @*
@command{mencoder "mf://*.jpg" -mf fps=25 -oac pcm -sws 2 -vf scale=1280:1024,hqdn3d=2:1:2 -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=800:aspect=4/3:vpass=2 -ofps 10 -of avi -o ../arquivo_renderizado.avi -ffourcc DIVX}

Você também pode renderizar o vídeo para MPEG4 diretamente do Cinelerra se quiser.

@c cincvdoc_node_number_278
@node Melhorando a performance
@section Melhorando a performance
@cindex Performance, melhorando

Pelo momento, o GNU/Linux não é um desktop excelente. Ele é mais como um servidor. A maioria do que você vai encontrar nas distribuições modernas GNU/Linux é programas sem rosto, de rede-apenas, estrategicamente desenhados para contra-agir com uma característica de servidor da Microsoft ou outra e não ter uma boa performance para interação de usuários. Há um número de parâmetros no GNU/Linux que pessoas normais podem ajustar para fazê-lo se comportar mais como um desktop gerado minuciosamente.

@menu
* Desabilitando a área de troca (swap)::
* Alargando os buffers de áudio::
* Liberando mais memória compartilhada::
* Aumentando a velocidade do disco rígido::
* Desabilitando o cron::
* Reduzindo a sensibilidade do mouse USB::
* Modificações gerais no X::
* Aumentando a velocidade do sistema de arquivos::
* Melhorando vídeos Zoran::
@end menu

@c cincvdoc_node_number_279
@node Desabilitando a área de troca (swap)
@subsection Desabilitando a área de troca (swap)
@cindex Desabilitando a área de troca (swap)
@cindex Área de troca (swap), desabilitando

Em sistemas com muita memória, o Cinelerra às vezes roda melhor sem uma área de troca (swap). Se você possui 4 GB de RAM, você provavelmente vai ficar melhor sem o espaço de swap. Se você possui 512MB de RAM, você deve manter o swap. Se você quer fazer gravações, você provavelmente deve desabilitar o swap em qualquer um dos casos. Há uma razão para isso. O GNU/Linux permite que apenas metade da memória disponível seja usada. Além disso, ele começa a procurar por páginas livres para usar como troca, para conseguir fazer mais cache de acesso ao disco. Em um sistema de 4 GB, você vai começar a esperar por mais páginas de swap após ter usado apenas 2 GB@.

A questão então é como fazer o GNU/Linux rodar sem um espaço de swap. Teoricamente, deveria ser apenas um problema de rodar o comando @*
@command{swapoff -a}

Infelizmente, sem um espaço de swap, a função kswapd normalmente gira a 100%. Para eliminar este problema, edite o arquivo @file{linux/mm/vmscan.c}. Nele, ponha uma linha dizendo @command{return 0;} antes da que diz
@verbatim
    /*
     * Kswapd main loop.
     */
@end verbatim

Então recompile o kernel.

@c cincvdoc_node_number_280
@node Alargando os buffers de áudio
@subsection Alargando os buffers de áudio
@cindex Buffers de áudio, alargando

Para melhorar a performance tempo-real, os buffers de áudio para todos os drives de som GNU/Linux foram limitados de 128k para 64k. Para gravar áudio e vídeo simultaneamente e para a maioria das gravações de áudio, isso faz com que dados sejam pulados ("dropouts"). Aplicações de latência baixa e patches de kernel preemptíveis tornam possível gravar mais gravações de áudio, mas não melhoram a gravação de vídeo com áudio. É aqui que você tem que hackear o kernel.

Para ver se seus buffers de áudio são adequados, rode o programa incluído de teste de áudio com nada sendo reproduzido ou gravado. Isso alocará os buffers mais largos possíveis e exibi-los. Se o @b{Total de bytes disponível} estiver abaixo de 131072, você precisa alargar seus buffers no driver. Como vários drivers diferem, temos o hack para pelo menos um deles.

Isso se aplica à versão OSS do driver Soundblaster Live. Já que cada placa de áudio e derivativo de driver de áudio possui uma implementação diferente, você vai precisar fazer uma busca por outras placas de áudio. Edite o @file{linux/drivers/sound/emu10k1/audio.c}

Onde diz @*
@code{if (bufsize >= 0x10000)} @*
mude para: @*
@code{if (bufsize > 0x40000)}

Onde diz
@verbatim
    for (i = 0; i < 8; i++)
        for (j = 0; j < 4; j++)
@end verbatim
mude para:
@verbatim
    for (i = 0; i < 16; i++)
        for (j = 0; j < 4; j++)
@end verbatim

Em @file{linux/drivers/sound/emu10k1/hwaccess.h} @*
Mude @*
@code{#define MAXBUFSIZE 65536} @*
para @*
@code{#define MAXBUFSIZE 262144}

Finalmente, em @file{linux/drivers/sound/emu10k1/cardwi.h} @*
Mude @*
@code{#define WAVEIN_MAXBUFSIZE         65536} @*
para @*
@code{#define WAVEIN_MAXBUFSIZE         262144}

Então, recompile os módulos do kernel.

@c cincvdoc_node_number_281
@node Liberando mais memória compartilhada
@subsection Liberando mais memória compartilhada
@cindex Liberando mais memória compartilhada
@cindex Memória compartilhada, liberando
@cindex Memória, liberando

O kernel do GNU/Linux permite apenas que 32MB de memória compartilhada sejam alocados por padrão. Este número precisa ser aumentado para que se possa fazer qualquer coisa útil. Quando iniciado, o Cinelerra pode lembrá-lo disso exibindo a seguinte mensagem de erro: @*
@command{echo "0x7fffffff" > /proc/sys/kernel/shmmax}

Para uma mudança permanente, adicione ao arquivo @file{/etc/sysctl.conf} a seguinte linha:
@verbatim
kernel/shmmax=0x7fffffff
@end verbatim

ou, se você preferir:
@verbatim
kernel.shmmax = 2147483647
@end verbatim

Da primeira vez, para evitar ter de reiniciar seu computador, usa o seguinte comando como root:
@verbatim
sysctl -p
@end verbatim

@c cincvdoc_node_number_282
@node Aumentando a velocidade do disco rígido
@subsection Aumentando a velocidade do disco rígido
@cindex Aumentando a velocidade do disco rígido
@cindex Disco rígido, aumentando a velocidade
@cindex hdparm

Este é um comando bastante popular entre os gurus de GNU/Linux, que não é feito por padrão nas distribuições GNU/Linux. @*
@command{hdparm -c3 -d1 -u1 -k1 /dev/hda}

@itemize @bullet
@item @option{-c3} põe o disco rígido em 32 bit I/O com sincronia. Isso normalmente não funciona devido a um suporte inepto do kernel para a maioria dos controladores IDE. Se você obter erros de "lost interrupt" ou "SeekComplete", use rapidamente o @option{-c0} ao invés do @option{-c3} em seu comando.
@item @option{-d1} habilita o DMA, obviamente. Isso libera a CPU parcialmente durante transferências de informação.
@item @option{-u1} permite que vários interrupts sejam lidados durante transações de disco rígido. Isso libera ainda mais tempo de CPU.
@item @option{-k1} evite que o GNU/Linux reconfigure suas configurações no caso de uma falha.
@end itemize

@c cincvdoc_node_number_283
@node Desabilitando o cron
@subsection Desabilitando o cron
@cindex Desabilitando o cron
@cindex Cron, desabilitando

O GNU/Linux roda algumas operações diárias como comprimir páginas de manual. Estas tarefas podem ser aceitas como tarefas de fundo conforme se compila ou se faz um processamento de texto, mas não durante a reprodução de um vídeo. Desabilite essas operações editando o @file{/etc/rc.d/init.d/anacron}.

Ponha @command{exit} antes da primeira linha que não começar com um @command{#}.

Em @file{/etc/rc.d/init.d/crond}, ponha @command{exit} antes da primeira linha não começando com @command{#}. Então, reinicie o sistema.

Você não pode usar o comando @command{at} mais, mas quem usa este comando afinal?

@c cincvdoc_node_number_284
@node Reduzindo a sensibilidade do mouse USB
@subsection Reduzindo a sensibilidade do mouse USB
@cindex Reduzindo a sensibilidade do mouse USB
@cindex Mouse, reduzindo a sensibilidade
@cindex Mouse USB, reduzindo a sensibilidade

Gamers gostam de mouses com alta resolução, mas isso pode ser doloroso para posicionar precisamente um mouse em uma linha do tempo de um monitor. O XFree86 já permitiu que você reduzisse a sensibilidade do mouse PS/2 usando comandos como @command{xset m 1 1}, mas você não terá a mesma sorte com mouses USB ou KVM.

Temos um jeito de reduzir a sensibilidade do mouse USB, mas isso requererá editar o código fonte do kernel. Embora mouses USB sejam suportados por anos, o código fonte do kernel para mouses USB é constantemente reescrito. Estas instruções eram relevantes para o 2.6.12.3. Edite o @file{/usr/src/linux/drivers/input/mousedev.c}.

Após a linha que diz @*
@code{struct mousedev_hw_data @{} @*
coloque @*
@code{#define DOWNSAMPLE_N 100} @*
@code{#define DOWNSAMPLE_D 350} @*
@code{int x_accum, y_accum;}

Depois, a seção que diz algo como:
@verbatim
switch (code) {
    case REL_X:	mousedev->packet.dx += value; break;
    case REL_Y:	mousedev->packet.dy -= value; break;
    case REL_WHEEL:	mousedev->packet.dz -= value; break;
}
@end verbatim
deve ser substituída por
@verbatim
switch (code) {
    case REL_X:
    mousedev->packet.x_accum += value * DOWNSAMPLE_N;
    mousedev->packet.dx += (int)mousedev->packet.x_accum
    / (int)DOWNSAMPLE_D;
    mousedev->packet.x_accum -=
    ((int)mousedev->packet.x_accum / (int)DOWNSAMPLE_D)
    * (int)DOWNSAMPLE_D;
    break;
    case REL_Y:
    mousedev->packet.y_accum += value * DOWNSAMPLE_N;
    mousedev->packet.dy -= (int)mousedev->packet.y_accum
    / (int)DOWNSAMPLE_D;
    mousedev->packet.y_accum -=
    ((int)mousedev->packet.y_accum
    / (int)DOWNSAMPLE_D) * (int)DOWNSAMPLE_D;
    break;
    case REL_WHEEL: mousedev->packet.dz -= value; break;
}
@end verbatim

Mude o valor de @b{DOWNSAMPLE_N} para mudar a sensibilidade do mouse.

@c cincvdoc_node_number_285
@node Modificações gerais no X
@subsection Modificações gerais no X
@cindex X, modificações gerais

O XFree86 por padrão não pode exibir a renderização de pixmap avançada do Cinelerra muito rapidamente. O servidor X congela durante o desenho de caixas de listas ("list box drawing"). Conserte isso adicionando uma linha a seus arquivos XF86Config*.

Na área @b{Section "Device"}, adicione uma linha dizendo: @*
@code{Option "XaaNoOffscreenPixmaps"} @*
e reinicie o servidor X.

Embranquecimento de tela é realmente perturbador, a não ser que você seja fabulosamente rico e possa manter seu monitor 24h por dia sem o modo de economia de energia. Em
@file{/etc/X11/xinit/xinitrc} coloque @*
@code{xset s off} @*
@code{xset s noblank} @*
antes da primeira declaração @command{if}.

E sobre aquelas teclas de janela que nenhuma distribuição GNU/Linux pensa em usar? Você pode fazer com que as teclas de janela provenham funcionalidade de ALT editando
@file{/etc/X11/Xmodmap}. Adicione o seguinte a ele. @*
@code{keycode 115 = Hyper_L} @*
@code{keycode 116 = Hyper_R} @*
@code{add mod4 = Hyper_L} @*
@code{add mod5 = Hyper_R}

As mudanças reais para que um gerenciador de janelas reconheça teclas de janela para @key{ALT} são complexas. No @b{FVWM} pelo menos, você pode editar 
@file{/etc/X11/fvwm/system.fvwm2rc} e colocar @*
@code{Mouse 0 T A move-and-raise-or-raiselower} @*
@code{#Mouse 0 W M move} @*
@code{Mouse 0 W 4 move} @*
@code{Mouse 0 W 5 move} @*
@code{Mouse 0 F A resize-or-raiselower} @*
@code{Mouse 0 S A resize-or-raiselower}

no lugar da seção padrão para movimentação e redimensionamento. A sua melhor performance vai ser no FVWM@. Outros gerenciadores de janela parecem diminuir a velocidade do vídeo com aradilhas de eventos extra e não são tão eficientes no layout.

@c cincvdoc_node_number_286
@node Aumentando a velocidade do sistema de arquivos
@subsection Aumentando a velocidade do sistema de arquivos
@cindex Aumentando a velocidade do sistema de arquivos
@cindex Sistema de arquivos, aumentando a velocidade

Você vai normalmente armazenar vídeo em um arranjo gigante de disco separado de seu disco de boot. Você então tem que manualmente instalar um sistema de arquivos EXT neste arranjo de disco, usando o comando @command{mke2fs}. De longe, o sistema de arquivos mais rápido é o @*
@cindex mke2fs
@cindex tune2fs
@command{mke2fs -i 65536 -b 4096 meu_dispositivo} @*
@command{tune2fs -r0 -c10000 meu_dispositivo}

Ele não possui journaling, reserva o menor número de blocos possível para nomes de arquivos e acessa a maior quantidade de informação por bloco possível. Um sistema de arquivos levemente mais lento, que é mais fácil de recuperar após falhas de energia é @*
@command{mke2fs -j -i 65536 -b 4096 meu_dispositivo} @*
@command{tune2fs -r0 -c10000 meu_dispositivo}

Isso adiciona um journal que deixa a escrita um pouco mais lenta, mas torna-nos imune a falhas de energia.

@c cincvdoc_node_number_287
@node Melhorando vídeos Zoran
@subsection Melhorando vídeos Zoran
@cindex Vídeos Zoran, melhorando

Vídeo gravado a partir de dispositivos ZORAN é normalmente não-alinhado ou não completamente codificado direito. Isso pode ser levemente compensado ajustando os parâmetros no código fonte do driver.

Em @file{/usr/src/linux/drivers/media/video/zr36067.c} as estruturas definidas perto da linha 623 afetam o alinhamento. Pelo menos para NTSC, a versão 2.4.20 do driver podia ser melhorada mudando
@verbatim
    static struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 16 };
para
    static struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 17 };
@end verbatim

Em @file{/usr/src/linux/drivers/media/video/bt819.c}, mais estruturas perto da linha 76 afetam o alinhamento e a codificação. @*
Para NTSC
@verbatim
    {858 - 24, 2, 523, 1, 0x00f8, 0x0000},
poderia ser mudado para
    {868 - 24, 2, 523, 1, 0x00f8, 0x0000},
@end verbatim
Ajustar esses parâmetros podem ou não mover sua imagem para mais perto do centro. Na maioria das vezes, isso fará o driver travar antes de capturar o primeiro quadro.

@b{New in 2.6.5:} @*
Em kernels 2.6, o subsistema de vídeo foi reescrito de novo do zero. Para ajustar os parâmetros do Zoran, vá para @file{drivers/media/video/zoran_card.c} e busque um grupo de linhas como
@verbatim
    static struct tvnorm f50sqpixel = { 944, 768, 83, 880, 625, 576, 16 };
    static struct tvnorm f60sqpixel = { 780, 640, 51, 716, 525, 480, 12 };
    static struct tvnorm f50ccir601 = { 864, 720, 75, 804, 625, 576, 18 };
    static struct tvnorm f60ccir601 = { 858, 720, 57, 788, 525, 480, 16 };

    static struct tvnorm f50ccir601_lml33 = { 864, 720, 75+34, 804, 625, 576, 18 };
    static struct tvnorm f60ccir601_lml33 = { 858, 720, 57+34, 788, 525, 480, 16 };

    /* The DC10 (57/16/50) uses VActive as HSync, so HStart must be 0 */
    static struct tvnorm f50sqpixel_dc10 = { 944, 768, 0, 880, 625, 576, 0 };
    static struct tvnorm f60sqpixel_dc10 = { 780, 640, 0, 716, 525, 480, 12 };
    
    /* FIXME: I cannot swap U and V in saa7114, so i do one
     * pixel left shift in zoran (75 -> 74)
     * (Maxim Yevtyushkin <max@linuxmedialabs.com>) */
    static struct tvnorm f50ccir601_lm33r10 = { 864, 720, 74+54, 804, 625, 576, 18 };
    static struct tvnorm f60ccir601_lm33r10 = { 858, 720, 56+54, 788, 525, 480, 16 };
@end verbatim

Elas parecem controlar a posição da imagem. Pelo menos para o LML33 a definição seguinte para @b{f60ccir601_lml33} faz sucesso. @*
@code{static struct tvnorm f60ccir601_lml33 = @{ 858, 720, 67+34, 788, 525, 480, 13 @};}

@c cincvdoc_node_number_288
@node Traduzindo o Cinelerra
@section Traduzindo o Cinelerra
@cindex Traduzindo o Cinelerra

@menu
* Locais disponíveis::
* Atualizando uma tradução existente::
* Criando uma nova tradução::
@end menu

Esta informação é necessária se você quer participar de uma tradução do Cinelerra. Veja @xref{Variáveis de ambiente}, sobre como rodar o Cinelerra em sua língua.

@c cincvdoc_node_number_289
@node Locais disponíveis
@subsection Locais disponíveis
@cindex Locais disponíveis

Há alguns locais existentes do cinelerra:
@itemize @bullet
@item @b{DE} - Alemão
@item @b{ES} - Espanhol
@item @b{EU} - Basco
@item @b{FR} - Francês
@item @b{IT} - Italiano
@item @b{PT_BR} - Português do Brasil
@item @b{SL} - Esloveno
@end itemize

@c cincvdoc_node_number_290
@node Atualizando uma tradução existente
@subsection Atualizando uma tradução existente
@cindex Atualizando uma tradução existente

Para gerar um arquivo @file{*.po} atualizado com as mais novas entradas do código fonte do Cinelerra ainda não presentes no arquivo @file{.po}, rode após @command{./configure}: @*
@command{cd po && make}

Então, edite o arquivo @file{.po} localizado na pasta @file{po/} de sua língua alvo e submeta o arquivo de diferença para a equipe do Cinelerra-CV.

@c cincvdoc_node_number_291
@node Criando uma nova tradução
@subsection Criando uma nova tradução
@cindex Criando uma nova tradução

Para criar uma nova tradução, rode após @command{./configure}: @*
@command{cd po && make}

Então, edite o arquivo @file{cinelerra.pot} localizado em @file{po/} e adicione as entradas apropriadas traduzidas. Renomeie o arquivo para @file{(prefixo_da_lingua).po} e adicione o prefixo de língua para @file{po/LINGUAS}. Finalmente, submeta o arquivo diff à equipe do cinelerra-CV.

@c cincvdoc_node_number_292
@node Fazendo panorâmicas e aproximações em imagens estáticas
@section Fazendo panorâmicas e aproximações em imagens estáticas
@cindex Fazendo panorâmicas e aproximações em imagens estáticas
@cindex Imagens estáticas, fazendo panorâmicas e aproximações

As características poderosas de quadros-chave do Cinelerra permitem que você faça efeitos poderosos de panorâmicas e aproximação com uma imagem estática.
@enumerate 1
@item Carregue e crie um recorte com uma imagem estática conforme descrito acima. Faça o recorte durar 10 segundos.
@item Ative a @b{geração automática de quadros-chave}
@item Usando os @b{controles de transporte} vá para o início do recorte
@item Usando os @b{controle de composição de câmera} marque a posição inicial de seu recorte
@item Usando os @b{controles de transporte} mova para frente alguns segundos no recorte
@item Arrastando a @b{composição de câmera}, mova o centro da câmera para uma nova posição
@item Agora, volte para o começo do recorte e reproduza-o.
@end enumerate

Você pode ver que a câmera suavemente se move de um ponto de quadro-chave a outro quadro-chave, conforme o Cinelerra automaticamente ajusta o movimento de câmera em linhas retas de ponto a ponto.

@c cincvdoc_node_number_342
@node Editando HDV 1080i usando arquivos proxy
@section Editando HDV 1080i usando arquivos proxy
@cindex Editando HDV 1080i usando arquivos proxy

Trabalhar com vídeo de alta definição, que tipicamente vem de câmeras HDV requere um monte de poder de processamento. Mesmo se o sistema consegue reproduzir uma trilha única à taxa de quadros inteira, ele normalmente não consegue reproduzir várias trilhas simultaneamente. Assim, uma simples transição Dissolver fica tão lenta a ponto de ser inaceitável. Mais do que isso, o HDV está num formato baseado em GOP, e um simples recorte requere a decodificação de todo o GOP em menos de 1/25s. Desta forma, uma das possibilidades é fazer todas as edições em arquivos de resolução menor e usar o material HDV apenas para a renderização final. O fluxograma de trabalho apresentado abaixo foi primeiro proposto por Hermann @sc{Vosseler}.

@menu
* Visão geral::
* Capturando HDV a partir de uma câmera::
* Usando os arquivos TOC e WAV::
* Gerando os arquivos proxy::
* Convertendo os arquivos HDV e proxy::
* Renderizando o projeto HDV::
* Outras questões::
@end menu

@c cincvdoc_node_number_343
@node Visão geral
@subsection Visão geral
@cindex Edição HDV 1080i, visão geral

@itemize @bullet
@item Para cada arquivo HDV, um proxy é criado com uma escala de 0.5.
@item O projeto é criado com uma resolução HDV, por exemplo, 1440x1080 e aspecto 16/9.
@item Novos recursos são criados tanto com os proxies como com os arquivos HDV.
@item Cada trilha de vídeo deve ter uma Automação de Câmera marcada para 2.0.
@item A edição é feita com os arquivos proxy.
@item Para renderizar em HDV, saia do Cinelerra e converta o arquivo do projeto com o proxychange.py e reabra o projeto.
@item Após a renderização, caso edições futuras sejam necessárias, o arquivo do projeto pode ser re-transformado em uma versão proxy.
@end itemize

@c cincvdoc_node_number_344
@node Capturando HDV a partir de uma câmera
@subsection Capturando HDV a partir de uma câmera
@cindex Edição HDV 1080i, capturando HDV a partir de uma câmera

Ainda não há uma solução perfeita até agora. Uma possibilidade é rodar o comando @command{test-mpeg2} disponível com os fontes do @b{libiec61883}. Use esta sintaxe:@*
@command{test-mpeg2 > hdv_tape.mpeg}@*
e pressione @b{Play} na câmera. Você não deveria rodar quaisquer programas que consumam muitos recursos em seu computador já que a falta de fluxo de cache no test-mpeg2 gera saltos de quadros ("frame drops").
framedrops.

@c cincvdoc_node_number_345
@node Usando os arquivos TOC e WAV
@subsection Usando os arquivos TOC e WAV
@cindex Edição HDV 1080i, usando os arquivos TOC e WAV

Tente usar arquivos WAV para som, e carregue os arquivos HDV MPEG-2 via seu TOC gerado. Para criar os arquivos de toc, use o seguinte comando:@*
@command{for i in *.mpeg; do mpeg3toc $i `basename $i mpeg`toc; done}

@c cincvdoc_node_number_346
@node Gerando os arquivos proxy
@subsection Gerando os arquivos proxy
@cindex Edição HDV 1080i, gerando os arquivos proxy

Arquivos proxy podem ser convertidos de muitas formas e podem usar qualquer formato. Entretanto, o Cinelerra funciona melhor quando editando formatos que não sejam baseados em GOP. Para converter seus arquivos HDV em I-frames baseados em arquivos mjpeg com 50% de escala, use o seguinte comando:@*
@command{for i in *.mpeg;do mencoder -mc 0 -noskip $i -ovc lavc -lavcopts
vcodec=mjpeg -vf scale=720:540 -oac pcm -o `basename $i mpeg`avi; done}

@c cincvdoc_node_number_347
@node Convertendo os arquivos HDV e proxy
@subsection Convertendo os arquivos HDV e proxy
@cindex Edição HDV 1080i editing, convertendo os arquivos HDV e proxy

O script python @b{proxychange.py} converte HDV para/de proxies. Você pode baixar este script aqui:@*
@uref{http://cvs.cinelerra.org/docs/proxychange.py}

Ele sobrescreve os arquivos existentes de projeto e cria uma cópia do original em @file{projectfile.xml.bak}.

@itemize @bullet
@item Proxy -> HDV (ex. para renderização):@*
@command{./proxychange.py projectfile.xml -from `proxyfiles/(\w+)\.avi` -to `hdv/\1.toc` -scale 0.5}
@item HDV -> Proxy (ex. após renderizar se você quiser fazer novas edições):@*
@command{./proxychange.py projectfile.xml -from `hdv/(\w+)\.toc` -to `proxyfiles/\1.avi` -scale 2.0}
@end itemize

O arquivo XML do projeto não é um arquivo XML perfeitamente válido. Assim, após cada operação de "Salvar" do Cinelerra, algum problema pode ocorrer. Às vezes, as tags não estão fechadas, ou seja, a <TAG> não está seguida de um </TAG>. Isso debe ser corrigido manualmente.

ACODEC contém alguns \001 caracteres. Edite o arquivo manualmente ou use o comando a seguir:@*
@command{cat temp001.xml| tr -d `\001` > /tmp/1 ; mv /tmp/1 temp001.xml}

@c cincvdoc_node_number_348
@node Renderizando o projeto HDV
@subsection Renderizando o projeto HDV
@cindex Edição HDV 1080i, renderizando o projeto

Arquivos HDV podem ser renderizados para uma faixa YUV4MPEG e então codificados para MPEG2 usando um binário do Mjpegtools modificado.
@command{mpeg2enc -verbose 0 -aspect 3 -format 3 -frame-rate 3 -video-bitrate 25000 -nonvideo-bitrate 384 -force-b-b-p -video-buffer 448 -video-norm n -keep-hf -no-constraints -sequence-header-every-gop -min-gop-size 6 -max-gop-size 6 -o %}

Renderize o com como um arquivo AC3, e multiplexe o vídeo e o áudio com o mplex.

@c cincvdoc_node_number_349
@node Outras questões
@subsection Outras questões
@cindex Edição HDV 1080i, outras questões

Quando reproduzindo arquivos MJPEG, a transição Dissolver não funciona adequadamente nos modos RGBA ou YUVA, mas ela funciona bem em RGB ou YUV.

@c cincvdoc_node_number_350
@node Adicionando legendas
@section Adicionando legendas
@cindex Legendas, adicionando

Há dois métodos disponíveis para se adicionar legendas em um vídeo:
@itemize @bullet
@item Usar o efeito de Título do Cinelerra. Esta tarefa é longa e fatigante. Além disso, as legendas ficam na verdade incrustradas na imagem. Não será possível reproduzir o vídeo renderizado sem as legendas. Se você quer que seu vídeo esteja disponível com legendas em vários idiomas, você terá que renderizá-lo várias vezes. Veja @xref{Título}, para informações sobre o efeito de Título do Cinelerra.
@item Adicionar as legendas com um editor de legendas após haver renderizado o vídeo.
@end itemize

O segundo método é o usado caso você queira que seu vídeo fique disponível com legendas em vários idiomas. Caso você queira produzir um DVD, este método é também o único que é compatível com a ferramenta de legendas do dvdauthor. Caso você planeje distribuir seu vídeo pela internet, um arquivo de vídeo e vários de legendas será menor do que vários arquivos de vídeo, um para cada língua.

Arquivos de texto de legendas podem ser exibidos por qualquer reprodutor de vídeo decente. Com o mplayer, você pode usar a seguinte sintaxe:@*
@command{mplayer -sub <o_arquivo_de_legenda_de_texto> <o_arquivo_de_vídeo>}

Um arquivo de legenda é um arquivo simples de texto, que contém o texto e o tempo o número do quadro onde cada legenda deve ser exibida na tela.

Há vários editores de legendas disponíveis para Linux. Entretanto, a maioria deles é boa para facilitar a @b{tradução} de legendas, mas não apropriados para realmente @b{adicionar} e @b{sincronizar} novas legendas em um vídeo. Uma vez que a criação de vídeo é no que a maioria de nós se foca, a tarefa em que estamos mais interessados é em @b{criar} legendas para um vídeo.

Nós fortemente recomendamos o @b{Subtitleeditor}, que está disponível aqui:@*
@uref{http://kitone.free.fr/subtitleeditor}

@center @image{manual_images_en/subtitleeditor,100mm}
@center @b{Subtitleeditor}

O Subtitleeditor possui a grande vantagem de exibir a onda do áudio. Esta característica é realmente importante para sincronizar precisamente as legendas às falas. Tenha em mente que a sincronia estaria perdida se você editasse seu vídeo após haver adicionado as legendas. Adicionar legendas deve ser feito após a edição do vídeo haver terminado.

Uma vez que o arquivo de texto de legendas estiver criado, você pode:
@itemize @bullet
@item Distribui-lo com o seu vídeo. As pessoas vão ter que carregar o arquivo adequado de legendas em seus reprodutores de vídeo para efetivamente ver as legendas.
@item Usá-lo com o dvdauthor, para adicionar as legendas em um DVD. Leia a documentação do dvdauthor para mais informação.
@item Incrustar as legendas no vídeo usando o mencoder. Esta linha de comando é um exemplo. Adapte as opções a suas necessidades:@*
@command{mencoder -sub <seu_arquivo_de_legenda> <arquivo_de_vídeo_sem_legendas> -ovc lavc -lavcopts vcodec=mpeg4:vhq:vbitrate=1000 -oac mp3lame -lameopts br=256:vol=1 -ffourcc DIVX -o <vídeo_convertido.avi>}
@end itemize

@c cincvdoc_node_number_293
@node Resolvendo problemas
@chapter Resolvendo problemas
@cindex Resolvendo problemas

@menu
* Reportando erros::
* A reprodução não pára::
* Paus do driver Buz::
* Arrastar bordas de edição não funciona::
* Travando quando arquivos estão sendo carregados::
* Sincronia perdida quando capturando arquivos::
* Aplicar gama seguido do desfocar não funciona::
* Cópia e Cola de seleções de trilha não funcionam na Linha do Tempo::
* Cinelerra dá pau freqüente::
* Tema Blond não encontrado::
@end menu

@c cincvdoc_node_number_294
@node Reportando erros
@section Reportando erros
@cindex Reportando erros
@cindex Erros, reportando

Quando você encontra um erro ("bug"), a primeira coisa a fazer é ir para @uref{http://bugs.cinelerra.org} e checar se ele já não foi reportado. Se não há um reporte para o erro que você notou, você pode preencher um relatório de erro. Abra uma conta em @uref{http://bugs.cinelerra.org} caso você ainda não a tenha. Então, preencha o reporte de erros, incluindo a seguinte informação:

@itemize @minus
@item Número de revisão do Cinelerra CV@. Exemplo: r959

@item Nome da distribuição e versão.  Exemplo: Debian SID

@item Passos para replicar o erro. Isso é muito importante, uma vez que realmente ajuda às pessoas que estão tentando consertá-los. Exemplo:
@enumerate 1
@item abrir o cinelerra
@item abrir a janela de gravação
@item clicar em OK
@item cinelerra dá pau
@end enumerate

@item Quando o Cinelerra CV dá pau, uma saída depuradora é bem vinda. Rode: @*
@command{gdb cinelerra} @*
@command{run} @*
(Você provoca o erro e o Cinelerra CV dá pau) @*
@command{thread apply all bt} @*
Copie toda a informação disposta no seu reporte de erros.
@end itemize

Não exite em anexar qualquer arquivo que você acha que tenha relevância, como uma captura de tela por exemplo. A saída gdb é mais útil quando o Cinelerra é compilado com símbolos de depuração. Veja @xref{Compilando com símbolos de depuração}, para instruções de compilação.

Além disso, se o erro que você notou estiver relacionado a um problema de carregar um arquivo específico no Cinelerra-CV, fazer um upload de uma pequena amostra de tal arquivo na internet pode ser bem útil. Isso permitiria a outras pessoas consertando erros tentar carregar aquele arquivo no Cinelerra e ver o que acontece.

@c cincvdoc_node_number_351
@node A reprodução não pára
@section A reprodução não pára
@cindex A reprodução não pára

Se a reprodução das trilhas de áudio não parar na linha do tempo e continuar após o final do vídeo, vá para @b{Configurações -> Preferências -> Reprodução} e clique na caixinha do @b{Parar travamento de reprodução}. Esta caixinha é mostrada apenas se você configurou o ALSA como driver de áudio.

@c cincvdoc_node_number_295
@node Paus do driver Buz
@section Paus do driver Buz
@cindex Buz, paus do driver

Primeiro, placas de captura Zoran devem ser acessadas usando o driver de vídeo @b{Buz} em @b{Preferências->Gravação} e @b{Preferências->Reprodução}. Alguns ajustes de performance estão disponíveis em outra seção. @xref{Melhorando a performance}.

Uma vez ajustado, o driver Buz parece dar pau se o número de buffers de gravação for muito alto. Faça com que ele esteja abaixo de 10 em @b{Preferências->Gravação->Quadros para bufferizar no dispositivo}.

@c cincvdoc_node_number_296
@node Arrastar bordas de edição não funciona
@section Arrastar bordas de edição não funciona
@cindex Arrastar bordas de edição não funciona
@cindex Pontos de entrada e saída, arrastar não funciona

Às vezes haverá dois blocos de edição bem juntos um do outro. A borda de edição selecionada para ser arrastada pode ser próxima ao bloco buscado em um bloco muito pequeno para ver no nível de aproximação atual. Aproxime horizontalmente.

@c cincvdoc_node_number_297
@node Travando quando arquivos estão sendo carregados
@section Travando quando arquivos estão sendo carregados
@cindex Travando quando arquivos estão sendo carregados
@cindex Arquivos, travando quando carregados

O maior motivo de travamentos quando se carrega arquivos é porque o codec não é suportado. Um outro motivo é que o Cinelerra está construindo ícones ("picons") para a Janela de Recursos. Se você carregar um número alto de imagens, será necessário descomprimir cada única imagem para construir um ícone ("picon"). Vá para @b{configurações->preferências->interface} e desabilite @b{Usar miniaturas na janela de recursos} para pular este processo.

@c cincvdoc_node_number_298
@node Sincronia perdida quando capturando arquivos
@section Sincronia perdida quando capturando arquivos
@cindex Sincronia perdida quando capturando arquivos
@cindex Gravação, sincronia

Se a taxa de quadros da gravação for muito mais baixa que a taxa de quadros da fonte, o vídeo acumulará buffers de gravação com o tempo enquanto o áudio e o vídeo ficarão bem fora de sincronia. Diminua o @b{número de quadros para bufferizar no dispositivo} em @b{preferências->gravação} de modo que os quadros excedentes sejam pulados ("dropped") ao invés de bufferizados.

@c cincvdoc_node_number_299
@node Aplicar gama seguido do desfocar não funciona
@section Aplicar gama seguido do desfocar não funciona

O efeito gama usa a função 'pow' enquanto o desfocar usa um número de funções 'exp' na biblioteca matemática. Por alguma razão, usar a função 'pow' quebra chamadas seguintes para as funções 'exp' na biblioteca matemática. Você deve aplicar o gama após o desfocar para fazê-los funcionar.

@c cincvdoc_node_number_300
@node Cópia e Cola de seleções de trilha não funcionam na Linha do Tempo
@section Cópia e Cola de seleções de trilha não funcionam na Linha do Tempo
@cindex Cópia e Cola de seleções de trilha não funcionam na Linha do Tempo

Se você estiver usando a aplicação KDE Klipper, ou desabilite-a ou clique com o botão direito em seu ícone na barra de taregas, selecione @b{Configure Klipper} e assegure-se que o @b{Prevent empty clipboard} não esteja selecionado.

@c cincvdoc_node_number_301
@node Cinelerra dá pau freqüente
@section Cinelerra dá pau freqüente
@cindex Paus

Faça uma instalação limpa. Assegure-se que você não possui bibliotecas de instalações anteriores. Apague o seu diretório @file{$HOME/.bcast/} também. @*
@command{rm -f /usr/local/lib/libguicast*} @*
@command{rm -f /usr/lib/libguicast*} @*
@command{rm -f /usr/local/lib/libquicktimehv*} @*
@command{rm -f /usr/lib/libquicktimehv*} @*
@command{rm -f /usr/local/lib/libmpeg3hv*} @*
@command{rm -f /usr/lib/libmpeg3hv*}

@c cincvdoc_node_number_302
@node Tema Blond não encontrado
@section Tema Blond não encontrado
@cindex Tema Blond não encontrado

Se a seguinte mensagem de erro aparecer: @command{Aborted, MWindow::init_theme: Theme Blond not found}, então:
@itemize @bullet
@item Você deve ter o arquivo @file{defaulttheme.*} dentro de @file{/usr/lib/cinelerra} ou @file{/usr/local/lib/cinelerra}. Se ele não existe, você precisa instalar os plugins novamente.
@item Tente apagar a pasta @file{$HOME/.bcast/}.
@item Olhe dentro de @file{$HOME/.bcast/Cinelerra_rc} e procure o THEME ("tema"); ele estar como => THEME Blond
@end itemize

@c cincvdoc_node_number_303
@node Autoração de plugin
@chapter Autoração de plugin
@cindex Autoração de plugin

A API de plugin no Cinelerra data de 1997, antes de o LADSPA e antes de o VST se tornarem populares. Ela é fundamentalmente a mesma que era em 1997, com modificações menores para suportar quadros-chave e resposta de interface GUI. O GUI não é abstraído do programador. Isso permite ao programador usar a ferramenta que quiser e permite mais flexibilidade na aparência, mas o custo é mais alto.

Há vários tipos de plugins, cada um com um procedimento comum de implementação e mudanças específicas para aquele tipo particular. O jeito mais fácil de implementar um plugin é pegar o plugin mais simples existente no grupo e renomear os símbolos.

@menu
* Introduzindo o método pull:: 		O paradigma atual para a escrita de plugins
* Funções comuns de plugin:: 			O que todos os efeitos devem fazer
* Plugins tempo-real:: 			O que efeitos em tempo-real devem fazer
* Plugins não-tempo-real:: 			O que efeitos renderizados devem fazer
* Plugins de áudio:: 				O que efeitos de áudio devem fazer
* Plugins de vídeo:: 				O que efeitos de vídeo devem fazer
* Plugins de transição:: 			O que transições devem fazer
* GUI de plugins que se atualizam durante a reprodução:: Como usar informação sendo reproduzida para desenhar o GUI
* Busca de informações dos plugins:: 		Como plugins obtêm informação sobre o que ser processado
* Usando OpenGL:: 				Como usar o hardware para aumentar a velocidade das operações
@end menu

@c cincvdoc_node_number_304
@node Introduzindo o método pull
@section Introduzindo o método pull
@cindex Método pull, introduzindo

Originalmente, os plugins eram desenhados com o método de empurrar ("push"). O método push é intuitivo e simples. Uma fonte empurra ("pushes") a informação para um plugin, o plugin faz operações matemáticas nela e o plugin a empurra para um destino. Por 6 anos esta era a forma que todos os plugins de tempo-real eram desenhados internamente, mas ele não te permitia reduzir a taxa de reprodução em tempo-real. Embora os plugins ainda possam ser desenhados como se estivessem empurrando a informação, este não é mais o jeito que eles são processados internamente.

A última evolução no desenho de plugins do Cinelerra é o método de puxar ("pull"). A linha de renderização se inicia na saída final e os passos finais na linha de renderização são os de ler a informação do disco. Cada passo na cadeia de renderização envolve pedir informações do passo anterior. Quando a cadeia de renderização eventualmente requere informação de uma cadeia de plugins, cada plugin requere informações do plugin que o antecede.

Isso é menos intuitivo do que o método push, mas é mais poderoso. Plugins tempo-real escritos usando o método pull podem mudar a razão na qual a informação é apresentada ao espectador e a direção da reprodução. O método pull permite que os plugins tragam informações para eles a uma taxa mais alta do que eles a enviam para fora.

Para conseguir o poder de independência de taxa, o método pull requere que os plugins saibam mais sobre a informação do que precisavam sob o método push. Plugins precisam saber a qual taxa o projeto está, a qual taxa sua saída supostamente deve ser e a qual taxa sua entrada supostamente deve estar. Essas taxas diferentes de informação precisam estar correlacionadas para que um plugin se configure devidamente.

Quadros-chave para um plugin são armazenados relativos à taxa de quadros do projeto. Buscas de informações de um plugin para a posição de reprodução atual são dadas relativas à taxa de quadros do projeto. Se foi requerido ao plugin que sua saída esteja a duas vezes a taxa de quadros do projeto, as posições precisam ser convertidas para a taxa do projeto para que os quadros-chave se adequem. Duas classes de taxas de informação foram criadas para lidar com este problema.

Conversões de taxas são feitas em termos da @b{taxa do projeto} e da @b{taxa requisitada}. A taxa do projeto é idêntica para todos os plugins. Ela é determinada pela janela de @b{configurações->formato}. A taxa requisitada é determinada pelo plugin mais abaixo ("downstream") requisitando informações do plugin atual. A taxa requisitada é arbitrária. Exatamente como usar essas taxas está descrito abaixo.

@c cincvdoc_node_number_305
@node Funções comuns de plugin
@section Funções comuns de plugin
@cindex Funções comuns de plugin

Todos os plugins provêm de um derivativo do PluginClient. Estes derivatidos do PluginClient implementam a maioria dos métodos requeridos no PluginClient, mas usuários ainda definem métodos para o PluginClient. Os métodos mais comumente usados são pré-definidos em macros para reduzir a digitação mas ainda assim permitir flexibilidade.

Os arquivos que eles incluem dependem do tipo de plugin. Plugins de áudio incluem @file{pluginaclient.h} e plugins de vídeo incluem @file{pluginvclient.h}. Eles são herdeiros do @b{PluginAClient} e do @b{PluginVClient} respectivamente.

O Cinelerra faz todos os plugins passarem por pelo menos duas instâncias quando eles são usados em um vídeo. Uma instância é o GUI@. A outra é o processador de sinal. A entrada do usuário, por meio de uma seqüência complicada, é propagada a partir da instância GUI para a instância do processador de sinal. Se o processador de sinal quiser alterar o GUI, ele propaga a informação de volta ao GUI. Há funções de ferramentas para se fazer isso.

Todos os plugins definem pelo menos três objetos:

@itemize @bullet
@item @b{Objeto de processamento} @*
Contém apontadores para todos os outros objetos e faz o processamento de sinal. Este objeto contém um número de buscas de informações para se identificar e é o objeto que você registra para registrar o plugin.
@item @b{Objeto da interface de usuário} @*
É definido de acordo com a discrição do programador. Ele pode ou usar uma ferramenta do Cinelerra ou outra. Ele mostra informações na tela e coleta parâmetros do usuário. @*
Usando as ferramentas do Cinelerra, o único objeto de interface de usuário com que o desenvolvedor precisa se preocupar é a Janela. A janela possui apontadores para um número de widgets, alguns métodos de inicialização e um apontador de volta ao objeto de processamento do plugin. Esta documentação se refere ao uso das ferramentas do Cinelerra. @*
Dependendo das ferramentas de interface do usuário, um assunto de interface de usuário pode ser criado para rodar a interface de usuário de forma assíncrona de todo o resto. Sincronizar a interface de usuário a mudanças na configuração do plugin é o aspecto mais complicado do plugin, então o assunto na interface de usuário e e o objeto serão pesadamente spuortados por macros se você usa as ferramentas do Cinelerra.
@item @b{Objeto de configuração} @*
Armazena os parâmetros de usuário e sempre requere interpolação, cópia e funções de comparação. Macros para o cliente de plugin automaticamente chamam métodos de configuração para interpolar quadros-chave.
@end itemize

@menu
* O objeto de processamento::
* O objeto de configuração::
* O objeto da interface de usuário::
@end menu

@c cincvdoc_node_number_306
@node O objeto de processamento
@subsection O objeto de processamento
@cindex O objeto de processamento

Carregue um plugin simples como o Ganho para ver como esse objeto se parece. O objeto de processamento deve ser herdado do derivativo PluginClient desejado. Este construtor deve levar um argumento do PluginServer. @*
@code{MyPlugin(PluginServer *server);}

Na implementação, o plugin deve conter uma linha de registro com o nome do objeto de processamento, como @*
@code{REGISTER_PLUGIN(MyPlugin)}

O construtor deve conter @*
@code{PLUGIN_CONSTRUCTOR_MACRO} @*
para inicializar as variáveis mais comuns.

O objeto de processamento deve ter um destrutor contendo @*
@code{PLUGIN_DESTRUCTOR_MACRO} @*
para apagar as variáveis mais comuns.

Outra função que é útil mas não obrigatória é @*
@code{int is_multichannel();} @*
Ela deve retornar 1 se uma instância do plugin suporta múltiplas trilhas simultaneamente ou 0 se uma instância do plugin suporta apenas uma trilha. O padrão é 0 se ela estiver omitida.

Plugins multi-canais em sua função de processamento devem se referir a uma função chamada @b{PluginClient::get_total_buffers()} para determinar o número de canais.

Para simplificar a implementação de plugins tempo-real, um macro para membros comumente usados foi criado para o cabeçalho de classe ("class header"), levando o objeto de configuração e o assunto ("thread") do objeto da interface de usuário como argumentos. As definições macro se aplicam principalmente a plugins tempo-real e não são úteis em plugins não-tempo-real. Felizmente, plugins não-tempo-real são mais simples.

@code{PLUGIN_CLASS_MEMBERS(config_name, thread_name)} @*

Os membros comumente usados em PLUGIN_CLASS_MEMBERS estão descritos abaixo.

@itemize @bullet
@item @b{int load_configuration();} @*
Carrega a configuração baseada nos quadros-chave à volta e posição atual. @*
A definição de classe para load_configuration deve conter @*
@code{LOAD_CONFIGURATION_MACRO(plugin_class, config_class)}
@*
para implementar o comportamento padrão para load_configuration. Isso armazena qualquer configuração atual que esteja dentro do objeto de configuração do plugin e retorna 1 se a nova configuração diferir da configuração prévia. O valor de retorno do load_configuration é usado por outra função comumente usada, update_gui, para determinada se o GUI realmente precisa ser atualizado. @*
O objeto de configuração do plugin é sempre chamado @b{config} dentro de PLUGIN_CLASS_MEMBERS@.

@item @b{VFrame* new_picon();} @*
Cria um ícone ("picon") para ser exibido na janela de recursos. Use @*
@code{#include "picon_png.h"} @*
@code{NEW_PICON_MACRO(plugin_class)} @*
para implementar new_picon. Além disso, o usuário deveria criar um arquivo de cabeçalho @file{picon_png.h} de uma imagem PNG usando @command{pngtoh}.
@command{pngtoh} está compilado na pasta @file{guicast/ARCH}. @*
A imagem fonte PNG deve ser chamada @file{picon.png} e pode ser de qualquer formato suportado pelo PNG@.

@item @b{char* plugin_title();} @*
Retorna uma cadeia de texto identificando o plugin na janela de recursos. A cadeia deve ser única.

@item @b{void update_gui();} @*
Deve primeiro carregar a configuração, testar por um retorno de 1 e então redesenhar o GUI com os novos parâmetros. Todos os plugins usando GuiCast possuem um formato como
@verbatim
    void MyPlugin::update_gui()
    {
        if(thread)
        {
        if(load_configuration())
        {
            thread->window->lock_window();
            // update widgets here
            thread->window->unlock_window();
        }
        }
    }
@end verbatim
para suportarem concorrência e condições sem GUI@.

@item @b{int show_gui();} @*
Cria uma instância de GUI e muda o plugin para o modo GUI. Isso é implementado com @*
@code{SHOW_GUI_MACRO(plugin_class, thread_class)}

@item @b{int set_string();} @*
Muda o título da janela GUI para uma certa cadeia de caracteres. Isso é implementado com @*
@code{SET_STRING_MACRO(plugin_class)}

@item @b{void raise_window();} @*
Eleva a janela GUI para o topo da pilha. Isso é implementado com @*
@code{RAISE_WINDOW_MACRO(plugin_class)}
@end itemize

Funções importantes que o objeto de processamento deve definir são as funções que carregam e salvam informações de configuração dos quadros-chave. Essas funções são chamadas pelos macros então tudo o que você precisa se preocupar é em acessar a informação do quadro-chave. @*
@code{void save_data(KeyFrame *keyframe);} @*
@code{void read_data(KeyFrame *keyframe);}

As funções de leitura de informação são usadas apenas nos plugins tempo-real. As funções de leitura de informações traduzem ("translate") a configuração do plugin entre o argumento do KeyFrame e o objeto de configuração para o plugin. Os quadros-chave são armazenados na linha do tempo e podem mudar para cada projeto.

Use um objeto chamado @b{FileXML} para fazer toda a readução ("translation") e alguns comandos específicos para obter as informações do argumento do KeyFrame. Veja algum plugin existente para ver o uso de KeyFrame e FileXML. @*
@code{int load_defaults();} @*
@code{int save_defaults();}

As funções de carregar padrões são usadas em plugins tempo-real e plugins não-tempo-real. As funções de carregar padrões traduzem ("translate") as configurações de plugin entre um objeto BC_Hash e a configuração do plugin. O objeto BC_Hash armazena configurações em um arquivo discreto no disco para cada plugin, mas não isola configurações diferentes para projetos diferentes.

A função sobrescrevendo o @b{load_defaults} também necessita criar o objeto BC_Hash. Veja um plugin existente para ver o uso do BC_Hash.

Outros membros padrão podem ser definidos no objeto de processamento, dependendo do tipo de plugin.

@c cincvdoc_node_number_307
@node O objeto de configuração
@subsection O objeto de configuração
@cindex Objeto de configuração

O objeto de configuração é crítico para atualizações de GUI, processamento de sinal e configurações padrão em plugins tempo-real. Assegure-se que ele não seja usado em plugins não-tempo-real. O objeto de configuração não é herdado de nada e não possui dependências. Ele é simplesmente uma classe ("class") contendo três funções e variáveis específicas aos parâmetros dos plugins.

Normalmente, o objeto de configuração começa com o nome do plugin seguido por Config.
@verbatim
    class MyPluginConfig
    {
    public:
        MyPluginConfig();
@end verbatim

Seguindo o nome da classe de configuração, colocamos as três funções requeridas e as variáveis de configuração.
@verbatim
        int equivalent(MyPluginConfig &that);
        void copy_from(MyPluginConfig &that);
        void interpolate(MyPluginConfig &prev,
        MyPluginConfig &next,
        int64_t prev_position,
        int64_t next_position,
        int64_t current_position);
        float parameter1;
        float parameter2;
        int parameter3;
    };
@end verbatim

Agora você deve definir as três funções. @b{Equivalent} é chamado pelo LOAD_CONFIGURATION_MACRO para determinar se os parâmetros de configuração local são idênticos aos parâmetros de configuração no argumento. Se o equivalent retornar 0, o LOAD_CONFIGURATION_MACRO faz com que o GUI seja redesenhado. Se o equivalent retornar 1, o LOAD_CONFIGURATION_MACRO não redesenha o GUI@.

Então, há o @b{copy_from} que transfere os valores de configuração do argumento para as variáveis locais. Isso é novamente usado em LOAD_CONFIGURATION_MACRO para armazenar configurações nos temporários. Uma vez que o LOAD_CONFIGURATION_MACRO tenha replicado a configuração, ele carrega uma segunda configuração. Então, ele interpola as duas configurações para obter a configuração atual. A função de interpolação faz a interpolação e armazena o resultado nas variáveis locais.

Normalmente, a função de interpolação calcula uma fração prévia e próxima, usando os argumentos.
@verbatim
    void MyPluginConfig::interpolate(MyPluginConfig &prev,
        MyPluginConfig &next,
        int64_t prev_position,
        int64_t next_position,
        int64_t current_position
    {
        double next_scale =
        (double)(current_position - prev_position)
        / (next_position - prev_position);
        double prev_scale =
        (double)(next_position - current_position) /
        (next_position - prev_position);
@end verbatim

Então as frações são aplicadas às variáveis de configuração prévias e seguintes para chegar-se aos valores atuais.
@verbatim
        this->parameter1 =
        (float)(prev.parameter1 * prev_scale
        + next.parameter1 * next_scale);
        this->parameter2 =
        (float)(prev.parameter2 * prev_scale
        + next.parameter2 * next_scale);
        this->parameter3 =
        (int)(prev.parameter3 * prev_scale
        + next.parameter3 * next_scale);
    }
@end verbatim

Alternativamente, você pode copiar os valores do argumento de configuração prévio se nenhuma interpolação for desejada.

Este uso do objeto de configuração é o mesmo em plugins de áudio e de vídeo. Na reprodução do vídeo, a função de interpolação é chamada para cada quadro, resultando em uma interpolação suave. Na reprodução de áudio, a função de interpolação é chamada apenas uma vez para cada fragmento de console e uma vez a cada vez que o ponto de inserção se move. Isso é bom o suficiente para atualizar o GUI enquanto se seleciona regiões na linha do tempo, mas pode não ser preciso o suficiente para uma renderização realmente suave do efeito.

Para uma renderização realmente suave do áudio, você ainda pode usar load_configuration quando atualizando o GUI@. Para process_buffer, entretanto, ignore o load_configuration e escreva sua própria rotina de interpolação que carrega todos os quadros-chave em um fragmento de console e interpola cada amostra. Isso seria muito lento e difícil de se fazer um debug, resultando em uma melhoria que pode não ser audível. Porém, claro, cada país tem seus próprios malucos.

Um modo mais fácil de se conseguir uma interpolação mais suave é reduzir o fragmento de console para 1 sample. Isso teria que ser renderizado e reproduzido com o fragmento de console novamente acima de 2048, claro. Os drivers de áudio GNU/Linux não conseguem reproduzir fragmentos de 1 sample.

@c cincvdoc_node_number_308
@node O objeto da interface de usuário
@subsection O objeto da interface de usuário
@cindex Objeto da interface de usuário

O objeto da interface de usuário em seu mínimo consiste em um apontador para uma janela e apontadores para todos as funções ("widgets") na janela. Usando as ferramentas do Cinelerra, ele consiste em um derivativo da @b{BCWindow} e um derivativo de @b{Thread}. O derivativo de Thread é declarado no cabeçalho do plugin usando @*
@code{PLUGIN_THREAD_HEADER(plugin_class, thread_class, window_class)}

Então ele é definido usando @*
@code{PLUGIN_THREAD_OBJECT(plugin_class, thread_class, window_class)}

Isso, em combinação com o macro SHOW_GUI faz todo o trabalho de instanciamento da Janela. Esse sistema de duas classes é usado em plugins tempo-real mas não em plugins não-tempo-real. Plugins não-tempo-real criam e destróem seu GUI em sua função @b{get_parameters} e não há necessidade de uma Thread.

Agora a classe de janela deve ser declarada no cabeçalho do plugin. É mais fácil implementar a janela copiando um plugin existente e renomeando os símbolos. O seguinte é um esboço do que acontece. O cabeçalho do plugin deve declarar o construtor de janela usando os argumentos apropriados.
@verbatim
    #include "guicast.h"
    class MyPluginWindow : public BC_Window
    {
    public:
        MyPluginWindow(MyPluginMain *plugin, int x, int y);
@end verbatim

Isso se torna uma janela na tela, posicionada em x e y.

Ela precisa de dois métodos @*
@code{int create_objects();} @*
@code{int close_event();} @*
e um apontador de volta para o plugin @*
@code{MyPlugin *plugin;}

A definição do construtor deve conter extenções ("extents") e bandeiramentos ("flags") fazendo com que a janela seja escondida quando criada pela primeira vez. O membro create_objects põe funções ("widgets") na janela de acordo com a sintaxe do GuiCast. Um apontador para cada função que você quer sincronizar para um parâmetro de configuração é armazenado na classe de janela. Esses são atualizados na função @b{update_gui} que você definiu mais cedo para o plugin. As funções são normalmente derivativos de uma função do GuiCast e sobrescrevem funções no GuiCast para suportar eventos. Finalmente, o create_objects chama @*
@code{show_window();} @*
@code{flush();} @*
para fazer a janela aparecer toda de uma vez.

O membro close_event deve ser implementado usando @*
@code{WINDOW_CLOSE_EVENT(window_class)}

Cada função no GUI precisa detectar quando seu valor muda. No GuiCast, o método @b{handle_event} é chamado sempre que o valor mudar. No @b{handle_event}, a função então precisa chamar @b{plugin->send_configure_change()} para propagar a mudança para quaisquer cópias do plugin que estiverem processando informação.

@c cincvdoc_node_number_309
@node Plugins tempo-real
@section Plugins tempo-real
@cindex Plugins tempo-real

Plugins tempo-real devem usar PLUGIN_CLASS_MEMBERS para definir o conjunto básico de membros em seus cabeçalhos. Todos os plugins tempo-real devem definir um @*
@code{int is_realtime()}

membro retornando 1. Isso faz co mque um número de métodos seja chamado durante a reprodução ao vivo e para que o plugin possa ser usável na linha do tempo.

Plugins tempo-real devem sobrescrever um membro chamado @*
@code{process_buffer}

Esta função leva argumentos diferentes dependendo se o plugin suporta vídeo e áudio. Veja um plugin existente para descobrir quais usos se aplicam.

As principais características da função process_buffer são um buffer para armazenar a saída, a posição de início da saída e a taxa requerida de saída. Para áudio, também há um argumento de tamanho para o número de amostras.

A posição de início do buffer de saída é a amostra de menor número na linha do tempo se a reprodução for para frente e a amostra de maior número na linha do tempo se a reprodução for ao reverso. A direção a reprodução é determinada por uma das buscas de informação descritas abaixo.

Os argumentos de posição e tamanho são todos relativos à taxa de quadros e taxa de amostragem passados ao process_buffer. Este será a taxa de informação requerida e não pode ser o mesmo que a taxa de informação do projeto.

A função process_realtime deve ser inciada chamando o @b{load_configuration}. O LOAD_CONFIGURATION_MACRO retorna 1 se a configuração houver mudado.

Após determinar a configuração do plugin, uma mídia de entrada tem que ser carregada para processamento. Chame:
@verbatim
    read_frame(VFrame *buffer,
        int channel,
        int64_t start_position,
        double frame_rate)
ou
    read_samples(double *buffer,
        int channel,
        int sample_rate,
        int64_t start_position,
        int64_t len)
@end verbatim

para requisitar informação de entrada do objeto que vem antes deste plugin. A função de leitura precisa de um buffer para armazenar a informação de entrada. Isso pode ser ou um temporário que você crie no plugin ou o buffer de saída fornecido ao process_buffer se você não precisa de um temporário.

Ele também precisa de um conjunto de argumentos de posição para determinar quando você quer ler a informação de onde. A posição de início, taxa e len passados para uma função de leitura não precisam ser os mesmos que os valores recebidos pela função process_buffer. Desta forma, os plugins podem ler informação a uma taxa diferente do que a informação de saída.

O argumento de canal é apenas significante se este for um plugin multi-canal. Eles precisam ler a informação para cada trilha no valor de get_total_buffers() e processar todas as trilhas. Plugins de canais únicos devem passar 0 para channel.

Membros adicionais são implementados para manter a configuração em plugins tempo-real. Algum deles também são requeridos em plugins não-tempo-real.

@itemize @bullet
@item @b{void read_data(KeyFrame *keyframe);} @*
Carrega a informação de um quadro-chave na configuração do plugin. Dentro do quadro-chave está uma cadeia XML. Ela é mais facilmente dividida ("parsed") criando-se um objeto @b{FileXML}. Veja um plugin existente para ver como a função read_data é implementada. @*
Read data carrega informação vinda do objeto XML e armazena valores no objeto de configuração do plugin. Uma vez que objetos de configuração variam de plugin para plugin, essas funções não podem ser automatizadas.

@item @b{void save_data(KeyFrame *keyframe);} @*
Salva informação da configuração do plugin para um quadro-chave. Dentro do quadro-chave você colocará uma cadeia XML que é normalmente criada por um objeto FileXML. Veja um plugin existente para ver como a função save_data está implementada. @*
Save data salva informação de um objeto de configuração do plugin no objeto XML.

@item @b{int load_defaults();} @*
Outra forma de o plugin obter parâmetros é a partir de um arquivo de padrões. As rotinas dos padrões de carregar e salvar usam um objeto BC_Hash para dividir ("parse") o arquivo de padrões. O objeto defaults é criado em @b{load_defaults} e destruído no destrutor de plugins. Veja um plugin existente para ver como o objeto BC_Hash é usado.

@item @b{int save_defaults();} @*
Salva a configuração no objeto de padrões.
@end itemize

@c cincvdoc_node_number_310
@node Plugins não-tempo-real
@section Plugins não-tempo-real
@cindex Plugins não-tempo-real

Algumas referências para plugins não-tempo-real são @b{Normalizar} para áudio e @b{Mudar taxa de quadros} para vídeo.

Como os plugins tempo-real, @b{load_defaults} e @b{save_defaults} devem ser implementados. Nos plugins não-tempo-real, eles não são usados apenas para parâmetros padrão, mas para transferir valores da interface de usuário para o processador de sinal. Não é preciso que haja uma classe de configuração nos plugins não-tempo-real.

Contrário aos plugins tempo-real, o LOAD_CONFIGURATION_MACRO não pode ser usado no cabeçalho do plugin. Ao invés disso, os seguintes métodos devem ser definidos.

O plugin não-tempo-real deve conter um apontador para um objeto de defaults. @*
@code{BC_Hash *defaults;} @*
Ele também deve ter um apontador para uma MainProgressBar. @*
@code{MainProgressBar *progress;}

O apontador de progresso permite que plugins não-tempo-real exibam seus progressos na janela principal do Cinelerra.

O construtor para um plugin não-tempo-real não pode usar o PLUGIN_CONSTRUCTOR_MACRO mas deve chamar o @b{load_defaults} diretamente.

O destrutor, de forma semelhante, deve chamar o @b{save_defaults} e o @b{delete defaults} diretamente ao invés do PLUGIN_DESTRUCTOR_MACRO@.

@itemize @bullet
@item @b{VFrame* new_picon();} @*
@b{char* plugin_title();} @*
O uso destes é o mesmo que para plugins tempo-real.

@item @b{int is_realtime();} @*
Esta função deve retornar 0 para indicar um plugin não-tempo-real.

@item @b{int get_parameters();} @*
Aqui, o usuário deve criar um GUI, esperar pelo usuário apertar um botão de OK ou um botão de Cancelar e armazenar os parâmetros nas variáveis de plugin. Esta rotina deve retornar 0 para sucesso e 1 para falha. Desta forma, o usuário pode cancelar o efeito pelo GUI@. @*
Ao contrário do plugin tempo-real, este GUI não precisa rodar de forma assíncrona ao plugin. Ele deve bloquear a função get_parameters até que o usuário selecione OK ou Cancel.

@item @b{int load_defaults();} @*
Isso deve criar um objeto de defaults e carregar parâmetros do objeto de defaults em variáveis de plugin.

@item @b{int save_defaults();} @*
Isso deve salvar as variáveis de plugin no objeto de defaults.

@item @b{int start_loop();} @*
Se o @b{get_parameters} retornou 0 para sucesso, este é chamado uma vez para dar ao plugin uma chance para iniciar o processamento. O plugin deve instanciar o objeto de progresso com uma linha como @*
@code{progress = start_progress("MyPlugin progress...",} @*
@code{PluginClient::get_total_len());}
@*
O uso de @b{start_progress} depende de se o plugin for multi-canal ou de canal único. Se for multi-canal, você sempre poderá chamar start_progress. Se for de canal único, você primeiro precisa saber se a barra de progresso há foi iniciada em outra instância do plugin. @*
Se o @b{PluginClient::interactive} for 1, você precisa iniciar a barra de progresso. Se for 0, a barra de progresso já foi iniciada. @*
O PluginClient define o @b{get_total_len()} e @b{get_source_start()} para descrever a abrangência da linha do tempo a ser processada. As unidades são ou amostras ou quadros e à taxa do projeto.

@item @b{int process_loop} @*
Este é chamado repetidamente até que a abrangência da linha do tempo seja processada. Possui ou um buffer de amostras ou de quadros para saída e uma referência ao write_length para armazenar o número de amostras processado. Se este for um plugin de áudio, o usuário precisa chamar o @b{get_buffer_size()} para saber quantas amostras o buffer de saída pode aguentar. @*
O plugin deve usar @b{read_samples} ou @b{read_frame} para ler a entrada. Essas funções são um pouco diferentes para um plugin não-tempo-real do que são para um plugin tempo-real. @*
Elas pegam uma posição relativa ao início da linha do tempo, à taxa da linha do tempo. Então, você deve processá-lo e colocar a saída no argumento do buffer para process_loop. O write_length deve conter o número de amostras geradas se ele for áudio. @*
Finalmente, o process_loop deve testar o @b{PluginClient::interactive} e atualizar a barra de progresso se aquele for 1. @*
@code{progress->update(total_written);} @*
retorna 1 ou 0 se a barra de progresso foi cancelada. Se for 1, o process_loop deve retornar 1 para indicar um cancelamento. Além do cancelamento da barra de progresso, o @b{process_loop} deve retornar 1 quando toda a abrangência da linha do tempo for processada.

@item @b{int stop_loop();} @*
Este é chamado após que o process_loop processa seu último buffer. @*
Se o PluginClient::is_interactive for 1, este deve chamar o @b{stop_progress} no apontador da barra de progresso e apagar o apontador. Então, ele deve apagar quaisquer objetos que criou para processar em @b{start_loop}.
@end itemize

@c cincvdoc_node_number_311
@node Plugins de áudio
@section Plugins de áudio
@cindex Plugins de áudio

O plugin mais simples de áudio é o Ganho. O objeto de processamento deve incluir o @file{pluginaclient.h} e ser herdado do @b{PluginAClient}. Plugins tempo-real de áudio devem definir 
@verbatim
    int process_buffer(int64_t size,
        double **buffer,
        int64_t start_position,
        int sample_rate);
caso sejam multi-canais ou 
    int process_buffer(int64_t size,
        double *buffer,
        int64_t start_position,
        int sample_rate);
@end verbatim
caso sejam de um único canal. Estes devem retornar 0 ao sucesso ou 1 à falha. No futuro, o valor de retorno pode abortar uma renderização falha.

A função de processamento precisa requerir amostras de entrada com
@verbatim
    int read_samples(double *buffer,
        int channel,
        int sample_rate,
        int64_t start_position,
        int64_t len);
@end verbatim
Isto sempre retorna um 0. O usuário pode especificar qualquer taxa de amostragem desejada e posição de início.

Plugins de áudio não-tempo-real precisam definir
@verbatim
int process_loop(double *buffer, int64_t &write_length);
para cana único ou 
int process_loop(double **buffers, int64_t &write_length);
@end verbatim
para multi-canal. Plugins não-tempo-real usam um conjunto diferente de funções read_samples para requerer a informação de entrada. Estas são fixadas à taxa de amostragem do projeto.

@c cincvdoc_node_number_312
@node Plugins de vídeo
@section Plugins de vídeo
@cindex Plugins de vídeo

O plugin mais simples de vídeo é o Inverter. O objeto de processamento deve incluir o @file{pluginvclient.h} e ser herdado do @b{PluginVClient}. Plugins de vídeo tempo-real precisam definir
@verbatim
    int process_buffer(VFrame **frame,
        int64_t start_position,
        double frame_rate);
caso sejam multi-canais ou
    int process_buffer(VFrame *frame,
        int64_t start_position,
        double frame_rate);
@end verbatim
caso sejam de canal único.

Plugins de vídeo não-tempo-real precisam definir
@verbatim
int process_loop(VFrame *buffer);
para canal único ou
int process_loop(VFrame **buffers);
@end verbatim

para multi-canal. A quantidade de quadros gerada em um process_loop único é sempre assumida para ser 1, portanto a falta de um argumento write_length. Um retorno de 0 faz com que a renderização continue. Um retorno de 1 faz com que a renderização seja abortada.

Um conjunto de funções read_frame existem para requerer os quadros de entrada em plugins de vídeo não-tempo-real. Estes são fixados à taxa de quadros do projeto.

@c cincvdoc_node_number_313
@node Plugins de transição
@section Plugins de transição
@cindex Plugins de transição

A transição mais simples de vídeo é a @b{Varredura} e a transição de áudio mais simples é o @b{Fade cruzado}. Estes usam um subconjunto dos membros de classe padrão de plugins tempo-real, mas até agora nenhum análogo a PLUGIN_CLASS_MEMBERS foi feito para transições.

O objeto de processamento para transições de áudio ainda deve ser herdado do PluginAClient e para transições de vídeo ainda deve ser herdado do PluginVClient.

Transições podem ou não ter um GUI@. Caso elas tenham um GUI, devem também gerenciar um assunto ("thread") como plugins tempo-real. Faça isso com os mesmos macros PLUGIN_THREAD_OBJECT e PLUGIN_THREAD_HEADER como plugins tempo-real. Uma vez que há apenas um quadro-chave em uma transição, você não precisa se preocupar em atualizar o GUI do objeto de processamento como você faz com um plugin tempo-real.

Se a transição tiver um GUI, você pode usar o PLUGIN_CONSTRUCTOR_MACRO e o PLUGIN_DESTRUCTOR_MACRO para inicializar o objeto de processamento. Você também vai precisar de um objeto BC_Hash e um objeto Thread para estes macros.

Uma vez que o GUI é opcional, sobrescreva uma função chamada @b{uses_gui()} para significar se a transição terá ou não um GUI@. Retorno de 1 caso tenha e 0 caso não tenha.

Transições precisam de funções @b{load_defaults} e @b{save_defaults} de forma que a primeira vez que forem jogadas à linha do tempo elas tenham configurações úteis.

Uma função @b{read_data} e @b{save_data} toma o comando após a inserção para acessar informação específica a cada instância da transição.

A diferença mais importante entre as transições e os plugins tempo-real é a adição de um método @b{is_transition} no objeto de processamento. @b{is_transition} deve retornar 1 para significar que o plugin é uma transição.

As transições processam informação em uma função @b{process_realtime}.
@verbatim
    int process_realtime(VFrame *input,
        VFrame *output);
    int process_realtime(int64_t size,
        double *input_ptr,
        double *output_ptr);
@end verbatim
O argumento de entrada para o process_realtime é a informação para a próxima edição. O argumento de saída para o process_realtime é a informação da edição anterior.

Rotinas existem para determinar se você está relacionado ao início e final da transição.

@itemize @bullet
@item
@b{PluginClient::get_source_position()} - retorna à posição atual até o início da transição da menor amostragem nos buffers.

@item
@b{PluginClient::get_total_len()} - returna à abrangência do integrador ("integer") da transição. As unidades são ou amostras ou quadros, à taxa de informação requerida pelo primeiro plugin.
@end itemize

Usuários devem dividir a posição fonte pela abrangência total para obter a fração da transição onde a função @b{process_realtime} está.

As transições rodam a taxa de informação requerida pelo primeiro plugin da trilha. Isso pode ser diferente da taxa de informações do projeto. Uma vez que o process_realtime não possui um argumento de taxa, use @b{get_framerate()} ou @b{get_samplerate} para obter a taxa requerida.

@c cincvdoc_node_number_314
@node GUI de plugins que se atualizam durante a reprodução
@section GUI de plugins que se atualizam durante a reprodução
@cindex GUI de plugins que se atualizam durante a reprodução

Efeitos como @b{Histograma} e @b{Escopo de vídeo} precisam atualizar o GUI durante a reprodução para exibir a informação sobre o sinal. Isso é alcançado com os métodos @b{send_render_gui} e @b{render_gui}. Normalmente em process_buffer, quando o objeto de processamento quer atualizar o GUI, ele deve chamar @b{send_render_gui}. Isso deveria ser chamado apenas no process_buffer. O send_render_gui faz uma busca e eventualmente chama o @b{render_gui} na instância do GUI do plugin.

O render_gui deve ter uma seqüência como
@verbatim
    void MyPlugin::render_gui(void *data)
    {
        if(thread)
        {
        thread->window->lock_window();
        // update GUI here
        thread->window->unlock_window();
        }
    }
@end verbatim

Send_render_gui e render_gui usam um argumento, um apontador void para transferir informação do objeto de processamento para o GUI@. O usuário deve fazer uma digitação ("typecast") para este apontador para transformá-lo em algo útil.

@c cincvdoc_node_number_315
@node Busca de informações dos plugins
@section Busca de informações dos plugins
@cindex Busca de informações dos plugins

Há várias buscas de informações ("queries") úteis no PluginClient que podem ser acessadas a partir do objeto de processamento. Algumas delas possuem diferentes significados nos modos tempo-real e não-tempo-real. Elas todas dão informações sobre o sistema operacional ou o porjeto que podem ser usadas para melhorar a qualidade do processamento.

@menu
* Busca de informações de sistema:: 	Ferramentas para determinar os recursos do sistema
* Busca de informações de tempo:: 	Ferramentas para executar processamento dependente do tempo
@end menu

@c cincvdoc_node_number_316
@node Busca de informações de sistema
@subsection Busca de informações de sistema
@cindex Busca de informações de sistema

@itemize @bullet
@item @b{get_interpolation_type()} @*
Retorna o tipo de interpolação que o usuário quer para todas as operações de escala. Este é um macro da overlayframe.inc. Ele pode ser aplicado a qualquer chamada ao objeto @b{OverlayFrame}.

@item @b{get_project_smp()} @*
Dá o número de CPUs no sistema menos 1. Caso seja um processador único, será 0. Caso seja um processador dual, será 1. Este número deve ser usado para ganhar paralelismo.

@item @b{get_total_buffers()} @*
Dá o número de trilhas que um plugin multi-canal precisa para processar.
@end itemize

@c cincvdoc_node_number_317
@node Busca de informações de tempo
@subsection Busca de informações de tempo
@cindex Busca de informações de tempo

Há duas taxas para mídia que um plugin tempo-real deve saber: a taxa do projeto e a taxa requerida. Funções são providenciadas para se obter as taxas do projeto e requerida. Além disso, fazer efeitos dependentes de tempo requere usar várias funções que dizem onde você está no efeito.

@itemize @bullet
@item @b{get_project_framerate()} @*
Dá os quadros por segundo do vídeo conforme definido nas configurações do projeto.

@item @b{get_project_samplerate()} @*
Dá a amostragem por segundo do áudio conforme definida nas configurações do projeto.

@item @b{get_framerate()} @*
Dá os quadros por segundo requeridos pelo plugin após este. Esta é a taxa de quadros requerida e é a mesma que no argumento frame_rate para o process_buffer.

@item @b{get_samplerate()} @*
Dá a taxa de mostragem por segundo requerida pelo plugin após este. Esta é a taxa de amostragem requerida e é a mesma que o argumento sample_rate para o process_buffer.

@item @b{get_total_len()} @*
Dá o número de amostras ou quadros na abrangência cobrida pelo efeito, relativo à taxa de informação requerida.

@item @b{get_source_start()} @*
Para plugins tempo-real, dá a amostragem ou quadro mais baixos na abrangência do efeito à taxa de informação requerida. Para plugins não-tempo-real, é o início da abrangência da linha do tempo a ser processado.

@item @b{get_source_position()} @*
Para plugins tempo-real, é a amostra com o número mais baixo na região requerida a ser processada caso se esteja fazendo uma reprodução para frente ou a amostra com o número mais alto na região caso a reprodução esteja sendo feita ao reverso. Para vídeo, é o início do quadro caso a reprodução esteja sendo feita para frente e o quadro final caso a reprodução esteja sendo feita ao reverso. A posição é relativa ao início da EDL e é a taxa de informação requerida. @*
Para transições, este sempre será a amostra com o número mais baixo da região a ser processada relativa ao início da transição.

@item @b{get_direction()} @*
Dá a direção da operação atual de reprodução. Isto é um macro definido em transportque.inc. É útil para chamar funções de leitura uma vez lêem a posição das próprias funções de leitura ao início ou final de uma região a ser lida, dependendo da operação de reprodução.

@item @b{local_to_edl()} @*
@b{edl_to_local()} @*
Fazem a conversão entre a taxa de informação requerida e a taxa de informação do projeto. São usados para converter posições de quadros-chave em números que podem ser interpolados à taxa de informação requerida. A conversão é automaticamente baseada na taxa de quadros ou de amostragem dependendo do tipo do plugin.

@item @b{get_prev_keyframe(int64_t position, int is_local)} @*
@b{get_next_keyframe(int64_t position, int is_local)} @*
Estes informam o quadro-chave mais próximo antes ou depois de dada posição. A versão da definição do macro de load_configuration automaticamente obtém os quadros-chave certos, mas você pode querer fazer isso por você mesma/o. @*
O arumento de posição pode ser ou a taxa do projeto ou a taxa requerida. Marque o is_local para 1 se estiver à taxa requerida e para 0 se estiver à taxa do projeto. @*
Em cada quadro-chave, outro valor de posição diz a posição do quadro-chave relativa ao início da linha do tempo e à taxa do projeto. @*
O único jeito de conseguir uma interpolação suave entre quadros-chave é converter as posições nos objetos de quadros-chave à taxa requerida. Faça isso usando edl_to_local nas posições de quadro-chave.
@end itemize

@c cincvdoc_node_number_318
@node Usando OpenGL
@section Usando OpenGL
@cindex OpenGL, usando

Plugins tempo-real de vídeo suportam OpenGL@. Usar o OpenGL para rotinas de plugins pode acelerar bastante a reprodução já que o trabalho é feito principalmente no hardware. Infelizmente, cada rotina de OpenGL precisa de uma contrapartida de software para renderização, dobrando a quantidade de software a ser mantida. Felizmente, ter uma rotina OpenGL significa que a versão do software não precisa ser otimizada como precisava quando software era a única forma de se fazer as coisas.

Como sempre, a melhor forma de desenhar um primeiro plugin OpenGL é copiar um existente e alterá-lo. O plugin @b{Brilho} é um plugin OpenGL simples para ser copiado. Há 3 pontos principais na renderização OpenGL e um ponto para otimizar a renderização OpenGL.

@menu
* Obtendo informação OpenGL:: 			Obtendo informação de vídeo em um formulário utilizável pelo OpenGL
* Desenhando usando OpenGL:: 			O método de se desenhar vídeo em OpenGL
* Usando os sombreadores ("shaders"):: 	Rotinas para simplificar o uso do shader
* Agregando plugins:: 				Combinando rotinas OpenGL de plugins diferentes em uma só
@end menu

@c cincvdoc_node_number_319
@node Obtendo informação OpenGL
@subsection Obtendo informação OpenGL
@cindex OpenGL, obtendo informação

O primeiro problema é fazer os plugins com OpenGL-habilitado interagirem com os plugins apenas-software. Para resolver isso, toda a informação requerida para fazer a reprodução OpenGL é armazenada no objeto VFrame que é passado para o @b{process_buffer}. Para suportar 3D, o VFrame contém um PBuffer e uma textura, além das fileiras originais do VFrame.

No modo OpenGL, o VFrame tem 3 estados correspondendo à localização de sua informação de vídeo. O estado opengl é recuperado chamando-se o @b{get_opengl_state} e é configurado chamando-se o @b{set_opengl_state}. Os estados são:

@itemize @bullet
@item @b{VFrame::RAM} @*
Isso significa que a informação de vídeo é armazenada nos apontadores tradicionais de fileiras ("row"). Deve ser carregado em uma textura antes de ser desenhado usando as rotinas OpenGL.

@item @b{VFrame::TEXTURE} @*
A informação de vídeo é armazenada na memória de textura. Ela está pronta para ser desenhada usando as rotinas OpenGL.

@item @b{VFrame::SCREEN} @*
A informação de vídeo é armazenada em um buffer de quadro na placa de vídeo. Para plugins, o buffer de quadro será sempre um PBuffer. A imagem no buffer de quadro não pode ser replicada de novo a menos que ela seja lida de volta na textura e o estado opengl seja remarcado para TEXTURE@. O buffer de quadro é limitado a 8 bits por canal. Se um efeito OpenGL for usado em um projeto de ponto flutuante ("floating point"), ele retém apenas 8 bits.
@end itemize

Na rotina do @b{process_buffer} do plugin, há normalmente uma chamada para o @b{read_frame} para obter informação do plugin anterior da cadeia. O @b{read_frame} leva um novo parâmetro chamado @b{use_opengl}.

O plugin passa 1 para o @b{use_opengl} caso deseje suportar a informação usando OpenGL@. Ele passa 0 para o @b{use_opengl} caso possa suportar a informação somente usando software. O valor de @b{use_opengl} é passado para cima na cadeia para assegurar que um plugin que apenas use software receba informação apenas em seus apontadores de fileiras ("row pointers"). Se o @b{use_opengl} for 0, o estado opengl no VFrame é RAM@.

O plugin não deve apenas saber se ele é software-apenas, mas se sua saída deve ser software-apenas. Chame @b{get_use_opengl} para determinar se a saída pode ser suportada pelo OpenGL@. Caso o @b{get_use_opengl} reture 0, o plugin deve passar 0 para o @b{use_opengl} em @b{read_frame} e fazer seu processamento no software. Caso o @b{get_use_opengl} seja 1, o plugin pode decidir baseado em sua implementação se usará OpenGL@.

O maior problema com o OpenGL é que todas as chamadas do gl... precisam ser rodadas a partir do mesmo assunto ("thread"). Para contornar isso, a interface do plugin possui rotinas para rodar o OpenGL em um assunto comum.

O @b{run_opengl} transfere o controle para o assunto comum OpenGL. Isso é normalmente chamado pelo plugin em @b{process_buffer} após ele haver chamado o @b{read_frame} e apenas se o @b{get_use_opengl} for 1.

Por uma série de indireções, o @b{run_opengl} eventualmente transfere o controle para uma função virtual chamada @b{handle_opengl}. O @b{handle_opengl} deve ser sobrescrito com uma função para rodar todas as rotinas OpenGL. Os conteúdos do @b{handle_opengl} devem ser fechados em @b{#ifdef HAVE_GL} ... @b{#endif} para permitir que eles sejam compiladom em sistemas que não possuam suporte a gráficos, como nódulos de renderização. O valor de retorno do @b{handle_opengl} é passado de volta do @b{run_opengl}.

O @b{read_frame} não pode ser chamado de dentro do @b{handle_opengl}. Isso criaria uma trava recursiva porque faria outros objetos chamarem o @b{run_opengl}.

Uma vez dentro do @b{handle_opengl}, o plugin possui o uso completo de todas as funções OpenGL. O VFrame oferece algumas funções para automatizar seqüências comuns de OpenGL.

O argumento do VFrame para o @b{process_buffer} é sempre disponível via a função @b{get_output(int layer)}. Caso o plugin seja multi-canal, o argumento de camada ("layer") obtém uma camada específica dos buffers de saída. O PBuffer do buffer de saída é onde a saída do OpenGL deve ir caso qualquer processamento seja feito.

@c cincvdoc_node_number_320
@node Desenhando usando OpenGL
@subsection Desenhando usando OpenGL
@cindex Desenhando usando OpenGL

A seqüência de comandos para desenhar na saída do PBuffer começa com fazer o vídeo em uma área de memória onde ele possa ser re-chamado para desenho: @*
@code{get_output()->to_texture();} @*
@code{get_output()->enable_opengl();} @*
@itemize @bullet
@item @b{to_texture} transfere a informação OpenGL de onde ela estiver para a memória de textura de saída e marca o estado de saída para TEXTURE@.
@item @b{enable_opengl} faz o contexto OpenGL relativo à saída do PBuffer.
@end itemize

O próximo passo é desenhar a textura com algum processamento no PBuffer. A seqüência normal de comandos para desenhar uma textura é: @*
@code{get_output()->init_screen();} @*
@code{get_output()->bind_texture(0);} @*
@code{get_output()->draw_texture();}

@itemize @bullet
@item @b{VFrame::init_screen} marca o frustum do OpenGL e os parâmetros para valores conhecidos.
@item @b{VFrame::bind_texture(int texture_unit)} amarra a textura à unidade dada de textura e a habilita.
@item @b{VFrame::draw_texture()} chama as funções de vertex para desenhar a textura normalizada ao tamanho do PBuffer. Copie isso se você quer vértices padrão ("custom").
@end itemize

O último passo na rotina do handle_opengl, após a textura ser desenhada no PBuffer, é marcar a saída do estado opengl para SCREEN com uma chamada para @b{VFrame::set_opengl_state}. O plugin não deve ler de volta o buffer de quadro em uma textura ou apontadores de fileira caso não haja mais processamento. Os plugins devem apenas deixar a saída na textura ou RAM caso sua localização resulte de um processamento normal. Eles devem marcar o estado opengl para RAM ou TEXTURE caso o façam.

@b{Modelos de cor em OpenGL:} @*
O modelo de cor exposto a rotinas OpenGL será sempre de ponto flutuante uma vez que é isso que o OpenGL usa, mas ele pode ser YUV ou RGB dependendo das configurações do projeto. Caso seja YUV, ele é deslocado por 0.5 como em software. Passar modelos de cor YUV a plugins era necessário pela velocidade. A outra opção era converter YUV para RGB no primeiro passo que requeria OpenGL@. Cada efeito e passo de renderização teria necessitado de uma rotina YUV para RGB. Com o YUV retido, apenas o passo de composição final  precisa de uma rotina YUV para RGB.

@c cincvdoc_node_number_321
@node Usando os sombreadores ("shaders")
@subsection Usando os sombreadores ("shaders")
@cindex OpenGL, usando shaders

Muito poucos efeitos conseguem fazer alguma coisa útil com apenas um desenho direto na textura do PBuffer. Eles normalmente precisam definir um sombreamento ("shader"). O sombreador é um programa em C que roda na placa de gráfico. Uma vez que a placa de gráficos esteja otimizada para gráficos, ela pode ser muito mais rápida do que rodá-lo na CPU@.

Sombreadores são escritos na linguagem OpenGL Shading Language. O código-fonte do sombreador é contido em uma cadeia. A seqüência normal para se usar um sombreador vem após uma chamada para o @b{enable_opengl}.

@code{char *shader_source = "...";} @*
@code{unsigned char shader_id = VFrame::make_shader(0, shader_source, 0);} @*
@code{glUseProgram(shader_id);} @*
@code{// Set uniform variables using glUniform commands}

A compilação e o passo de se fazer liks para os sombreadores é encapsulado pelo comando VFrame::make_shader. Ele retorna um shader_id que pode ser passado para as funções OpenGL. O primeiro e último argumentos devem ser sempre 0. Um número arbitrário de cadeias de fonte pode ser colocado entre os 0s. As cadeias de fonte são concatenadas pelo make_shader em um fonte de sombreador gigante. Caso múltiplas funções principais estejam nos fontes, as funções principais são renomeadas e rodadas em ordem.

Há um número de macros úteis para sombreadores no @file{playback3d.h}. Todos os sombreadores até agora tem sido sombreadores de fragmento. Após o sombreador ser inicializado, desenhe a textura iniciando pelo @b{init_screen}. O programa sombreador deve ser desabilitado com outra chamada para @b{glUseProgram(0)} e 0 como argumento.

O shader_id e código fonte são armazenados na memória enquanto o Cinelerra estiver rodando. Chamadas futuras para o make_shader com o mesmo código fonte rodarão muito mais rápido.

@c cincvdoc_node_number_322
@node Agregando plugins
@subsection Agregando plugins
@cindex Agregando plugins

Melhorias futuras de velocidade podem ser obtidas combinando rotinas OpenGL de dois plugins em uma função única handle_opengl. Isso é feito quando @b{Quadros para campos} e @b{RGB para 601} são unidos ("attached") em ordem. Agregações de mais de dois plugins são possíveis mas muito difíceis de se fazer funcionar. A agregação é útil para o OpenGL porque cada plugin deve copiar o vídeo de uma textura para um PBuffer. Em software não há operação de cópia.

Na agregação, um plugin processa tudo dos outros plugins e os outros plugins "fall through". Os plugins "fall through" devem copiar seus parâmetros para o buffer de saída de forma que possam ser detectados pelo plugin de processamento.

O VFrame usado como o buffer de saída contém uma tabela de parâmetro para a passagem de parâmetro entre plugins e é acessado com @b{get_output()->get_params()}. Parâmetros são marcados e obtidos na tabela que chama uma atualização ("@b{update}") e obtenção ("@b{get}") como os padrões ("defaults").

Os plugins "fall through" devem determinar se o plugin de processamento está junto com chamados para @b{next_effect_is} e @b{prev_effect_is}. Estes pegam o nome do plugin processador como um argumento de cadeia e retornam 1 caso o plugin anterior ou subseqüente é o plugin processador. Caso nenhum deles retorne 1, o plugin "fall through" ainda deve chamar o @b{read_frame} para propagar a informação mas fazer um retorno após isso.

O plugin processador deve chamar o @b{next_effect_is} e @b{prev_effect_is} para determinar se ele está agregado com um plugin "fall through". Caso esteja, deve realizar as operações do plugin "fall through" em sua rotina OpenGL. Os parâmetros para o plugin "fall through" devem estar disponíveis pelo @b{get_output()->get_params()} caso o plugin "fall through" os tenha configurado.

@c cincvdoc_node_number_323
@node Atalhos de teclado
@chapter Atalhos de teclado
@cindex Atalhos de teclado
@cindex Atalhos

Alex Ferrer começou a resumir a maioria dos atalhos de teclado.  A maioria das teclas funcionam sem qualquer modificador como @key{SHIFT} ou @key{CTRL}. A maioria das janelas podem ser fechadas com um @kbd{CTRL-w}. A maioria das operações podem ser canceladas com @key{ESC} e aceitas com @key{RET}.

@menu
* Atalhos da janela de programa::
* Atalhos das janelas Visor e Compositor::
* Atalhos de transporte de reprodução::
* Atalhos da janela de Gravação::
@end menu

@c cincvdoc_node_number_331
@node Atalhos da janela de programa
@section Janela de programa
@cindex Janela de programa

@menu
* Atalhos de edição mídia::
* Atalhos de edição de marcadores e pontos de entrada/saída::
* Atalhos de navegação::
* Atalhos de operações de arquivo::
* Atalhos de edição de quadros-chave::
* Atalhos de manipulação de trilhas::
* Atalhos do que é desenhado na linha do tempo::
@end menu

@c cincvdoc_node_number_332
@node Atalhos de edição mídia
@subsection Atalhos de edição mídia
@cindex Atalhos, edição de mídia

@multitable @columnfractions .2 .8
@item @kbd{z}
@tab Desfazer
@item @kbd{SHIFT Z}
@tab Refazer
@item @kbd{x}
@tab Cortar
@item @kbd{c}
@tab Copiar
@item @kbd{v}
@tab Colar
@item @kbd{Del}
@tab Limpar
@item @kbd{SHIFT Space}
@tab Inserir silêncio
@item @kbd{m}
@tab Tornar região muda
@item @kbd{a}
@tab Selecionar tudo
@item @kbd{clicar-com-o-SHIFT}
@tab Quando feito por sobre uma edição, faz com que a região selecionada seja extendida para a posição do cursor. Quando feita por sobre o limite de um efeito, faz com que a operação de arraste ("trim") seja aplicada a um efeito.
@item @kbd{e}
@tab Alterna entre os modos de edição Arrastar-e-Soltar e Recortar-e-Colar
@end multitable

@c cincvdoc_node_number_333
@node Atalhos de edição de marcadores e pontos de entrada/saída
@subsection Atalhos de edição de marcadores e pontos de entrada/saída
@cindex Atalhos de edição de marcadores e pontos de entrada/saída

@multitable @columnfractions .2 .8
@item @kbd{[}
@tab Insere ou retira um ponto de entrada
@item @kbd{]}
@tab Insere ou retira um ponto de saída
@item @kbd{l}
@tab Insere ou retira um marcador na posição atual
@item @kbd{CTRL <-}
@tab Ir para marcador anterior
@item @kbd{CTRL ->}
@tab Ir para o próximo marcador
@end multitable

@c cincvdoc_node_number_334
@node Atalhos de navegação
@subsection Atalhos de navegação
@cindex Atalhos de navegação

@multitable @columnfractions .2 .8
@item @kbd{Seta para a direita}
@tab Mover a linha do tempo para a direita (não o ponto de inserção) *
@item @kbd{Seta para a esquerda} 
@tab Mover a linha do tempo para a esquerda (não o ponto de inserção) *
@item @kbd{Seta para cima}
@tab Afastar Linha do Tempo *
@item @kbd{Seta para baixo}
@tab Aproximar Linha do Tempo *
@item @kbd{CTRL PARACIMA}
@tab Expandir amplitude atual da curva
@item @kbd{CTRL PARABAIXO}
@tab Diminuir amplitude atual da curva
@item @kbd{CTRL Alt PARACIMA}
@tab Expandir todas as amplitudes de curva
@item @kbd{Ctrl Alt PARABAIXO}
@tab Diminuir todas as amplitudes de curva
@item @kbd{Alt PARACIMA}
@tab Expandir amplitude de curva
@item @kbd{Alt PARABAIXO}
@tab Diminuir amplitude de curva
@item @kbd{f}
@tab Ajustar o tempo exibido à seleção
@item @kbd{Alt f}
@tab Fazer a abrangência de todos os tipos de automação. Ajusta a abrangência máxima e mínima da seleção atual
@item @kbd{Ctrl Alt f}
@tab Fazer a abrangência do tipo de automação atualmente selecionado ajustar à abrangência máxima e mínima da região selecionada
@item @kbd{Alt Seta-para-equerda}
@tab Move o ponto de inserção para o próximo bloco de edição à esquerda
@item @kbd{Alt Seta-para-direita}
@tab Move o ponto de inserção para o próximo bloco de edição à direita
@item @kbd{Page Up}
@tab Move a linha do tempo para cima *
@item @kbd{Page Dn}
@tab Move a linha do tempo para baixo *
@item @kbd{Ctrl Page Up}
@tab Expandir altura da trilha
@item @kbd{Ctrl Page Dn}
@tab Diminuir altura da trilha
@item @kbd{Home}
@tab Move o ponto de inserção para o início da Linha do Tempo *
@item @kbd{End}
@tab Move o ponto de inserção para o final da Linha do Tempo *
@end multitable

* Você pode ter que clicar na Linha do Tempo para desativar quaisquer caixas de texto antes que estes funcionem.

@c cincvdoc_node_number_335
@node Atalhos de operações de arquivo
@subsection Atalhos de operações de arquivo
@cindex Atalhos de operações de arquivo

@multitable @columnfractions .2 .8
@item @kbd{n}
@tab Novo projeto
@item @kbd{o}
@tab Carregar arquivos
@item @kbd{s}
@tab Salvar projeto
@item @kbd{r}
@tab Gravar
@item @kbd{SHIFT R}
@tab Render
@item @kbd{q}
@tab Sair
@item @kbd{SHIFT P}
@tab Preferências
@item @kbd{SHIFT B}
@tab Renderização em grupo
@item @kbd{SHIFT F}
@tab Configurar formato
@item @kbd{}
@tab
@end multitable

@c cincvdoc_node_number_336
@node Atalhos de edição de quadros-chave
@subsection Atalhos de edição de quadros-chave
@cindex Quadros-chave, atalhos de edição

@multitable @columnfractions .2 .8
@item @kbd{SHIFT X}
@tab Cortar quadros-chave
@item @kbd{SHIFT C}
@tab Copiar quadros-chave
@item @kbd{SHIFT V}
@tab Colar quadros-chave
@item @kbd{SHIFT Del}
@tab Limpar quadros-chave
@item @kbd{Alt c}
@tab Copiar quadro-chave padrão
@item @kbd{Alt v}
@tab Colar quadro-chave padrão
@end multitable

@c cincvdoc_node_number_337
@node Atalhos de manipulação de trilhas
@subsection Atalhos de manipulação de trilhas
@cindex Atalhos de manipulação de trilhas

@multitable @columnfractions .2 .8
@item @kbd{t}
@tab Adicionar trilha de áudio
@item @kbd{u}
@tab Inserir transição de áudio padrão
@item @kbd{SHIFT T}
@tab Adicionar trilha de vídeo
@item @kbd{SHIFT U}
@tab Inserir transição de vídeo padrão
@item @kbd{d}
@tab Apagar a última trilha
@item @kbd{SHIFT L}
@tab Reprodução em loop
@item @kbd{TAB}
@tab Ativa/desativa status de armação de trilha única
@item @kbd{SHIFT-TAB}
@tab Ativa/desativa status de armação de a cada outra trilha
@end multitable

@c cincvdoc_node_number_338
@node Atalhos do que é desenhado na linha do tempo
@subsection Atalhos do que é desenhado na linha do tempo
@cindex Linha do tempo, atalhos do que é desenhado

@multitable @columnfractions .2 .8
@item @kbd{1}
@tab Mostrar títulos
@item @kbd{2}
@tab Mostrar transições
@item @kbd{3}
@tab Quadros-chave de fade
@item @kbd{4}
@tab Quadros-chave mudez
@item @kbd{5}
@tab Quadros-chave de modo
@item @kbd{6}
@tab Quadros-chave de pan
@item @kbd{7}
@tab Quadros-chave de câmera
@item @kbd{8}
@tab Quadros-chave de projetor
@item @kbd{9}
@tab Quadros-chave de plugins
@item @kbd{0}
@tab Quadros-chave de máscara
@item @kbd{-}
@tab Aproximação de câmera
@item @kbd{=}
@tab Aproximação de projetor
@end multitable

@c cincvdoc_node_number_339
@node Atalhos das janelas Visor e Compositor
@section Atalhos das janelas Visor e Compositor
@cindex Atalhos das janelas Visor e Compositor

@multitable @columnfractions .2 .8
@item @kbd{x}
@tab Cortar
@item @kbd{c}
@tab Copiar
@item @kbd{v}
@tab Colar
@item @kbd{v}
@tab Dividir
@item @kbd{b}
@tab Sobrescrever
@item @kbd{[}
@tab Adicionar/retirar ponto de entrada
@item @kbd{]}
@tab Adicionar/retirar ponto de saída
@item @kbd{l}
@tab Adicionar/retirar marcador na posição atual
@item @kbd{Ctrl <-}
@tab Ir para o marcador anterior
@item @kbd{Ctrl ->}
@tab Ir para o próximo marcador
@item @kbd{Home}
@tab Ir para o início
@item @kbd{End}
@tab Ir para o final
@item @kbd{z}
@tab Desfazer
@item @kbd{SHIFT Z}
@tab Refazer
@item @kbd{+}
@tab Aproximar
@item @kbd{-}
@tab Afastar
@end multitable

@c cincvdoc_node_number_340
@node Atalhos de transporte de reprodução
@section Atalhos de transporte de reprodução
@cindex Atalhos de transporte de reprodução

Os controles de transporte funcionam em qualquer janela que possua um transporte de reprodução. Eles são acessados por meio do teclado de números com a função 'num lock' desabilitada.

@multitable @columnfractions .08 .17 .08 .17 .08 .17 .08 .17
@item @kbd{4}
@tab Quadro anterior
@tab @kbd{5}
@tab Reverso lento
@tab @kbd{6}
@tab Reprodução reversa
@tab @kbd{+}
@tab Reverso rápido
@item @kbd{1}
@tab Quadro seguinte
@tab @kbd{2}
@tab À frente devagar
@tab @kbd{3}
@tab Reproduzir
@tab @kbd{Enter}
@tab À frente rápido
@item @kbd{0}
@tab Parar
@tab
@tab
@tab
@tab
@tab
@tab
@end multitable

@key{SPACE} é o Reproduzir ("Play") normal; pressionar qualquer tecla duas vezes é Pausa.

Pressionar qualquer controle de transporte com o @key{CTRL} pressionado faz com que apenas a região entre os pontos de entrada/saída sejam reproduzidos, caso pontos de entrada/saída sejam definidos.

@c cincvdoc_node_number_341
@node Atalhos da janela de Gravação
@section Atalhos da janela de Gravação
@cindex Atalhos da janela de Gravação

@multitable @columnfractions .2 .8
@item @kbd{Space}
@tab Inicia e pausa a gravação do grupo atual
@item @kbd{l}
@tab Insere/retira marcador na posição atual
@end multitable

@include gpl_en.texi

@ifnotplaintext
@ifnothtml
@ifnotdocbook
@node Índice
@unnumbered Índice
@printindex cp
@end ifnotdocbook
@end ifnothtml
@end ifnotplaintext

@bye

